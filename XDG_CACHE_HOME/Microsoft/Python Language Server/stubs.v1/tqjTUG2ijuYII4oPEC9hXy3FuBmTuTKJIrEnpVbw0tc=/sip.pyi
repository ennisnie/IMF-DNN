import builtins as _mod_builtins

SIP_VERSION = 267016
SIP_VERSION_STR = '4.19.8'
_C_API = _mod_builtins.PyCapsule()
__doc__ = None
__file__ = '/home/nj/.conda/envs/cs231n/lib/python3.6/site-packages/sip.so'
__name__ = 'sip'
__package__ = ''
def _unpickle_enum():
    pass

def _unpickle_type():
    pass

def assign():
    pass

def cast():
    pass

def delete():
    pass

def dump():
    pass

def enableautoconversion():
    pass

def enableoverflowchecking():
    pass

def getapi():
    pass

def isdeleted():
    pass

def ispycreated():
    pass

def ispyowned():
    pass

def setapi():
    pass

def setdeleted():
    pass

def setdestroyonexit():
    pass

def settracemask():
    pass

class simplewrapper(_mod_builtins.object):
    __class__ = simplewrapper
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def transferback():
    pass

def transferto():
    pass

def unwrapinstance():
    pass

class voidptr(_mod_builtins.object):
    def __bool__(self):
        'self != 0'
        return False
    
    __class__ = voidptr
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __int__(self):
        'int(self)'
        return 0
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def asarray(self):
        pass
    
    def ascapsule(self):
        pass
    
    def asstring(self):
        pass
    
    def getsize(self):
        pass
    
    def getwriteable(self):
        pass
    
    def setsize(self):
        pass
    
    def setwriteable(self):
        pass
    

def wrapinstance():
    pass

class wrapper(simplewrapper):
    __class__ = wrapper
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class wrappertype(_mod_builtins.type):
    __base__ = _mod_builtins.type
    __bases__ = ()
    __basicsize__ = 904
    __class__ = wrappertype
    def __delattr__(self, name):
        'Implement delattr(self, name).'
        return None
    
    __dict__ = {}
    __dictoffset__ = 264
    __flags__ = 2148291584
    def __getattribute__(self, name):
        'Return getattr(self, name).'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'sip'
    __mro__ = ()
    __name__ = 'wrappertype'
    @classmethod
    def __prepare__(cls, name, bases, **kwds):
        '__prepare__() -> dict\nused to create the namespace for the class statement'
        return dict()
    
    __qualname__ = 'wrappertype'
    def __setattr__(self, name, value):
        'Implement setattr(self, name, value).'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    __weakrefoffset__ = 368

