import PyQt5.QtCore as _mod_PyQt5_QtCore
import sip as _mod_sip

class QAbstractOpenGLFunctions(_mod_sip.wrapper):
    __class__ = QAbstractOpenGLFunctions
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class QAbstractTextDocumentLayout(_mod_PyQt5_QtCore.QObject):
    'QAbstractTextDocumentLayout(QTextDocument)'
    PaintContext = PaintContext()
    Selection = Selection()
    __class__ = QAbstractTextDocumentLayout
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QAbstractTextDocumentLayout(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def anchorAt(cls, self, UnionQPointF=None, QPoint=None):
        'anchorAt(self, Union[QPointF, QPoint]) -> str'
        return ''
    
    @classmethod
    def blockBoundingRect(cls, self, QTextBlock):
        'blockBoundingRect(self, QTextBlock) -> QRectF'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def documentChanged(cls, self, int, int_, int_1):
        'documentChanged(self, int, int, int)'
        pass
    
    @classmethod
    def documentSize(cls, self):
        'documentSize(self) -> QSizeF'
        pass
    
    def documentSizeChanged(self, QSizeF):
        'documentSizeChanged(self, QSizeF) [signal]'
        pass
    
    @classmethod
    def draw(cls, self, QPainter, QAbstractTextDocumentLayoutPaintContext):
        'draw(self, QPainter, QAbstractTextDocumentLayout.PaintContext)'
        pass
    
    @classmethod
    def drawInlineObject(cls, self, QPainter, QRectF, QTextInlineObject, int, QTextFormat):
        'drawInlineObject(self, QPainter, QRectF, QTextInlineObject, int, QTextFormat)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self, int):
        'format(self, int) -> QTextCharFormat'
        pass
    
    @classmethod
    def formatAt(cls, self, UnionQPointF=None, QPoint=None):
        'formatAt(self, Union[QPointF, QPoint]) -> QTextFormat'
        pass
    
    @classmethod
    def frameBoundingRect(cls, self, QTextFrame):
        'frameBoundingRect(self, QTextFrame) -> QRectF'
        pass
    
    @classmethod
    def handlerForObject(cls, self, int):
        'handlerForObject(self, int) -> QTextObjectInterface'
        pass
    
    @classmethod
    def hitTest(cls, self, UnionQPointF=None, QPoint=None, QtHitTestAccuracy=None):
        'hitTest(self, Union[QPointF, QPoint], Qt.HitTestAccuracy) -> int'
        return 1
    
    @classmethod
    def imageAt(cls, self, UnionQPointF=None, QPoint=None):
        'imageAt(self, Union[QPointF, QPoint]) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def pageCount(cls, self):
        'pageCount(self) -> int'
        return 1
    
    def pageCountChanged(self, int):
        'pageCountChanged(self, int) [signal]'
        pass
    
    @classmethod
    def paintDevice(cls, self):
        'paintDevice(self) -> QPaintDevice'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def positionInlineObject(cls, self, QTextInlineObject, int, QTextFormat):
        'positionInlineObject(self, QTextInlineObject, int, QTextFormat)'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def registerHandler(cls, self, int, QObject):
        'registerHandler(self, int, QObject)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def resizeInlineObject(cls, self, QTextInlineObject, int, QTextFormat):
        'resizeInlineObject(self, QTextInlineObject, int, QTextFormat)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setPaintDevice(cls, self, QPaintDevice):
        'setPaintDevice(self, QPaintDevice)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def unregisterHandler(cls, self, int, component: QObject=None):
        'unregisterHandler(self, int, component: QObject = None)'
        pass
    
    def update(self, QRectF=QRectF(0,0,1e+09,1e+09)):
        'update(self, QRectF = QRectF(0,0,1e+09,1e+09)) [signal]'
        pass
    
    def updateBlock(self, QTextBlock):
        'updateBlock(self, QTextBlock) [signal]'
        pass
    

class QActionEvent(_mod_PyQt5_QtCore.QEvent):
    'QActionEvent(int, QAction, before: QAction = None)\nQActionEvent(QActionEvent)'
    __class__ = QActionEvent
    __dict__ = {}
    def __init__(self, int, QAction, before: QAction=None):
        'QActionEvent(int, QAction, before: QAction = None)\nQActionEvent(QActionEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def action(cls, self):
        'action(self) -> QAction'
        pass
    
    @classmethod
    def before(cls, self):
        'before(self) -> QAction'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QBackingStore(_mod_sip.simplewrapper):
    'QBackingStore(QWindow)'
    __class__ = QBackingStore
    __dict__ = {}
    def __init__(self, QWindow):
        'QBackingStore(QWindow)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def beginPaint(cls, self, QRegion):
        'beginPaint(self, QRegion)'
        pass
    
    @classmethod
    def endPaint(cls, self):
        'endPaint(self)'
        pass
    
    @classmethod
    def flush(cls, self, QRegion, window: QWindow=None, offset: QPoint=QPoint()):
        'flush(self, QRegion, window: QWindow = None, offset: QPoint = QPoint())'
        pass
    
    @classmethod
    def hasStaticContents(cls, self):
        'hasStaticContents(self) -> bool'
        return True
    
    @classmethod
    def paintDevice(cls, self):
        'paintDevice(self) -> QPaintDevice'
        pass
    
    @classmethod
    def resize(cls, self, QSize):
        'resize(self, QSize)'
        pass
    
    @classmethod
    def scroll(cls, self, QRegion, int, int_):
        'scroll(self, QRegion, int, int) -> bool'
        return True
    
    @classmethod
    def setStaticContents(cls, self, QRegion):
        'setStaticContents(self, QRegion)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def staticContents(cls, self):
        'staticContents(self) -> QRegion'
        pass
    
    @classmethod
    def window(cls, self):
        'window(self) -> QWindow'
        pass
    

class QBitmap(QPixmap):
    'QBitmap()\nQBitmap(QBitmap)\nQBitmap(QPixmap)\nQBitmap(int, int)\nQBitmap(QSize)\nQBitmap(str, format: str = None)\nQBitmap(Any)'
    __class__ = QBitmap
    __dict__ = {}
    def __init__(self, str, format: str=None):
        'QBitmap()\nQBitmap(QBitmap)\nQBitmap(QPixmap)\nQBitmap(int, int)\nQBitmap(QSize)\nQBitmap(str, format: str = None)\nQBitmap(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def cacheKey(cls, self):
        'cacheKey(self) -> int'
        return 1
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def convertFromImage(cls, self, QImage, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'convertFromImage(self, QImage, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def copy(cls, self, rect: QRect=QRect()):
        'copy(self, rect: QRect = QRect()) -> QPixmap\ncopy(self, int, int, int, int) -> QPixmap'
        pass
    
    @classmethod
    def createHeuristicMask(cls, self, clipTight: bool=True):
        'createHeuristicMask(self, clipTight: bool = True) -> QBitmap'
        pass
    
    @classmethod
    def createMaskFromColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None, mode: Qt.MaskMode=Qt.MaskInColor):
        'createMaskFromColor(self, Union[QColor, Qt.GlobalColor, QGradient], mode: Qt.MaskMode = Qt.MaskInColor) -> QBitmap'
        pass
    
    @classmethod
    def defaultDepth(cls):
        'defaultDepth() -> int'
        return 1
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def detach(cls, self):
        'detach(self)'
        pass
    
    @classmethod
    def devType(cls, self):
        'devType(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def fill(cls, self, color: Union[QColor,Qt.GlobalColor,QGradient]=Qt.white):
        'fill(self, color: Union[QColor, Qt.GlobalColor, QGradient] = Qt.white)'
        pass
    
    @classmethod
    def fromData(cls, QSize, bytes, format: QImage.Format=QImage.Format_MonoLSB):
        'fromData(QSize, bytes, format: QImage.Format = QImage.Format_MonoLSB) -> QBitmap'
        pass
    
    @classmethod
    def fromImage(cls, QImage, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'fromImage(QImage, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QBitmap'
        pass
    
    @classmethod
    def fromImageReader(cls, QImageReader, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'fromImageReader(QImageReader, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QPixmap'
        pass
    
    @classmethod
    def hasAlpha(cls, self):
        'hasAlpha(self) -> bool'
        return True
    
    @classmethod
    def hasAlphaChannel(cls, self):
        'hasAlphaChannel(self) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def isQBitmap(cls, self):
        'isQBitmap(self) -> bool'
        return True
    
    @classmethod
    def load(cls, self, str, format: str=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'load(self, str, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def loadFromData(cls, self, UnionQByteArray=None, bytes=None, bytearray=None, format: str=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'loadFromData(self, bytes, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool\nloadFromData(self, Union[QByteArray, bytes, bytearray], format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QBitmap'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRect'
        pass
    
    @classmethod
    def save(cls, self, QIODevice, format: str=None, quality: int=-1):
        'save(self, str, format: str = None, quality: int = -1) -> bool\nsave(self, QIODevice, format: str = None, quality: int = -1) -> bool'
        return True
    
    @classmethod
    def scaled(cls, self, int, int_, aspectRatioMode: Qt.AspectRatioMode=Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode=Qt.FastTransformation):
        'scaled(self, int, int, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap\nscaled(self, QSize, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scaledToHeight(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToHeight(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scaledToWidth(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToWidth(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scroll(cls, self, int, int_, int_1, int_2, int_3, int_4):
        'scroll(self, int, int, QRect) -> QRegion\nscroll(self, int, int, int, int, int, int) -> QRegion'
        pass
    
    @classmethod
    def setDevicePixelRatio(cls, self, float):
        'setDevicePixelRatio(self, float)'
        pass
    
    @classmethod
    def setMask(cls, self, QBitmap):
        'setMask(self, QBitmap)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def swap(cls, self, QBitmap):
        'swap(self, QBitmap)'
        pass
    
    @classmethod
    def toImage(cls, self):
        'toImage(self) -> QImage'
        pass
    
    @classmethod
    def transformed(cls, self, QTransform):
        'transformed(self, QTransform) -> QBitmap'
        pass
    
    @classmethod
    def trueMatrix(cls, QTransform, int, int_):
        'trueMatrix(QTransform, int, int) -> QTransform'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QBrush(_mod_sip.simplewrapper):
    'QBrush()\nQBrush(Qt.BrushStyle)\nQBrush(Union[QColor, Qt.GlobalColor, QGradient], style: Qt.BrushStyle = Qt.SolidPattern)\nQBrush(Union[QColor, Qt.GlobalColor, QGradient], QPixmap)\nQBrush(QPixmap)\nQBrush(QImage)\nQBrush(Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nQBrush(Any)'
    __class__ = QBrush
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, UnionQColor=None, QtGlobalColor=None, QGradient=None, style: Qt.BrushStyle=Qt.SolidPattern):
        'QBrush()\nQBrush(Qt.BrushStyle)\nQBrush(Union[QColor, Qt.GlobalColor, QGradient], style: Qt.BrushStyle = Qt.SolidPattern)\nQBrush(Union[QColor, Qt.GlobalColor, QGradient], QPixmap)\nQBrush(QPixmap)\nQBrush(QImage)\nQBrush(Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nQBrush(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def color(cls, self):
        'color(self) -> QColor'
        pass
    
    @classmethod
    def gradient(cls, self):
        'gradient(self) -> QGradient'
        pass
    
    @classmethod
    def isOpaque(cls, self):
        'isOpaque(self) -> bool'
        return True
    
    @classmethod
    def setColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColor(self, Union[QColor, Qt.GlobalColor, QGradient])\nsetColor(self, Qt.GlobalColor)'
        pass
    
    @classmethod
    def setStyle(cls, self, QtBrushStyle):
        'setStyle(self, Qt.BrushStyle)'
        pass
    
    @classmethod
    def setTexture(cls, self, QPixmap):
        'setTexture(self, QPixmap)'
        pass
    
    @classmethod
    def setTextureImage(cls, self, QImage):
        'setTextureImage(self, QImage)'
        pass
    
    @classmethod
    def setTransform(cls, self, QTransform):
        'setTransform(self, QTransform)'
        pass
    
    @classmethod
    def style(cls, self):
        'style(self) -> Qt.BrushStyle'
        pass
    
    @classmethod
    def swap(cls, self, QBrush):
        'swap(self, QBrush)'
        pass
    
    @classmethod
    def texture(cls, self):
        'texture(self) -> QPixmap'
        pass
    
    @classmethod
    def textureImage(cls, self):
        'textureImage(self) -> QImage'
        pass
    
    @classmethod
    def transform(cls, self):
        'transform(self) -> QTransform'
        pass
    

class QClipboard(_mod_PyQt5_QtCore.QObject):
    Clipboard = Mode()
    FindBuffer = Mode()
    Mode = Mode()
    Selection = Mode()
    __class__ = QClipboard
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    def changed(self, QClipboardMode):
        'changed(self, QClipboard.Mode) [signal]'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def clear(cls, self, mode: QClipboard.Mode=QClipboard.Clipboard):
        'clear(self, mode: QClipboard.Mode = QClipboard.Clipboard)'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    def dataChanged(self):
        'dataChanged(self) [signal]'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    def findBufferChanged(self):
        'findBufferChanged(self) [signal]'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def image(cls, self, mode: QClipboard.Mode=QClipboard.Clipboard):
        'image(self, mode: QClipboard.Mode = QClipboard.Clipboard) -> QImage'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def mimeData(cls, self, mode: QClipboard.Mode=QClipboard.Clipboard):
        'mimeData(self, mode: QClipboard.Mode = QClipboard.Clipboard) -> QMimeData'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def ownsClipboard(cls, self):
        'ownsClipboard(self) -> bool'
        return True
    
    @classmethod
    def ownsFindBuffer(cls, self):
        'ownsFindBuffer(self) -> bool'
        return True
    
    @classmethod
    def ownsSelection(cls, self):
        'ownsSelection(self) -> bool'
        return True
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def pixmap(cls, self, mode: QClipboard.Mode=QClipboard.Clipboard):
        'pixmap(self, mode: QClipboard.Mode = QClipboard.Clipboard) -> QPixmap'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    def selectionChanged(self):
        'selectionChanged(self) [signal]'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setImage(cls, self, QImage, mode: QClipboard.Mode=QClipboard.Clipboard):
        'setImage(self, QImage, mode: QClipboard.Mode = QClipboard.Clipboard)'
        pass
    
    @classmethod
    def setMimeData(cls, self, QMimeData, mode: QClipboard.Mode=QClipboard.Clipboard):
        'setMimeData(self, QMimeData, mode: QClipboard.Mode = QClipboard.Clipboard)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setPixmap(cls, self, QPixmap, mode: QClipboard.Mode=QClipboard.Clipboard):
        'setPixmap(self, QPixmap, mode: QClipboard.Mode = QClipboard.Clipboard)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setText(cls, self, str, mode: QClipboard.Mode=QClipboard.Clipboard):
        'setText(self, str, mode: QClipboard.Mode = QClipboard.Clipboard)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsFindBuffer(cls, self):
        'supportsFindBuffer(self) -> bool'
        return True
    
    @classmethod
    def supportsSelection(cls, self):
        'supportsSelection(self) -> bool'
        return True
    
    @classmethod
    def text(cls, self, str, mode: QClipboard.Mode=QClipboard.Clipboard):
        'text(self, mode: QClipboard.Mode = QClipboard.Clipboard) -> str\ntext(self, str, mode: QClipboard.Mode = QClipboard.Clipboard) -> Tuple[str, str]'
        return ''
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QCloseEvent(_mod_PyQt5_QtCore.QEvent):
    'QCloseEvent()\nQCloseEvent(QCloseEvent)'
    __class__ = QCloseEvent
    __dict__ = {}
    def __init__(self, QCloseEvent):
        'QCloseEvent()\nQCloseEvent(QCloseEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QColor(_mod_sip.simplewrapper):
    'QColor(Qt.GlobalColor)\nQColor(int)\nQColor(QRgba64)\nQColor(Any)\nQColor()\nQColor(int, int, int, alpha: int = 255)\nQColor(str)\nQColor(Union[QColor, Qt.GlobalColor, QGradient])'
    Cmyk = Spec()
    HexArgb = NameFormat()
    HexRgb = NameFormat()
    Hsl = Spec()
    Hsv = Spec()
    Invalid = Spec()
    NameFormat = NameFormat()
    Rgb = Spec()
    Spec = Spec()
    __class__ = QColor
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'QColor(Qt.GlobalColor)\nQColor(int)\nQColor(QRgba64)\nQColor(Any)\nQColor()\nQColor(int, int, int, alpha: int = 255)\nQColor(str)\nQColor(Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alpha(cls, self):
        'alpha(self) -> int'
        return 1
    
    @classmethod
    def alphaF(cls, self):
        'alphaF(self) -> float'
        return 1.0
    
    @classmethod
    def black(cls, self):
        'black(self) -> int'
        return 1
    
    @classmethod
    def blackF(cls, self):
        'blackF(self) -> float'
        return 1.0
    
    @classmethod
    def blue(cls, self):
        'blue(self) -> int'
        return 1
    
    @classmethod
    def blueF(cls, self):
        'blueF(self) -> float'
        return 1.0
    
    @classmethod
    def colorNames(cls):
        'colorNames() -> List[str]'
        pass
    
    @classmethod
    def convertTo(cls, self, QColorSpec):
        'convertTo(self, QColor.Spec) -> QColor'
        pass
    
    @classmethod
    def cyan(cls, self):
        'cyan(self) -> int'
        return 1
    
    @classmethod
    def cyanF(cls, self):
        'cyanF(self) -> float'
        return 1.0
    
    @classmethod
    def darker(cls, self, factor: int=200):
        'darker(self, factor: int = 200) -> QColor'
        pass
    
    @classmethod
    def fromCmyk(cls, int, int_, int_1, int_2, alpha: int=255):
        'fromCmyk(int, int, int, int, alpha: int = 255) -> QColor'
        pass
    
    @classmethod
    def fromCmykF(cls, float, float_, float_1, float_2, alpha: float=1):
        'fromCmykF(float, float, float, float, alpha: float = 1) -> QColor'
        pass
    
    @classmethod
    def fromHsl(cls, int, int_, int_1, alpha: int=255):
        'fromHsl(int, int, int, alpha: int = 255) -> QColor'
        pass
    
    @classmethod
    def fromHslF(cls, float, float_, float_1, alpha: float=1):
        'fromHslF(float, float, float, alpha: float = 1) -> QColor'
        pass
    
    @classmethod
    def fromHsv(cls, int, int_, int_1, alpha: int=255):
        'fromHsv(int, int, int, alpha: int = 255) -> QColor'
        pass
    
    @classmethod
    def fromHsvF(cls, float, float_, float_1, alpha: float=1):
        'fromHsvF(float, float, float, alpha: float = 1) -> QColor'
        pass
    
    @classmethod
    def fromRgb(cls, int, int_, int_1, alpha: int=255):
        'fromRgb(int) -> QColor\nfromRgb(int, int, int, alpha: int = 255) -> QColor'
        pass
    
    @classmethod
    def fromRgbF(cls, float, float_, float_1, alpha: float=1):
        'fromRgbF(float, float, float, alpha: float = 1) -> QColor'
        pass
    
    @classmethod
    def fromRgba(cls, int):
        'fromRgba(int) -> QColor'
        pass
    
    @classmethod
    def fromRgba64(cls, int, int_, int_1, alpha: int=65535):
        'fromRgba64(int, int, int, alpha: int = 65535) -> QColor\nfromRgba64(QRgba64) -> QColor'
        pass
    
    @classmethod
    def getCmyk(cls, self):
        'getCmyk(self) -> Tuple[int, int, int, int, int]'
        pass
    
    @classmethod
    def getCmykF(cls, self):
        'getCmykF(self) -> Tuple[float, float, float, float, float]'
        pass
    
    @classmethod
    def getHsl(cls, self):
        'getHsl(self) -> Tuple[int, int, int, int]'
        pass
    
    @classmethod
    def getHslF(cls, self):
        'getHslF(self) -> Tuple[float, float, float, float]'
        pass
    
    @classmethod
    def getHsv(cls, self):
        'getHsv(self) -> Tuple[int, int, int, int]'
        pass
    
    @classmethod
    def getHsvF(cls, self):
        'getHsvF(self) -> Tuple[float, float, float, float]'
        pass
    
    @classmethod
    def getRgb(cls, self):
        'getRgb(self) -> Tuple[int, int, int, int]'
        pass
    
    @classmethod
    def getRgbF(cls, self):
        'getRgbF(self) -> Tuple[float, float, float, float]'
        pass
    
    @classmethod
    def green(cls, self):
        'green(self) -> int'
        return 1
    
    @classmethod
    def greenF(cls, self):
        'greenF(self) -> float'
        return 1.0
    
    @classmethod
    def hslHue(cls, self):
        'hslHue(self) -> int'
        return 1
    
    @classmethod
    def hslHueF(cls, self):
        'hslHueF(self) -> float'
        return 1.0
    
    @classmethod
    def hslSaturation(cls, self):
        'hslSaturation(self) -> int'
        return 1
    
    @classmethod
    def hslSaturationF(cls, self):
        'hslSaturationF(self) -> float'
        return 1.0
    
    @classmethod
    def hsvHue(cls, self):
        'hsvHue(self) -> int'
        return 1
    
    @classmethod
    def hsvHueF(cls, self):
        'hsvHueF(self) -> float'
        return 1.0
    
    @classmethod
    def hsvSaturation(cls, self):
        'hsvSaturation(self) -> int'
        return 1
    
    @classmethod
    def hsvSaturationF(cls, self):
        'hsvSaturationF(self) -> float'
        return 1.0
    
    @classmethod
    def hue(cls, self):
        'hue(self) -> int'
        return 1
    
    @classmethod
    def hueF(cls, self):
        'hueF(self) -> float'
        return 1.0
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isValidColor(cls, str):
        'isValidColor(str) -> bool'
        return True
    
    @classmethod
    def lighter(cls, self, factor: int=150):
        'lighter(self, factor: int = 150) -> QColor'
        pass
    
    @classmethod
    def lightness(cls, self):
        'lightness(self) -> int'
        return 1
    
    @classmethod
    def lightnessF(cls, self):
        'lightnessF(self) -> float'
        return 1.0
    
    @classmethod
    def magenta(cls, self):
        'magenta(self) -> int'
        return 1
    
    @classmethod
    def magentaF(cls, self):
        'magentaF(self) -> float'
        return 1.0
    
    @classmethod
    def name(cls, self, QColorNameFormat):
        'name(self) -> str\nname(self, QColor.NameFormat) -> str'
        return ''
    
    @classmethod
    def red(cls, self):
        'red(self) -> int'
        return 1
    
    @classmethod
    def redF(cls, self):
        'redF(self) -> float'
        return 1.0
    
    @classmethod
    def rgb(cls, self):
        'rgb(self) -> int'
        return 1
    
    @classmethod
    def rgba(cls, self):
        'rgba(self) -> int'
        return 1
    
    @classmethod
    def rgba64(cls, self):
        'rgba64(self) -> QRgba64'
        pass
    
    @classmethod
    def saturation(cls, self):
        'saturation(self) -> int'
        return 1
    
    @classmethod
    def saturationF(cls, self):
        'saturationF(self) -> float'
        return 1.0
    
    @classmethod
    def setAlpha(cls, self, int):
        'setAlpha(self, int)'
        pass
    
    @classmethod
    def setAlphaF(cls, self, float):
        'setAlphaF(self, float)'
        pass
    
    @classmethod
    def setBlue(cls, self, int):
        'setBlue(self, int)'
        pass
    
    @classmethod
    def setBlueF(cls, self, float):
        'setBlueF(self, float)'
        pass
    
    @classmethod
    def setCmyk(cls, self, int, int_, int_1, int_2, alpha: int=255):
        'setCmyk(self, int, int, int, int, alpha: int = 255)'
        pass
    
    @classmethod
    def setCmykF(cls, self, float, float_, float_1, float_2, alpha: float=1):
        'setCmykF(self, float, float, float, float, alpha: float = 1)'
        pass
    
    @classmethod
    def setGreen(cls, self, int):
        'setGreen(self, int)'
        pass
    
    @classmethod
    def setGreenF(cls, self, float):
        'setGreenF(self, float)'
        pass
    
    @classmethod
    def setHsl(cls, self, int, int_, int_1, alpha: int=255):
        'setHsl(self, int, int, int, alpha: int = 255)'
        pass
    
    @classmethod
    def setHslF(cls, self, float, float_, float_1, alpha: float=1):
        'setHslF(self, float, float, float, alpha: float = 1)'
        pass
    
    @classmethod
    def setHsv(cls, self, int, int_, int_1, alpha: int=255):
        'setHsv(self, int, int, int, alpha: int = 255)'
        pass
    
    @classmethod
    def setHsvF(cls, self, float, float_, float_1, alpha: float=1):
        'setHsvF(self, float, float, float, alpha: float = 1)'
        pass
    
    @classmethod
    def setNamedColor(cls, self, str):
        'setNamedColor(self, str)'
        pass
    
    @classmethod
    def setRed(cls, self, int):
        'setRed(self, int)'
        pass
    
    @classmethod
    def setRedF(cls, self, float):
        'setRedF(self, float)'
        pass
    
    @classmethod
    def setRgb(cls, self, int, int_, int_1, alpha: int=255):
        'setRgb(self, int, int, int, alpha: int = 255)\nsetRgb(self, int)'
        pass
    
    @classmethod
    def setRgbF(cls, self, float, float_, float_1, alpha: float=1):
        'setRgbF(self, float, float, float, alpha: float = 1)'
        pass
    
    @classmethod
    def setRgba(cls, self, int):
        'setRgba(self, int)'
        pass
    
    @classmethod
    def setRgba64(cls, self, QRgba64):
        'setRgba64(self, QRgba64)'
        pass
    
    @classmethod
    def spec(cls, self):
        'spec(self) -> QColor.Spec'
        pass
    
    @classmethod
    def toCmyk(cls, self):
        'toCmyk(self) -> QColor'
        pass
    
    @classmethod
    def toHsl(cls, self):
        'toHsl(self) -> QColor'
        pass
    
    @classmethod
    def toHsv(cls, self):
        'toHsv(self) -> QColor'
        pass
    
    @classmethod
    def toRgb(cls, self):
        'toRgb(self) -> QColor'
        pass
    
    @classmethod
    def value(cls, self):
        'value(self) -> int'
        return 1
    
    @classmethod
    def valueF(cls, self):
        'valueF(self) -> float'
        return 1.0
    
    @classmethod
    def yellow(cls, self):
        'yellow(self) -> int'
        return 1
    
    @classmethod
    def yellowF(cls, self):
        'yellowF(self) -> float'
        return 1.0
    

class QConicalGradient(QGradient):
    'QConicalGradient()\nQConicalGradient(Union[QPointF, QPoint], float)\nQConicalGradient(float, float, float)\nQConicalGradient(QConicalGradient)'
    __class__ = QConicalGradient
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, float=None):
        'QConicalGradient()\nQConicalGradient(Union[QPointF, QPoint], float)\nQConicalGradient(float, float, float)\nQConicalGradient(QConicalGradient)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def angle(cls, self):
        'angle(self) -> float'
        return 1.0
    
    @classmethod
    def center(cls, self):
        'center(self) -> QPointF'
        pass
    
    @classmethod
    def coordinateMode(cls, self):
        'coordinateMode(self) -> QGradient.CoordinateMode'
        pass
    
    @classmethod
    def setAngle(cls, self, float):
        'setAngle(self, float)'
        pass
    
    @classmethod
    def setCenter(cls, self, UnionQPointF=None, QPoint=None):
        'setCenter(self, Union[QPointF, QPoint])\nsetCenter(self, float, float)'
        pass
    
    @classmethod
    def setColorAt(cls, self, float, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColorAt(self, float, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCoordinateMode(cls, self, QGradientCoordinateMode):
        'setCoordinateMode(self, QGradient.CoordinateMode)'
        pass
    
    @classmethod
    def setSpread(cls, self, QGradientSpread):
        'setSpread(self, QGradient.Spread)'
        pass
    
    @classmethod
    def setStops(cls, self, object):
        'setStops(self, object)'
        pass
    
    @classmethod
    def spread(cls, self):
        'spread(self) -> QGradient.Spread'
        pass
    
    @classmethod
    def stops(cls, self):
        'stops(self) -> object'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QGradient.Type'
        pass
    

class QContextMenuEvent(QInputEvent):
    'QContextMenuEvent(QContextMenuEvent.Reason, QPoint, QPoint, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQContextMenuEvent(QContextMenuEvent.Reason, QPoint, QPoint)\nQContextMenuEvent(QContextMenuEvent.Reason, QPoint)\nQContextMenuEvent(QContextMenuEvent)'
    Keyboard = Reason()
    Mouse = Reason()
    Other = Reason()
    Reason = Reason()
    __class__ = QContextMenuEvent
    __dict__ = {}
    def __init__(self, QContextMenuEventReason, QPoint, QPoint_, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None):
        'QContextMenuEvent(QContextMenuEvent.Reason, QPoint, QPoint, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQContextMenuEvent(QContextMenuEvent.Reason, QPoint, QPoint)\nQContextMenuEvent(QContextMenuEvent.Reason, QPoint)\nQContextMenuEvent(QContextMenuEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def reason(cls, self):
        'reason(self) -> QContextMenuEvent.Reason'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QCursor(_mod_sip.simplewrapper):
    'QCursor()\nQCursor(QBitmap, QBitmap, hotX: int = -1, hotY: int = -1)\nQCursor(QPixmap, hotX: int = -1, hotY: int = -1)\nQCursor(Union[QCursor, Qt.CursorShape])\nQCursor(Any)'
    __class__ = QCursor
    __dict__ = {}
    def __init__(self, QBitmap, QBitmap_, hotX: int=-1, hotY: int=-1):
        'QCursor()\nQCursor(QBitmap, QBitmap, hotX: int = -1, hotY: int = -1)\nQCursor(QPixmap, hotX: int = -1, hotY: int = -1)\nQCursor(Union[QCursor, Qt.CursorShape])\nQCursor(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def bitmap(cls, self):
        'bitmap(self) -> QBitmap'
        pass
    
    @classmethod
    def hotSpot(cls, self):
        'hotSpot(self) -> QPoint'
        pass
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QBitmap'
        pass
    
    @classmethod
    def pixmap(cls, self):
        'pixmap(self) -> QPixmap'
        pass
    
    @classmethod
    def pos(cls):
        'pos() -> QPoint'
        pass
    
    @classmethod
    def setPos(cls, int, int_):
        'setPos(int, int)\nsetPos(QPoint)'
        pass
    
    @classmethod
    def setShape(cls, self, QtCursorShape):
        'setShape(self, Qt.CursorShape)'
        pass
    
    @classmethod
    def shape(cls, self):
        'shape(self) -> Qt.CursorShape'
        pass
    
    @classmethod
    def swap(cls, self, UnionQCursor=None, QtCursorShape=None):
        'swap(self, Union[QCursor, Qt.CursorShape])'
        pass
    

class QDesktopServices(_mod_sip.simplewrapper):
    'QDesktopServices()\nQDesktopServices(QDesktopServices)'
    __class__ = QDesktopServices
    __dict__ = {}
    def __init__(self, QDesktopServices):
        'QDesktopServices()\nQDesktopServices(QDesktopServices)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def openUrl(cls, QUrl):
        'openUrl(QUrl) -> bool'
        return True
    
    @classmethod
    def setUrlHandler(cls, str, Callable, None_):
        'setUrlHandler(str, QObject, str)\nsetUrlHandler(str, Callable[[], None])'
        pass
    
    @classmethod
    def unsetUrlHandler(cls, str):
        'unsetUrlHandler(str)'
        pass
    

class QDoubleValidator(QValidator):
    'QDoubleValidator(parent: QObject = None)\nQDoubleValidator(float, float, int, parent: QObject = None)'
    Notation = Notation()
    ScientificNotation = Notation()
    StandardNotation = Notation()
    __class__ = QDoubleValidator
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, float, float_, int, parent: QObject=None):
        'QDoubleValidator(parent: QObject = None)\nQDoubleValidator(float, float, int, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def bottom(cls, self):
        'bottom(self) -> float'
        return 1.0
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def decimals(cls, self):
        'decimals(self) -> int'
        return 1
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fixup(cls, self, str):
        'fixup(self, str) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def notation(cls, self):
        'notation(self) -> QDoubleValidator.Notation'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBottom(cls, self, float):
        'setBottom(self, float)'
        pass
    
    @classmethod
    def setDecimals(cls, self, int):
        'setDecimals(self, int)'
        pass
    
    @classmethod
    def setLocale(cls, self, QLocale):
        'setLocale(self, QLocale)'
        pass
    
    @classmethod
    def setNotation(cls, self, QDoubleValidatorNotation):
        'setNotation(self, QDoubleValidator.Notation)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRange(cls, self, float, float_, decimals: int=0):
        'setRange(self, float, float, decimals: int = 0)'
        pass
    
    @classmethod
    def setTop(cls, self, float):
        'setTop(self, float)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def top(cls, self):
        'top(self) -> float'
        return 1.0
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def validate(cls, self, str, int):
        'validate(self, str, int) -> Tuple[QValidator.State, str, int]'
        pass
    

class QDrag(_mod_PyQt5_QtCore.QObject):
    'QDrag(QObject)'
    __class__ = QDrag
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QObject):
        'QDrag(QObject)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def cancel(cls):
        'cancel()'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def defaultAction(cls, self):
        'defaultAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dragCursor(cls, self, QtDropAction):
        'dragCursor(self, Qt.DropAction) -> QPixmap'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exec(cls, self, supportedActions: Union[Qt.DropActions,Qt.DropAction]=Qt.MoveAction):
        'exec(self, supportedActions: Union[Qt.DropActions, Qt.DropAction] = Qt.MoveAction) -> Qt.DropAction\nexec(self, Union[Qt.DropActions, Qt.DropAction], Qt.DropAction) -> Qt.DropAction'
        pass
    
    @classmethod
    def exec_(cls, self, supportedActions: Union[Qt.DropActions,Qt.DropAction]=Qt.MoveAction):
        'exec_(self, supportedActions: Union[Qt.DropActions, Qt.DropAction] = Qt.MoveAction) -> Qt.DropAction\nexec_(self, Union[Qt.DropActions, Qt.DropAction], Qt.DropAction) -> Qt.DropAction'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def hotSpot(cls, self):
        'hotSpot(self) -> QPoint'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def mimeData(cls, self):
        'mimeData(self) -> QMimeData'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def pixmap(cls, self):
        'pixmap(self) -> QPixmap'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setDragCursor(cls, self, QPixmap, QtDropAction):
        'setDragCursor(self, QPixmap, Qt.DropAction)'
        pass
    
    @classmethod
    def setHotSpot(cls, self, QPoint):
        'setHotSpot(self, QPoint)'
        pass
    
    @classmethod
    def setMimeData(cls, self, QMimeData):
        'setMimeData(self, QMimeData)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setPixmap(cls, self, QPixmap):
        'setPixmap(self, QPixmap)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def source(cls, self):
        'source(self) -> QObject'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportedActions(cls, self):
        'supportedActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def target(cls, self):
        'target(self) -> QObject'
        pass
    
    def targetChanged(self, QObject):
        'targetChanged(self, QObject) [signal]'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QDragEnterEvent(QDragMoveEvent):
    'QDragEnterEvent(QPoint, Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQDragEnterEvent(QDragEnterEvent)'
    __class__ = QDragEnterEvent
    __dict__ = {}
    def __init__(self, QPoint, UnionQtDropActions=None, QtDropAction=None, QMimeData=None, UnionQtMouseButtons=None, QtMouseButton=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None):
        'QDragEnterEvent(QPoint, Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQDragEnterEvent(QDragEnterEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self, QRect):
        'accept(self)\naccept(self, QRect)'
        pass
    
    @classmethod
    def acceptProposedAction(cls, self):
        'acceptProposedAction(self)'
        pass
    
    @classmethod
    def answerRect(cls, self):
        'answerRect(self) -> QRect'
        pass
    
    @classmethod
    def dropAction(cls, self):
        'dropAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def ignore(cls, self, QRect):
        'ignore(self)\nignore(self, QRect)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def keyboardModifiers(cls, self):
        'keyboardModifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def mimeData(cls, self):
        'mimeData(self) -> QMimeData'
        pass
    
    @classmethod
    def mouseButtons(cls, self):
        'mouseButtons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def possibleActions(cls, self):
        'possibleActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def proposedAction(cls, self):
        'proposedAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setDropAction(cls, self, QtDropAction):
        'setDropAction(self, Qt.DropAction)'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> QObject'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QDragLeaveEvent(_mod_PyQt5_QtCore.QEvent):
    'QDragLeaveEvent()\nQDragLeaveEvent(QDragLeaveEvent)'
    __class__ = QDragLeaveEvent
    __dict__ = {}
    def __init__(self, QDragLeaveEvent):
        'QDragLeaveEvent()\nQDragLeaveEvent(QDragLeaveEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QDragMoveEvent(QDropEvent):
    'QDragMoveEvent(QPoint, Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], type: QEvent.Type = QEvent.DragMove)\nQDragMoveEvent(QDragMoveEvent)'
    __class__ = QDragMoveEvent
    __dict__ = {}
    def __init__(self, QPoint, UnionQtDropActions=None, QtDropAction=None, QMimeData=None, UnionQtMouseButtons=None, QtMouseButton=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, type: QEvent.Type=QEvent.DragMove):
        'QDragMoveEvent(QPoint, Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], type: QEvent.Type = QEvent.DragMove)\nQDragMoveEvent(QDragMoveEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self, QRect):
        'accept(self)\naccept(self, QRect)'
        pass
    
    @classmethod
    def acceptProposedAction(cls, self):
        'acceptProposedAction(self)'
        pass
    
    @classmethod
    def answerRect(cls, self):
        'answerRect(self) -> QRect'
        pass
    
    @classmethod
    def dropAction(cls, self):
        'dropAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def ignore(cls, self, QRect):
        'ignore(self)\nignore(self, QRect)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def keyboardModifiers(cls, self):
        'keyboardModifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def mimeData(cls, self):
        'mimeData(self) -> QMimeData'
        pass
    
    @classmethod
    def mouseButtons(cls, self):
        'mouseButtons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def possibleActions(cls, self):
        'possibleActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def proposedAction(cls, self):
        'proposedAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setDropAction(cls, self, QtDropAction):
        'setDropAction(self, Qt.DropAction)'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> QObject'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QDropEvent(_mod_PyQt5_QtCore.QEvent):
    'QDropEvent(Union[QPointF, QPoint], Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], type: QEvent.Type = QEvent.Drop)\nQDropEvent(QDropEvent)'
    __class__ = QDropEvent
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, UnionQtDropActions=None, QtDropAction=None, QMimeData=None, UnionQtMouseButtons=None, QtMouseButton=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, type: QEvent.Type=QEvent.Drop):
        'QDropEvent(Union[QPointF, QPoint], Union[Qt.DropActions, Qt.DropAction], QMimeData, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], type: QEvent.Type = QEvent.Drop)\nQDropEvent(QDropEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def acceptProposedAction(cls, self):
        'acceptProposedAction(self)'
        pass
    
    @classmethod
    def dropAction(cls, self):
        'dropAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def keyboardModifiers(cls, self):
        'keyboardModifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def mimeData(cls, self):
        'mimeData(self) -> QMimeData'
        pass
    
    @classmethod
    def mouseButtons(cls, self):
        'mouseButtons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def possibleActions(cls, self):
        'possibleActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def proposedAction(cls, self):
        'proposedAction(self) -> Qt.DropAction'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setDropAction(cls, self, QtDropAction):
        'setDropAction(self, Qt.DropAction)'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> QObject'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QEnterEvent(_mod_PyQt5_QtCore.QEvent):
    'QEnterEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint])\nQEnterEvent(QEnterEvent)'
    __class__ = QEnterEvent
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, UnionQPointF_1=None, QPoint_1=None):
        'QEnterEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint])\nQEnterEvent(QEnterEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def localPos(cls, self):
        'localPos(self) -> QPointF'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def screenPos(cls, self):
        'screenPos(self) -> QPointF'
        pass
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def windowPos(cls, self):
        'windowPos(self) -> QPointF'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QExposeEvent(_mod_PyQt5_QtCore.QEvent):
    'QExposeEvent(QRegion)\nQExposeEvent(QExposeEvent)'
    __class__ = QExposeEvent
    __dict__ = {}
    def __init__(self, QExposeEvent):
        'QExposeEvent(QRegion)\nQExposeEvent(QExposeEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def region(cls, self):
        'region(self) -> QRegion'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QFileOpenEvent(_mod_PyQt5_QtCore.QEvent):
    __class__ = QFileOpenEvent
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def file(cls, self):
        'file(self) -> str'
        return ''
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def openFile(cls, self, QFile, UnionQIODeviceOpenMode=None, QIODeviceOpenModeFlag=None):
        'openFile(self, QFile, Union[QIODevice.OpenMode, QIODevice.OpenModeFlag]) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def url(cls, self):
        'url(self) -> QUrl'
        pass
    

class QFocusEvent(_mod_PyQt5_QtCore.QEvent):
    'QFocusEvent(QEvent.Type, reason: Qt.FocusReason = Qt.OtherFocusReason)\nQFocusEvent(QFocusEvent)'
    __class__ = QFocusEvent
    __dict__ = {}
    def __init__(self, QEventType, reason: Qt.FocusReason=Qt.OtherFocusReason):
        'QFocusEvent(QEvent.Type, reason: Qt.FocusReason = Qt.OtherFocusReason)\nQFocusEvent(QFocusEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def gotFocus(cls, self):
        'gotFocus(self) -> bool'
        return True
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def lostFocus(cls, self):
        'lostFocus(self) -> bool'
        return True
    
    @classmethod
    def reason(cls, self):
        'reason(self) -> Qt.FocusReason'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QFont(_mod_sip.simplewrapper):
    'QFont()\nQFont(str, pointSize: int = -1, weight: int = -1, italic: bool = False)\nQFont(QFont, QPaintDevice)\nQFont(QFont)\nQFont(Any)'
    AbsoluteSpacing = SpacingType()
    AllLowercase = Capitalization()
    AllUppercase = Capitalization()
    AnyStretch = Stretch()
    AnyStyle = StyleHint()
    Black = Weight()
    Bold = Weight()
    Capitalization = Capitalization()
    Capitalize = Capitalization()
    Condensed = Stretch()
    Courier = StyleHint()
    Cursive = StyleHint()
    Decorative = StyleHint()
    DemiBold = Weight()
    Expanded = Stretch()
    ExtraBold = Weight()
    ExtraCondensed = Stretch()
    ExtraExpanded = Stretch()
    ExtraLight = Weight()
    Fantasy = StyleHint()
    ForceIntegerMetrics = StyleStrategy()
    ForceOutline = StyleStrategy()
    Helvetica = StyleHint()
    HintingPreference = HintingPreference()
    Light = Weight()
    Medium = Weight()
    MixedCase = Capitalization()
    Monospace = StyleHint()
    NoAntialias = StyleStrategy()
    NoFontMerging = StyleStrategy()
    NoSubpixelAntialias = StyleStrategy()
    Normal = Weight()
    OldEnglish = StyleHint()
    OpenGLCompatible = StyleStrategy()
    PercentageSpacing = SpacingType()
    PreferAntialias = StyleStrategy()
    PreferBitmap = StyleStrategy()
    PreferDefault = StyleStrategy()
    PreferDefaultHinting = HintingPreference()
    PreferDevice = StyleStrategy()
    PreferFullHinting = HintingPreference()
    PreferMatch = StyleStrategy()
    PreferNoHinting = HintingPreference()
    PreferOutline = StyleStrategy()
    PreferQuality = StyleStrategy()
    PreferVerticalHinting = HintingPreference()
    SansSerif = StyleHint()
    SemiCondensed = Stretch()
    SemiExpanded = Stretch()
    Serif = StyleHint()
    SmallCaps = Capitalization()
    SpacingType = SpacingType()
    Stretch = Stretch()
    Style = Style()
    StyleHint = StyleHint()
    StyleItalic = Style()
    StyleNormal = Style()
    StyleOblique = Style()
    StyleStrategy = StyleStrategy()
    System = StyleHint()
    Thin = Weight()
    Times = StyleHint()
    TypeWriter = StyleHint()
    UltraCondensed = Stretch()
    UltraExpanded = Stretch()
    Unstretched = Stretch()
    Weight = Weight()
    __class__ = QFont
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    def __hash__(self):
        'Return hash(self).'
        return 0
    
    def __init__(self, str, pointSize: int=-1, weight: int=-1, italic: bool=False):
        'QFont()\nQFont(str, pointSize: int = -1, weight: int = -1, italic: bool = False)\nQFont(QFont, QPaintDevice)\nQFont(QFont)\nQFont(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def bold(cls, self):
        'bold(self) -> bool'
        return True
    
    @classmethod
    def cacheStatistics(cls):
        'cacheStatistics()'
        pass
    
    @classmethod
    def capitalization(cls, self):
        'capitalization(self) -> QFont.Capitalization'
        pass
    
    @classmethod
    def cleanup(cls):
        'cleanup()'
        pass
    
    @classmethod
    def defaultFamily(cls, self):
        'defaultFamily(self) -> str'
        return ''
    
    @classmethod
    def exactMatch(cls, self):
        'exactMatch(self) -> bool'
        return True
    
    @classmethod
    def family(cls, self):
        'family(self) -> str'
        return ''
    
    @classmethod
    def fixedPitch(cls, self):
        'fixedPitch(self) -> bool'
        return True
    
    @classmethod
    def fromString(cls, self, str):
        'fromString(self, str) -> bool'
        return True
    
    @classmethod
    def hintingPreference(cls, self):
        'hintingPreference(self) -> QFont.HintingPreference'
        pass
    
    @classmethod
    def initialize(cls):
        'initialize()'
        pass
    
    @classmethod
    def insertSubstitution(cls, str, str_):
        'insertSubstitution(str, str)'
        pass
    
    @classmethod
    def insertSubstitutions(cls, str, Iterablestr=None):
        'insertSubstitutions(str, Iterable[str])'
        pass
    
    @classmethod
    def isCopyOf(cls, self, QFont):
        'isCopyOf(self, QFont) -> bool'
        return True
    
    @classmethod
    def italic(cls, self):
        'italic(self) -> bool'
        return True
    
    @classmethod
    def kerning(cls, self):
        'kerning(self) -> bool'
        return True
    
    @classmethod
    def key(cls, self):
        'key(self) -> str'
        return ''
    
    @classmethod
    def lastResortFamily(cls, self):
        'lastResortFamily(self) -> str'
        return ''
    
    @classmethod
    def lastResortFont(cls, self):
        'lastResortFont(self) -> str'
        return ''
    
    @classmethod
    def letterSpacing(cls, self):
        'letterSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def letterSpacingType(cls, self):
        'letterSpacingType(self) -> QFont.SpacingType'
        pass
    
    @classmethod
    def overline(cls, self):
        'overline(self) -> bool'
        return True
    
    @classmethod
    def pixelSize(cls, self):
        'pixelSize(self) -> int'
        return 1
    
    @classmethod
    def pointSize(cls, self):
        'pointSize(self) -> int'
        return 1
    
    @classmethod
    def pointSizeF(cls, self):
        'pointSizeF(self) -> float'
        return 1.0
    
    @classmethod
    def rawMode(cls, self):
        'rawMode(self) -> bool'
        return True
    
    @classmethod
    def rawName(cls, self):
        'rawName(self) -> str'
        return ''
    
    @classmethod
    def removeSubstitutions(cls, str):
        'removeSubstitutions(str)'
        pass
    
    @classmethod
    def resolve(cls, self, QFont):
        'resolve(self, QFont) -> QFont'
        pass
    
    @classmethod
    def setBold(cls, self, bool):
        'setBold(self, bool)'
        pass
    
    @classmethod
    def setCapitalization(cls, self, QFontCapitalization):
        'setCapitalization(self, QFont.Capitalization)'
        pass
    
    @classmethod
    def setFamily(cls, self, str):
        'setFamily(self, str)'
        pass
    
    @classmethod
    def setFixedPitch(cls, self, bool):
        'setFixedPitch(self, bool)'
        pass
    
    @classmethod
    def setHintingPreference(cls, self, QFontHintingPreference):
        'setHintingPreference(self, QFont.HintingPreference)'
        pass
    
    @classmethod
    def setItalic(cls, self, bool):
        'setItalic(self, bool)'
        pass
    
    @classmethod
    def setKerning(cls, self, bool):
        'setKerning(self, bool)'
        pass
    
    @classmethod
    def setLetterSpacing(cls, self, QFontSpacingType, float):
        'setLetterSpacing(self, QFont.SpacingType, float)'
        pass
    
    @classmethod
    def setOverline(cls, self, bool):
        'setOverline(self, bool)'
        pass
    
    @classmethod
    def setPixelSize(cls, self, int):
        'setPixelSize(self, int)'
        pass
    
    @classmethod
    def setPointSize(cls, self, int):
        'setPointSize(self, int)'
        pass
    
    @classmethod
    def setPointSizeF(cls, self, float):
        'setPointSizeF(self, float)'
        pass
    
    @classmethod
    def setRawMode(cls, self, bool):
        'setRawMode(self, bool)'
        pass
    
    @classmethod
    def setRawName(cls, self, str):
        'setRawName(self, str)'
        pass
    
    @classmethod
    def setStretch(cls, self, int):
        'setStretch(self, int)'
        pass
    
    @classmethod
    def setStrikeOut(cls, self, bool):
        'setStrikeOut(self, bool)'
        pass
    
    @classmethod
    def setStyle(cls, self, QFontStyle):
        'setStyle(self, QFont.Style)'
        pass
    
    @classmethod
    def setStyleHint(cls, self, QFontStyleHint, strategy: QFont.StyleStrategy=QFont.PreferDefault):
        'setStyleHint(self, QFont.StyleHint, strategy: QFont.StyleStrategy = QFont.PreferDefault)'
        pass
    
    @classmethod
    def setStyleName(cls, self, str):
        'setStyleName(self, str)'
        pass
    
    @classmethod
    def setStyleStrategy(cls, self, QFontStyleStrategy):
        'setStyleStrategy(self, QFont.StyleStrategy)'
        pass
    
    @classmethod
    def setUnderline(cls, self, bool):
        'setUnderline(self, bool)'
        pass
    
    @classmethod
    def setWeight(cls, self, int):
        'setWeight(self, int)'
        pass
    
    @classmethod
    def setWordSpacing(cls, self, float):
        'setWordSpacing(self, float)'
        pass
    
    @classmethod
    def stretch(cls, self):
        'stretch(self) -> int'
        return 1
    
    @classmethod
    def strikeOut(cls, self):
        'strikeOut(self) -> bool'
        return True
    
    @classmethod
    def style(cls, self):
        'style(self) -> QFont.Style'
        pass
    
    @classmethod
    def styleHint(cls, self):
        'styleHint(self) -> QFont.StyleHint'
        pass
    
    @classmethod
    def styleName(cls, self):
        'styleName(self) -> str'
        return ''
    
    @classmethod
    def styleStrategy(cls, self):
        'styleStrategy(self) -> QFont.StyleStrategy'
        pass
    
    @classmethod
    def substitute(cls, str):
        'substitute(str) -> str'
        return ''
    
    @classmethod
    def substitutes(cls, str):
        'substitutes(str) -> List[str]'
        pass
    
    @classmethod
    def substitutions(cls):
        'substitutions() -> List[str]'
        pass
    
    @classmethod
    def swap(cls, self, QFont):
        'swap(self, QFont)'
        pass
    
    @classmethod
    def toString(cls, self):
        'toString(self) -> str'
        return ''
    
    @classmethod
    def underline(cls, self):
        'underline(self) -> bool'
        return True
    
    @classmethod
    def weight(cls, self):
        'weight(self) -> int'
        return 1
    
    @classmethod
    def wordSpacing(cls, self):
        'wordSpacing(self) -> float'
        return 1.0
    

class QFontDatabase(_mod_sip.simplewrapper):
    'QFontDatabase()\nQFontDatabase(QFontDatabase)'
    Any = WritingSystem()
    Arabic = WritingSystem()
    Armenian = WritingSystem()
    Bengali = WritingSystem()
    Cyrillic = WritingSystem()
    Devanagari = WritingSystem()
    FixedFont = SystemFont()
    GeneralFont = SystemFont()
    Georgian = WritingSystem()
    Greek = WritingSystem()
    Gujarati = WritingSystem()
    Gurmukhi = WritingSystem()
    Hebrew = WritingSystem()
    Japanese = WritingSystem()
    Kannada = WritingSystem()
    Khmer = WritingSystem()
    Korean = WritingSystem()
    Lao = WritingSystem()
    Latin = WritingSystem()
    Malayalam = WritingSystem()
    Myanmar = WritingSystem()
    Nko = WritingSystem()
    Ogham = WritingSystem()
    Oriya = WritingSystem()
    Other = WritingSystem()
    Runic = WritingSystem()
    SimplifiedChinese = WritingSystem()
    Sinhala = WritingSystem()
    SmallestReadableFont = SystemFont()
    Symbol = WritingSystem()
    Syriac = WritingSystem()
    SystemFont = SystemFont()
    Tamil = WritingSystem()
    Telugu = WritingSystem()
    Thaana = WritingSystem()
    Thai = WritingSystem()
    Tibetan = WritingSystem()
    TitleFont = SystemFont()
    TraditionalChinese = WritingSystem()
    Vietnamese = WritingSystem()
    WritingSystem = WritingSystem()
    __class__ = QFontDatabase
    __dict__ = {}
    def __init__(self, QFontDatabase):
        'QFontDatabase()\nQFontDatabase(QFontDatabase)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def addApplicationFont(cls, str):
        'addApplicationFont(str) -> int'
        return 1
    
    @classmethod
    def addApplicationFontFromData(cls, UnionQByteArray=None, bytes=None, bytearray=None):
        'addApplicationFontFromData(Union[QByteArray, bytes, bytearray]) -> int'
        return 1
    
    @classmethod
    def applicationFontFamilies(cls, int):
        'applicationFontFamilies(int) -> List[str]'
        pass
    
    @classmethod
    def bold(cls, self, str, str_):
        'bold(self, str, str) -> bool'
        return True
    
    @classmethod
    def families(cls, self, writingSystem: QFontDatabase.WritingSystem=QFontDatabase.Any):
        'families(self, writingSystem: QFontDatabase.WritingSystem = QFontDatabase.Any) -> List[str]'
        pass
    
    @classmethod
    def font(cls, self, str, str_, int):
        'font(self, str, str, int) -> QFont'
        pass
    
    @classmethod
    def isBitmapScalable(cls, self, str, style: str=''):
        "isBitmapScalable(self, str, style: str = '') -> bool"
        return True
    
    @classmethod
    def isFixedPitch(cls, self, str, style: str=''):
        "isFixedPitch(self, str, style: str = '') -> bool"
        return True
    
    @classmethod
    def isPrivateFamily(cls, self, str):
        'isPrivateFamily(self, str) -> bool'
        return True
    
    @classmethod
    def isScalable(cls, self, str, style: str=''):
        "isScalable(self, str, style: str = '') -> bool"
        return True
    
    @classmethod
    def isSmoothlyScalable(cls, self, str, style: str=''):
        "isSmoothlyScalable(self, str, style: str = '') -> bool"
        return True
    
    @classmethod
    def italic(cls, self, str, str_):
        'italic(self, str, str) -> bool'
        return True
    
    @classmethod
    def pointSizes(cls, self, str, style: str=''):
        "pointSizes(self, str, style: str = '') -> List[int]"
        pass
    
    @classmethod
    def removeAllApplicationFonts(cls):
        'removeAllApplicationFonts() -> bool'
        return True
    
    @classmethod
    def removeApplicationFont(cls, int):
        'removeApplicationFont(int) -> bool'
        return True
    
    @classmethod
    def smoothSizes(cls, self, str, str_):
        'smoothSizes(self, str, str) -> List[int]'
        pass
    
    @classmethod
    def standardSizes(cls):
        'standardSizes() -> List[int]'
        pass
    
    @classmethod
    def styleString(cls, self, QFontInfo):
        'styleString(self, QFont) -> str\nstyleString(self, QFontInfo) -> str'
        return ''
    
    @classmethod
    def styles(cls, self, str):
        'styles(self, str) -> List[str]'
        pass
    
    @classmethod
    def supportsThreadedFontRendering(cls):
        'supportsThreadedFontRendering() -> bool'
        return True
    
    @classmethod
    def systemFont(cls, QFontDatabaseSystemFont):
        'systemFont(QFontDatabase.SystemFont) -> QFont'
        pass
    
    @classmethod
    def weight(cls, self, str, str_):
        'weight(self, str, str) -> int'
        return 1
    
    @classmethod
    def writingSystemName(cls, QFontDatabaseWritingSystem):
        'writingSystemName(QFontDatabase.WritingSystem) -> str'
        return ''
    
    @classmethod
    def writingSystemSample(cls, QFontDatabaseWritingSystem):
        'writingSystemSample(QFontDatabase.WritingSystem) -> str'
        return ''
    
    @classmethod
    def writingSystems(cls, self, str):
        'writingSystems(self) -> List[QFontDatabase.WritingSystem]\nwritingSystems(self, str) -> List[QFontDatabase.WritingSystem]'
        pass
    

class QFontInfo(_mod_sip.simplewrapper):
    'QFontInfo(QFont)\nQFontInfo(QFontInfo)'
    __class__ = QFontInfo
    __dict__ = {}
    def __init__(self, QFontInfo):
        'QFontInfo(QFont)\nQFontInfo(QFontInfo)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def bold(cls, self):
        'bold(self) -> bool'
        return True
    
    @classmethod
    def exactMatch(cls, self):
        'exactMatch(self) -> bool'
        return True
    
    @classmethod
    def family(cls, self):
        'family(self) -> str'
        return ''
    
    @classmethod
    def fixedPitch(cls, self):
        'fixedPitch(self) -> bool'
        return True
    
    @classmethod
    def italic(cls, self):
        'italic(self) -> bool'
        return True
    
    @classmethod
    def pixelSize(cls, self):
        'pixelSize(self) -> int'
        return 1
    
    @classmethod
    def pointSize(cls, self):
        'pointSize(self) -> int'
        return 1
    
    @classmethod
    def pointSizeF(cls, self):
        'pointSizeF(self) -> float'
        return 1.0
    
    @classmethod
    def rawMode(cls, self):
        'rawMode(self) -> bool'
        return True
    
    @classmethod
    def style(cls, self):
        'style(self) -> QFont.Style'
        pass
    
    @classmethod
    def styleHint(cls, self):
        'styleHint(self) -> QFont.StyleHint'
        pass
    
    @classmethod
    def styleName(cls, self):
        'styleName(self) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QFontInfo):
        'swap(self, QFontInfo)'
        pass
    
    @classmethod
    def weight(cls, self):
        'weight(self) -> int'
        return 1
    

class QFontMetrics(_mod_sip.simplewrapper):
    'QFontMetrics(QFont)\nQFontMetrics(QFont, QPaintDevice)\nQFontMetrics(QFontMetrics)'
    __class__ = QFontMetrics
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QFont, QPaintDevice):
        'QFontMetrics(QFont)\nQFontMetrics(QFont, QPaintDevice)\nQFontMetrics(QFontMetrics)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> int'
        return 1
    
    @classmethod
    def averageCharWidth(cls, self):
        'averageCharWidth(self) -> int'
        return 1
    
    @classmethod
    def boundingRect(cls, self, int, int_, int_1, int_2, int_3, str, tabStops: int=0, tabArray: Optional[List[int]]=0):
        'boundingRect(self, str) -> QRect\nboundingRect(self, QRect, int, str, tabStops: int = 0, tabArray: Optional[List[int]] = 0) -> QRect\nboundingRect(self, int, int, int, int, int, str, tabStops: int = 0, tabArray: Optional[List[int]] = 0) -> QRect'
        pass
    
    @classmethod
    def boundingRectChar(cls, self, str):
        'boundingRectChar(self, str) -> QRect'
        pass
    
    @classmethod
    def capHeight(cls, self):
        'capHeight(self) -> int'
        return 1
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> int'
        return 1
    
    @classmethod
    def elidedText(cls, self, str, QtTextElideMode, int, flags: int=0):
        'elidedText(self, str, Qt.TextElideMode, int, flags: int = 0) -> str'
        return ''
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def inFont(cls, self, str):
        'inFont(self, str) -> bool'
        return True
    
    @classmethod
    def inFontUcs4(cls, self, int):
        'inFontUcs4(self, int) -> bool'
        return True
    
    @classmethod
    def leading(cls, self):
        'leading(self) -> int'
        return 1
    
    @classmethod
    def leftBearing(cls, self, str):
        'leftBearing(self, str) -> int'
        return 1
    
    @classmethod
    def lineSpacing(cls, self):
        'lineSpacing(self) -> int'
        return 1
    
    @classmethod
    def lineWidth(cls, self):
        'lineWidth(self) -> int'
        return 1
    
    @classmethod
    def maxWidth(cls, self):
        'maxWidth(self) -> int'
        return 1
    
    @classmethod
    def minLeftBearing(cls, self):
        'minLeftBearing(self) -> int'
        return 1
    
    @classmethod
    def minRightBearing(cls, self):
        'minRightBearing(self) -> int'
        return 1
    
    @classmethod
    def overlinePos(cls, self):
        'overlinePos(self) -> int'
        return 1
    
    @classmethod
    def rightBearing(cls, self, str):
        'rightBearing(self, str) -> int'
        return 1
    
    @classmethod
    def size(cls, self, int, str, tabStops: int=0, tabArray: Optional[List[int]]=0):
        'size(self, int, str, tabStops: int = 0, tabArray: Optional[List[int]] = 0) -> QSize'
        pass
    
    @classmethod
    def strikeOutPos(cls, self):
        'strikeOutPos(self) -> int'
        return 1
    
    @classmethod
    def swap(cls, self, QFontMetrics):
        'swap(self, QFontMetrics)'
        pass
    
    @classmethod
    def tightBoundingRect(cls, self, str):
        'tightBoundingRect(self, str) -> QRect'
        pass
    
    @classmethod
    def underlinePos(cls, self):
        'underlinePos(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self, str, length: int=-1):
        'width(self, str, length: int = -1) -> int'
        return 1
    
    @classmethod
    def widthChar(cls, self, str):
        'widthChar(self, str) -> int'
        return 1
    
    @classmethod
    def xHeight(cls, self):
        'xHeight(self) -> int'
        return 1
    

class QFontMetricsF(_mod_sip.simplewrapper):
    'QFontMetricsF(QFont)\nQFontMetricsF(QFont, QPaintDevice)\nQFontMetricsF(QFontMetrics)\nQFontMetricsF(QFontMetricsF)'
    __class__ = QFontMetricsF
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QFont, QPaintDevice):
        'QFontMetricsF(QFont)\nQFontMetricsF(QFont, QPaintDevice)\nQFontMetricsF(QFontMetrics)\nQFontMetricsF(QFontMetricsF)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> float'
        return 1.0
    
    @classmethod
    def averageCharWidth(cls, self):
        'averageCharWidth(self) -> float'
        return 1.0
    
    @classmethod
    def boundingRect(cls, self, QRectF, int, str, tabStops: int=0, tabArray: Optional[List[int]]=0):
        'boundingRect(self, str) -> QRectF\nboundingRect(self, QRectF, int, str, tabStops: int = 0, tabArray: Optional[List[int]] = 0) -> QRectF'
        pass
    
    @classmethod
    def boundingRectChar(cls, self, str):
        'boundingRectChar(self, str) -> QRectF'
        pass
    
    @classmethod
    def capHeight(cls, self):
        'capHeight(self) -> float'
        return 1.0
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> float'
        return 1.0
    
    @classmethod
    def elidedText(cls, self, str, QtTextElideMode, float, flags: int=0):
        'elidedText(self, str, Qt.TextElideMode, float, flags: int = 0) -> str'
        return ''
    
    @classmethod
    def height(cls, self):
        'height(self) -> float'
        return 1.0
    
    @classmethod
    def inFont(cls, self, str):
        'inFont(self, str) -> bool'
        return True
    
    @classmethod
    def inFontUcs4(cls, self, int):
        'inFontUcs4(self, int) -> bool'
        return True
    
    @classmethod
    def leading(cls, self):
        'leading(self) -> float'
        return 1.0
    
    @classmethod
    def leftBearing(cls, self, str):
        'leftBearing(self, str) -> float'
        return 1.0
    
    @classmethod
    def lineSpacing(cls, self):
        'lineSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def lineWidth(cls, self):
        'lineWidth(self) -> float'
        return 1.0
    
    @classmethod
    def maxWidth(cls, self):
        'maxWidth(self) -> float'
        return 1.0
    
    @classmethod
    def minLeftBearing(cls, self):
        'minLeftBearing(self) -> float'
        return 1.0
    
    @classmethod
    def minRightBearing(cls, self):
        'minRightBearing(self) -> float'
        return 1.0
    
    @classmethod
    def overlinePos(cls, self):
        'overlinePos(self) -> float'
        return 1.0
    
    @classmethod
    def rightBearing(cls, self, str):
        'rightBearing(self, str) -> float'
        return 1.0
    
    @classmethod
    def size(cls, self, int, str, tabStops: int=0, tabArray: Optional[List[int]]=0):
        'size(self, int, str, tabStops: int = 0, tabArray: Optional[List[int]] = 0) -> QSizeF'
        pass
    
    @classmethod
    def strikeOutPos(cls, self):
        'strikeOutPos(self) -> float'
        return 1.0
    
    @classmethod
    def swap(cls, self, QFontMetricsF):
        'swap(self, QFontMetricsF)'
        pass
    
    @classmethod
    def tightBoundingRect(cls, self, str):
        'tightBoundingRect(self, str) -> QRectF'
        pass
    
    @classmethod
    def underlinePos(cls, self):
        'underlinePos(self) -> float'
        return 1.0
    
    @classmethod
    def width(cls, self, str):
        'width(self, str) -> float'
        return 1.0
    
    @classmethod
    def widthChar(cls, self, str):
        'widthChar(self, str) -> float'
        return 1.0
    
    @classmethod
    def xHeight(cls, self):
        'xHeight(self) -> float'
        return 1.0
    

class QGlyphRun(_mod_sip.simplewrapper):
    'QGlyphRun()\nQGlyphRun(QGlyphRun)'
    GlyphRunFlag = GlyphRunFlag()
    GlyphRunFlags = GlyphRunFlags()
    Overline = GlyphRunFlag()
    RightToLeft = GlyphRunFlag()
    SplitLigature = GlyphRunFlag()
    StrikeOut = GlyphRunFlag()
    Underline = GlyphRunFlag()
    __class__ = QGlyphRun
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QGlyphRun):
        'QGlyphRun()\nQGlyphRun(QGlyphRun)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRectF'
        pass
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> QGlyphRun.GlyphRunFlags'
        pass
    
    @classmethod
    def glyphIndexes(cls, self):
        'glyphIndexes(self) -> List[int]'
        pass
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isRightToLeft(cls, self):
        'isRightToLeft(self) -> bool'
        return True
    
    @classmethod
    def overline(cls, self):
        'overline(self) -> bool'
        return True
    
    @classmethod
    def positions(cls, self):
        'positions(self) -> List[QPointF]'
        pass
    
    @classmethod
    def rawFont(cls, self):
        'rawFont(self) -> QRawFont'
        pass
    
    @classmethod
    def setBoundingRect(cls, self, QRectF):
        'setBoundingRect(self, QRectF)'
        pass
    
    @classmethod
    def setFlag(cls, self, QGlyphRunGlyphRunFlag, enabled: bool=True):
        'setFlag(self, QGlyphRun.GlyphRunFlag, enabled: bool = True)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQGlyphRunGlyphRunFlags=None, QGlyphRunGlyphRunFlag=None):
        'setFlags(self, Union[QGlyphRun.GlyphRunFlags, QGlyphRun.GlyphRunFlag])'
        pass
    
    @classmethod
    def setGlyphIndexes(cls, self, Iterableint=None):
        'setGlyphIndexes(self, Iterable[int])'
        pass
    
    @classmethod
    def setOverline(cls, self, bool):
        'setOverline(self, bool)'
        pass
    
    @classmethod
    def setPositions(cls, self, IterableUnionQPointF=None, QPoint=None):
        'setPositions(self, Iterable[Union[QPointF, QPoint]])'
        pass
    
    @classmethod
    def setRawFont(cls, self, QRawFont):
        'setRawFont(self, QRawFont)'
        pass
    
    @classmethod
    def setRightToLeft(cls, self, bool):
        'setRightToLeft(self, bool)'
        pass
    
    @classmethod
    def setStrikeOut(cls, self, bool):
        'setStrikeOut(self, bool)'
        pass
    
    @classmethod
    def setUnderline(cls, self, bool):
        'setUnderline(self, bool)'
        pass
    
    @classmethod
    def strikeOut(cls, self):
        'strikeOut(self) -> bool'
        return True
    
    @classmethod
    def swap(cls, self, QGlyphRun):
        'swap(self, QGlyphRun)'
        pass
    
    @classmethod
    def underline(cls, self):
        'underline(self) -> bool'
        return True
    

class QGradient(_mod_sip.simplewrapper):
    'QGradient()\nQGradient(QGradient)'
    ConicalGradient = Type()
    CoordinateMode = CoordinateMode()
    LinearGradient = Type()
    LogicalMode = CoordinateMode()
    NoGradient = Type()
    ObjectBoundingMode = CoordinateMode()
    PadSpread = Spread()
    RadialGradient = Type()
    ReflectSpread = Spread()
    RepeatSpread = Spread()
    Spread = Spread()
    StretchToDeviceMode = CoordinateMode()
    Type = Type()
    __class__ = QGradient
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QGradient):
        'QGradient()\nQGradient(QGradient)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def coordinateMode(cls, self):
        'coordinateMode(self) -> QGradient.CoordinateMode'
        pass
    
    @classmethod
    def setColorAt(cls, self, float, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColorAt(self, float, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCoordinateMode(cls, self, QGradientCoordinateMode):
        'setCoordinateMode(self, QGradient.CoordinateMode)'
        pass
    
    @classmethod
    def setSpread(cls, self, QGradientSpread):
        'setSpread(self, QGradient.Spread)'
        pass
    
    @classmethod
    def setStops(cls, self, object):
        'setStops(self, object)'
        pass
    
    @classmethod
    def spread(cls, self):
        'spread(self) -> QGradient.Spread'
        pass
    
    @classmethod
    def stops(cls, self):
        'stops(self) -> object'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QGradient.Type'
        pass
    

class QGuiApplication(_mod_PyQt5_QtCore.QCoreApplication):
    'QGuiApplication(List[str])'
    __class__ = QGuiApplication
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, Liststr=None):
        'QGuiApplication(List[str])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def addLibraryPath(cls, str):
        'addLibraryPath(str)'
        pass
    
    @classmethod
    def allWindows(cls):
        'allWindows() -> object'
        pass
    
    @classmethod
    def applicationDirPath(cls):
        'applicationDirPath() -> str'
        return ''
    
    @classmethod
    def applicationDisplayName(cls):
        'applicationDisplayName() -> str'
        return ''
    
    @classmethod
    def applicationDisplayNameChanged(cls, self):
        'applicationDisplayNameChanged(self)'
        pass
    
    @classmethod
    def applicationFilePath(cls):
        'applicationFilePath() -> str'
        return ''
    
    @classmethod
    def applicationName(cls):
        'applicationName() -> str'
        return ''
    
    @classmethod
    def applicationPid(cls):
        'applicationPid() -> int'
        return 1
    
    @classmethod
    def applicationState(cls):
        'applicationState() -> Qt.ApplicationState'
        pass
    
    @classmethod
    def applicationVersion(cls):
        'applicationVersion() -> str'
        return ''
    
    @classmethod
    def arguments(cls):
        'arguments() -> List[str]'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def changeOverrideCursor(cls, UnionQCursor=None, QtCursorShape=None):
        'changeOverrideCursor(Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def clipboard(cls):
        'clipboard() -> QClipboard'
        pass
    
    @classmethod
    def closingDown(cls):
        'closingDown() -> bool'
        return True
    
    def commitDataRequest(self, QSessionManager):
        'commitDataRequest(self, QSessionManager) [signal]'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def desktopFileName(cls):
        'desktopFileName() -> str'
        return ''
    
    @classmethod
    def desktopSettingsAware(cls):
        'desktopSettingsAware() -> bool'
        return True
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventDispatcher(cls):
        'eventDispatcher() -> QAbstractEventDispatcher'
        pass
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exec(cls):
        'exec() -> int'
        return 1
    
    @classmethod
    def exec_(cls):
        'exec_() -> int'
        return 1
    
    @classmethod
    def exit(cls, returnCode: int=0):
        'exit(returnCode: int = 0)'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def flush(cls):
        'flush()'
        pass
    
    @classmethod
    def focusObject(cls):
        'focusObject() -> QObject'
        pass
    
    def focusObjectChanged(self, QObject):
        'focusObjectChanged(self, QObject) [signal]'
        pass
    
    @classmethod
    def focusWindow(cls):
        'focusWindow() -> QWindow'
        pass
    
    def focusWindowChanged(self, QWindow):
        'focusWindowChanged(self, QWindow) [signal]'
        pass
    
    @classmethod
    def font(cls):
        'font() -> QFont'
        pass
    
    def fontDatabaseChanged(self):
        'fontDatabaseChanged(self) [signal]'
        pass
    
    @classmethod
    def hasPendingEvents(cls):
        'hasPendingEvents() -> bool'
        return True
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def installNativeEventFilter(cls, self, QAbstractNativeEventFilter):
        'installNativeEventFilter(self, QAbstractNativeEventFilter)'
        pass
    
    @classmethod
    def installTranslator(cls, QTranslator):
        'installTranslator(QTranslator) -> bool'
        return True
    
    @classmethod
    def instance(cls):
        'instance() -> QCoreApplication'
        pass
    
    @classmethod
    def isFallbackSessionManagementEnabled(cls):
        'isFallbackSessionManagementEnabled() -> bool'
        return True
    
    @classmethod
    def isLeftToRight(cls):
        'isLeftToRight() -> bool'
        return True
    
    @classmethod
    def isQuitLockEnabled(cls):
        'isQuitLockEnabled() -> bool'
        return True
    
    @classmethod
    def isRightToLeft(cls):
        'isRightToLeft() -> bool'
        return True
    
    @classmethod
    def isSavingSession(cls, self):
        'isSavingSession(self) -> bool'
        return True
    
    @classmethod
    def isSessionRestored(cls, self):
        'isSessionRestored(self) -> bool'
        return True
    
    @classmethod
    def isSetuidAllowed(cls):
        'isSetuidAllowed() -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyboardModifiers(cls):
        'keyboardModifiers() -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    def lastWindowClosed(self):
        'lastWindowClosed(self) [signal]'
        pass
    
    @classmethod
    def layoutDirection(cls):
        'layoutDirection() -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def libraryPaths(cls):
        'libraryPaths() -> List[str]'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def modalWindow(cls):
        'modalWindow() -> QWindow'
        pass
    
    @classmethod
    def mouseButtons(cls):
        'mouseButtons() -> Qt.MouseButtons'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def notify(cls, self, QObject, QEvent):
        'notify(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def organizationDomain(cls):
        'organizationDomain() -> str'
        return ''
    
    @classmethod
    def organizationName(cls):
        'organizationName() -> str'
        return ''
    
    @classmethod
    def overrideCursor(cls):
        'overrideCursor() -> QCursor'
        pass
    
    @classmethod
    def palette(cls):
        'palette() -> QPalette'
        pass
    
    def paletteChanged(self, QPalette):
        'paletteChanged(self, QPalette) [signal]'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def platformName(cls):
        'platformName() -> str'
        return ''
    
    @classmethod
    def postEvent(cls, QObject, QEvent, priority: int=Qt.NormalEventPriority):
        'postEvent(QObject, QEvent, priority: int = Qt.NormalEventPriority)'
        pass
    
    @classmethod
    def primaryScreen(cls):
        'primaryScreen() -> QScreen'
        pass
    
    def primaryScreenChanged(self, QScreen):
        'primaryScreenChanged(self, QScreen) [signal]'
        pass
    
    @classmethod
    def processEvents(cls, flags: Union[QEventLoop.ProcessEventsFlags,QEventLoop.ProcessEventsFlag]=QEventLoop.AllEvents):
        'processEvents(flags: Union[QEventLoop.ProcessEventsFlags, QEventLoop.ProcessEventsFlag] = QEventLoop.AllEvents)\nprocessEvents(Union[QEventLoop.ProcessEventsFlags, QEventLoop.ProcessEventsFlag], int)'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def queryKeyboardModifiers(cls):
        'queryKeyboardModifiers() -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def quit(cls):
        'quit()'
        pass
    
    @classmethod
    def quitOnLastWindowClosed(cls):
        'quitOnLastWindowClosed() -> bool'
        return True
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def removeLibraryPath(cls, str):
        'removeLibraryPath(str)'
        pass
    
    @classmethod
    def removeNativeEventFilter(cls, self, QAbstractNativeEventFilter):
        'removeNativeEventFilter(self, QAbstractNativeEventFilter)'
        pass
    
    @classmethod
    def removePostedEvents(cls, QObject, eventType: int=0):
        'removePostedEvents(QObject, eventType: int = 0)'
        pass
    
    @classmethod
    def removeTranslator(cls, QTranslator):
        'removeTranslator(QTranslator) -> bool'
        return True
    
    @classmethod
    def restoreOverrideCursor(cls):
        'restoreOverrideCursor()'
        pass
    
    def saveStateRequest(self, QSessionManager):
        'saveStateRequest(self, QSessionManager) [signal]'
        pass
    
    def screenAdded(self, QScreen):
        'screenAdded(self, QScreen) [signal]'
        pass
    
    def screenRemoved(self, QScreen):
        'screenRemoved(self, QScreen) [signal]'
        pass
    
    @classmethod
    def screens(cls):
        'screens() -> object'
        pass
    
    @classmethod
    def sendEvent(cls, QObject, QEvent):
        'sendEvent(QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def sendPostedEvents(cls, receiver: QObject=None, eventType: int=0):
        'sendPostedEvents(receiver: QObject = None, eventType: int = 0)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def sessionId(cls, self):
        'sessionId(self) -> str'
        return ''
    
    @classmethod
    def sessionKey(cls, self):
        'sessionKey(self) -> str'
        return ''
    
    @classmethod
    def setApplicationDisplayName(cls, str):
        'setApplicationDisplayName(str)'
        pass
    
    @classmethod
    def setApplicationName(cls, str):
        'setApplicationName(str)'
        pass
    
    @classmethod
    def setApplicationVersion(cls, str):
        'setApplicationVersion(str)'
        pass
    
    @classmethod
    def setAttribute(cls, QtApplicationAttribute, on: bool=True):
        'setAttribute(Qt.ApplicationAttribute, on: bool = True)'
        pass
    
    @classmethod
    def setDesktopFileName(cls, str):
        'setDesktopFileName(str)'
        pass
    
    @classmethod
    def setDesktopSettingsAware(cls, bool):
        'setDesktopSettingsAware(bool)'
        pass
    
    @classmethod
    def setEventDispatcher(cls, QAbstractEventDispatcher):
        'setEventDispatcher(QAbstractEventDispatcher)'
        pass
    
    @classmethod
    def setFallbackSessionManagementEnabled(cls, bool):
        'setFallbackSessionManagementEnabled(bool)'
        pass
    
    @classmethod
    def setFont(cls, QFont):
        'setFont(QFont)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, QtLayoutDirection):
        'setLayoutDirection(Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setLibraryPaths(cls, Iterablestr=None):
        'setLibraryPaths(Iterable[str])'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOrganizationDomain(cls, str):
        'setOrganizationDomain(str)'
        pass
    
    @classmethod
    def setOrganizationName(cls, str):
        'setOrganizationName(str)'
        pass
    
    @classmethod
    def setOverrideCursor(cls, UnionQCursor=None, QtCursorShape=None):
        'setOverrideCursor(Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def setPalette(cls, QPalette):
        'setPalette(QPalette)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setQuitLockEnabled(cls, bool):
        'setQuitLockEnabled(bool)'
        pass
    
    @classmethod
    def setQuitOnLastWindowClosed(cls, bool):
        'setQuitOnLastWindowClosed(bool)'
        pass
    
    @classmethod
    def setSetuidAllowed(cls, bool):
        'setSetuidAllowed(bool)'
        pass
    
    @classmethod
    def setWindowIcon(cls, QIcon):
        'setWindowIcon(QIcon)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    @classmethod
    def startingUp(cls):
        'startingUp() -> bool'
        return True
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def sync(cls):
        'sync()'
        pass
    
    @classmethod
    def testAttribute(cls, QtApplicationAttribute):
        'testAttribute(Qt.ApplicationAttribute) -> bool'
        return True
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def topLevelAt(cls, QPoint):
        'topLevelAt(QPoint) -> QWindow'
        pass
    
    @classmethod
    def topLevelWindows(cls):
        'topLevelWindows() -> object'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def translate(cls, str, str_, disambiguation: str=None, n: int=-1):
        'translate(str, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def windowIcon(cls):
        'windowIcon() -> QIcon'
        pass
    

class QHelpEvent(_mod_PyQt5_QtCore.QEvent):
    'QHelpEvent(QEvent.Type, QPoint, QPoint)\nQHelpEvent(QHelpEvent)'
    __class__ = QHelpEvent
    __dict__ = {}
    def __init__(self, QEventType, QPoint, QPoint_):
        'QHelpEvent(QEvent.Type, QPoint, QPoint)\nQHelpEvent(QHelpEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QHideEvent(_mod_PyQt5_QtCore.QEvent):
    'QHideEvent()\nQHideEvent(QHideEvent)'
    __class__ = QHideEvent
    __dict__ = {}
    def __init__(self, QHideEvent):
        'QHideEvent()\nQHideEvent(QHideEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QHoverEvent(QInputEvent):
    'QHoverEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], modifiers: Union[Qt.KeyboardModifiers, Qt.KeyboardModifier] = Qt.NoModifier)\nQHoverEvent(QHoverEvent)'
    __class__ = QHoverEvent
    __dict__ = {}
    def __init__(self, QEventType, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, modifiers: Union[Qt.KeyboardModifiers,Qt.KeyboardModifier]=Qt.NoModifier):
        'QHoverEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], modifiers: Union[Qt.KeyboardModifiers, Qt.KeyboardModifier] = Qt.NoModifier)\nQHoverEvent(QHoverEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def oldPos(cls, self):
        'oldPos(self) -> QPoint'
        pass
    
    @classmethod
    def oldPosF(cls, self):
        'oldPosF(self) -> QPointF'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QIcon(_mod_sip.wrapper):
    'QIcon()\nQIcon(QPixmap)\nQIcon(QIcon)\nQIcon(str)\nQIcon(QIconEngine)\nQIcon(Any)'
    Active = Mode()
    Disabled = Mode()
    Mode = Mode()
    Normal = Mode()
    Off = State()
    On = State()
    Selected = Mode()
    State = State()
    __class__ = QIcon
    __dict__ = {}
    def __init__(self, QIconEngine):
        'QIcon()\nQIcon(QPixmap)\nQIcon(QIcon)\nQIcon(str)\nQIcon(QIconEngine)\nQIcon(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def actualSize(cls, self, QWindow, QSize, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'actualSize(self, QSize, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QSize\nactualSize(self, QWindow, QSize, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QSize'
        pass
    
    @classmethod
    def addFile(cls, self, str, size: QSize=QSize(), mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'addFile(self, str, size: QSize = QSize(), mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off)'
        pass
    
    @classmethod
    def addPixmap(cls, self, QPixmap, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'addPixmap(self, QPixmap, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off)'
        pass
    
    @classmethod
    def availableSizes(cls, self, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'availableSizes(self, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> List[QSize]'
        pass
    
    @classmethod
    def cacheKey(cls, self):
        'cacheKey(self) -> int'
        return 1
    
    @classmethod
    def fromTheme(cls, str, QIcon):
        'fromTheme(str) -> QIcon\nfromTheme(str, QIcon) -> QIcon'
        pass
    
    @classmethod
    def hasThemeIcon(cls, str):
        'hasThemeIcon(str) -> bool'
        return True
    
    @classmethod
    def isDetached(cls, self):
        'isDetached(self) -> bool'
        return True
    
    @classmethod
    def isMask(cls, self):
        'isMask(self) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def name(cls, self):
        'name(self) -> str'
        return ''
    
    @classmethod
    def paint(cls, self, QPainter, int, int_, int_1, int_2, alignment: Union[Qt.Alignment,Qt.AlignmentFlag]=Qt.AlignCenter, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'paint(self, QPainter, QRect, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.AlignCenter, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off)\npaint(self, QPainter, int, int, int, int, alignment: Union[Qt.Alignment, Qt.AlignmentFlag] = Qt.AlignCenter, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off)'
        pass
    
    @classmethod
    def pixmap(cls, self, QWindow, QSize, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'pixmap(self, QSize, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QPixmap\npixmap(self, int, int, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QPixmap\npixmap(self, int, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QPixmap\npixmap(self, QWindow, QSize, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> QPixmap'
        pass
    
    @classmethod
    def setIsMask(cls, self, bool):
        'setIsMask(self, bool)'
        pass
    
    @classmethod
    def setThemeName(cls, str):
        'setThemeName(str)'
        pass
    
    @classmethod
    def setThemeSearchPaths(cls, Iterablestr=None):
        'setThemeSearchPaths(Iterable[str])'
        pass
    
    @classmethod
    def swap(cls, self, QIcon):
        'swap(self, QIcon)'
        pass
    
    @classmethod
    def themeName(cls):
        'themeName() -> str'
        return ''
    
    @classmethod
    def themeSearchPaths(cls):
        'themeSearchPaths() -> List[str]'
        pass
    

class QIconDragEvent(_mod_PyQt5_QtCore.QEvent):
    'QIconDragEvent()\nQIconDragEvent(QIconDragEvent)'
    __class__ = QIconDragEvent
    __dict__ = {}
    def __init__(self, QIconDragEvent):
        'QIconDragEvent()\nQIconDragEvent(QIconDragEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QIconEngine(_mod_sip.wrapper):
    'QIconEngine()\nQIconEngine(QIconEngine)'
    AvailableSizesArgument = AvailableSizesArgument()
    AvailableSizesHook = IconEngineHook()
    IconEngineHook = IconEngineHook()
    IconNameHook = IconEngineHook()
    IsNullHook = IconEngineHook()
    ScaledPixmapArgument = ScaledPixmapArgument()
    ScaledPixmapHook = IconEngineHook()
    __class__ = QIconEngine
    __dict__ = {}
    def __init__(self, QIconEngine):
        'QIconEngine()\nQIconEngine(QIconEngine)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def actualSize(cls, self, QSize, QIconMode, QIconState):
        'actualSize(self, QSize, QIcon.Mode, QIcon.State) -> QSize'
        pass
    
    @classmethod
    def addFile(cls, self, str, QSize, QIconMode, QIconState):
        'addFile(self, str, QSize, QIcon.Mode, QIcon.State)'
        pass
    
    @classmethod
    def addPixmap(cls, self, QPixmap, QIconMode, QIconState):
        'addPixmap(self, QPixmap, QIcon.Mode, QIcon.State)'
        pass
    
    @classmethod
    def availableSizes(cls, self, mode: QIcon.Mode=QIcon.Normal, state: QIcon.State=QIcon.Off):
        'availableSizes(self, mode: QIcon.Mode = QIcon.Normal, state: QIcon.State = QIcon.Off) -> List[QSize]'
        pass
    
    @classmethod
    def clone(cls, self):
        'clone(self) -> QIconEngine'
        pass
    
    @classmethod
    def iconName(cls, self):
        'iconName(self) -> str'
        return ''
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def key(cls, self):
        'key(self) -> str'
        return ''
    
    @classmethod
    def paint(cls, self, QPainter, QRect, QIconMode, QIconState):
        'paint(self, QPainter, QRect, QIcon.Mode, QIcon.State)'
        pass
    
    @classmethod
    def pixmap(cls, self, QSize, QIconMode, QIconState):
        'pixmap(self, QSize, QIcon.Mode, QIcon.State) -> QPixmap'
        pass
    
    @classmethod
    def read(cls, self, QDataStream):
        'read(self, QDataStream) -> bool'
        return True
    
    @classmethod
    def scaledPixmap(cls, self, QSize, QIconMode, QIconState, float):
        'scaledPixmap(self, QSize, QIcon.Mode, QIcon.State, float) -> QPixmap'
        pass
    
    @classmethod
    def write(cls, self, QDataStream):
        'write(self, QDataStream) -> bool'
        return True
    

class QImage(QPaintDevice):
    'QImage()\nQImage(QSize, QImage.Format)\nQImage(int, int, QImage.Format)\nQImage(bytes, int, int, QImage.Format)\nQImage(sip.voidptr, int, int, QImage.Format)\nQImage(bytes, int, int, int, QImage.Format)\nQImage(sip.voidptr, int, int, int, QImage.Format)\nQImage(List[str])\nQImage(str, format: str = None)\nQImage(QImage)\nQImage(Any)'
    Format = Format()
    Format_A2BGR30_Premultiplied = Format()
    Format_A2RGB30_Premultiplied = Format()
    Format_ARGB32 = Format()
    Format_ARGB32_Premultiplied = Format()
    Format_ARGB4444_Premultiplied = Format()
    Format_ARGB6666_Premultiplied = Format()
    Format_ARGB8555_Premultiplied = Format()
    Format_ARGB8565_Premultiplied = Format()
    Format_Alpha8 = Format()
    Format_BGR30 = Format()
    Format_Grayscale8 = Format()
    Format_Indexed8 = Format()
    Format_Invalid = Format()
    Format_Mono = Format()
    Format_MonoLSB = Format()
    Format_RGB16 = Format()
    Format_RGB30 = Format()
    Format_RGB32 = Format()
    Format_RGB444 = Format()
    Format_RGB555 = Format()
    Format_RGB666 = Format()
    Format_RGB888 = Format()
    Format_RGBA8888 = Format()
    Format_RGBA8888_Premultiplied = Format()
    Format_RGBX8888 = Format()
    InvertMode = InvertMode()
    InvertRgb = InvertMode()
    InvertRgba = InvertMode()
    __class__ = QImage
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, sipvoidptr, int, int_, int_1, QImageFormat):
        'QImage()\nQImage(QSize, QImage.Format)\nQImage(int, int, QImage.Format)\nQImage(bytes, int, int, QImage.Format)\nQImage(sip.voidptr, int, int, QImage.Format)\nQImage(bytes, int, int, int, QImage.Format)\nQImage(sip.voidptr, int, int, int, QImage.Format)\nQImage(List[str])\nQImage(str, format: str = None)\nQImage(QImage)\nQImage(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def allGray(cls, self):
        'allGray(self) -> bool'
        return True
    
    @classmethod
    def bitPlaneCount(cls, self):
        'bitPlaneCount(self) -> int'
        return 1
    
    @classmethod
    def bits(cls, self):
        'bits(self) -> sip.voidptr'
        pass
    
    @classmethod
    def byteCount(cls, self):
        'byteCount(self) -> int'
        return 1
    
    @classmethod
    def bytesPerLine(cls, self):
        'bytesPerLine(self) -> int'
        return 1
    
    @classmethod
    def cacheKey(cls, self):
        'cacheKey(self) -> int'
        return 1
    
    @classmethod
    def color(cls, self, int):
        'color(self, int) -> int'
        return 1
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def colorTable(cls, self):
        'colorTable(self) -> List[int]'
        pass
    
    @classmethod
    def constBits(cls, self):
        'constBits(self) -> sip.voidptr'
        pass
    
    @classmethod
    def constScanLine(cls, self, int):
        'constScanLine(self, int) -> sip.voidptr'
        pass
    
    @classmethod
    def convertToFormat(cls, self, QImageFormat, Iterableint=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'convertToFormat(self, QImage.Format, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QImage\nconvertToFormat(self, QImage.Format, Iterable[int], flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QImage'
        pass
    
    @classmethod
    def copy(cls, self, rect: QRect=QRect()):
        'copy(self, rect: QRect = QRect()) -> QImage\ncopy(self, int, int, int, int) -> QImage'
        pass
    
    @classmethod
    def createAlphaMask(cls, self, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'createAlphaMask(self, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QImage'
        pass
    
    @classmethod
    def createHeuristicMask(cls, self, clipTight: bool=True):
        'createHeuristicMask(self, clipTight: bool = True) -> QImage'
        pass
    
    @classmethod
    def createMaskFromColor(cls, self, int, mode: Qt.MaskMode=Qt.MaskInColor):
        'createMaskFromColor(self, int, mode: Qt.MaskMode = Qt.MaskInColor) -> QImage'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def detach(cls, self):
        'detach(self)'
        pass
    
    @classmethod
    def devType(cls, self):
        'devType(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def dotsPerMeterX(cls, self):
        'dotsPerMeterX(self) -> int'
        return 1
    
    @classmethod
    def dotsPerMeterY(cls, self):
        'dotsPerMeterY(self) -> int'
        return 1
    
    @classmethod
    def fill(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'fill(self, Qt.GlobalColor)\nfill(self, Union[QColor, Qt.GlobalColor, QGradient])\nfill(self, int)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QImage.Format'
        pass
    
    @classmethod
    def fromData(cls, UnionQByteArray=None, bytes=None, bytearray=None, format: str=None):
        'fromData(bytes, format: str = None) -> QImage\nfromData(Union[QByteArray, bytes, bytearray], format: str = None) -> QImage'
        pass
    
    @classmethod
    def hasAlphaChannel(cls, self):
        'hasAlphaChannel(self) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def invertPixels(cls, self, mode: QImage.InvertMode=QImage.InvertRgb):
        'invertPixels(self, mode: QImage.InvertMode = QImage.InvertRgb)'
        pass
    
    @classmethod
    def isDetached(cls, self):
        'isDetached(self) -> bool'
        return True
    
    @classmethod
    def isGrayscale(cls, self):
        'isGrayscale(self) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def load(cls, self, str, format: str=None):
        'load(self, QIODevice, str) -> bool\nload(self, str, format: str = None) -> bool'
        return True
    
    @classmethod
    def loadFromData(cls, self, UnionQByteArray=None, bytes=None, bytearray=None, format: str=None):
        'loadFromData(self, bytes, format: str = None) -> bool\nloadFromData(self, Union[QByteArray, bytes, bytearray], format: str = None) -> bool'
        return True
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def mirrored(cls, self, horizontal: bool=False, vertical: bool=True):
        'mirrored(self, horizontal: bool = False, vertical: bool = True) -> QImage'
        pass
    
    @classmethod
    def offset(cls, self):
        'offset(self) -> QPoint'
        pass
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def pixel(cls, self, int, int_):
        'pixel(self, QPoint) -> int\npixel(self, int, int) -> int'
        return 1
    
    @classmethod
    def pixelColor(cls, self, int, int_):
        'pixelColor(self, int, int) -> QColor\npixelColor(self, QPoint) -> QColor'
        pass
    
    @classmethod
    def pixelFormat(cls, self):
        'pixelFormat(self) -> QPixelFormat'
        pass
    
    @classmethod
    def pixelIndex(cls, self, int, int_):
        'pixelIndex(self, QPoint) -> int\npixelIndex(self, int, int) -> int'
        return 1
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRect'
        pass
    
    @classmethod
    def reinterpretAsFormat(cls, self, QImageFormat):
        'reinterpretAsFormat(self, QImage.Format) -> bool'
        return True
    
    @classmethod
    def rgbSwapped(cls, self):
        'rgbSwapped(self) -> QImage'
        pass
    
    @classmethod
    def save(cls, self, QIODevice, format: str=None, quality: int=-1):
        'save(self, str, format: str = None, quality: int = -1) -> bool\nsave(self, QIODevice, format: str = None, quality: int = -1) -> bool'
        return True
    
    @classmethod
    def scaled(cls, self, int, int_, aspectRatioMode: Qt.AspectRatioMode=Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode=Qt.FastTransformation):
        'scaled(self, int, int, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QImage\nscaled(self, QSize, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QImage'
        pass
    
    @classmethod
    def scaledToHeight(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToHeight(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QImage'
        pass
    
    @classmethod
    def scaledToWidth(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToWidth(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QImage'
        pass
    
    @classmethod
    def scanLine(cls, self, int):
        'scanLine(self, int) -> sip.voidptr'
        pass
    
    @classmethod
    def setColor(cls, self, int, int_):
        'setColor(self, int, int)'
        pass
    
    @classmethod
    def setColorCount(cls, self, int):
        'setColorCount(self, int)'
        pass
    
    @classmethod
    def setColorTable(cls, self, Iterableint=None):
        'setColorTable(self, Iterable[int])'
        pass
    
    @classmethod
    def setDevicePixelRatio(cls, self, float):
        'setDevicePixelRatio(self, float)'
        pass
    
    @classmethod
    def setDotsPerMeterX(cls, self, int):
        'setDotsPerMeterX(self, int)'
        pass
    
    @classmethod
    def setDotsPerMeterY(cls, self, int):
        'setDotsPerMeterY(self, int)'
        pass
    
    @classmethod
    def setOffset(cls, self, QPoint):
        'setOffset(self, QPoint)'
        pass
    
    @classmethod
    def setPixel(cls, self, int, int_, int_1):
        'setPixel(self, QPoint, int)\nsetPixel(self, int, int, int)'
        pass
    
    @classmethod
    def setPixelColor(cls, self, int, int_, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setPixelColor(self, int, int, Union[QColor, Qt.GlobalColor, QGradient])\nsetPixelColor(self, QPoint, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setText(cls, self, str, str_):
        'setText(self, str, str)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def smoothScaled(cls, self, int, int_):
        'smoothScaled(self, int, int) -> QImage'
        pass
    
    @classmethod
    def swap(cls, self, QImage):
        'swap(self, QImage)'
        pass
    
    @classmethod
    def text(cls, self, key: str=''):
        "text(self, key: str = '') -> str"
        return ''
    
    @classmethod
    def textKeys(cls, self):
        'textKeys(self) -> List[str]'
        pass
    
    @classmethod
    def toImageFormat(cls, QPixelFormat):
        'toImageFormat(QPixelFormat) -> QImage.Format'
        pass
    
    @classmethod
    def toPixelFormat(cls, QImageFormat):
        'toPixelFormat(QImage.Format) -> QPixelFormat'
        pass
    
    @classmethod
    def transformed(cls, self, QTransform, mode: Qt.TransformationMode=Qt.FastTransformation):
        'transformed(self, QTransform, mode: Qt.TransformationMode = Qt.FastTransformation) -> QImage'
        pass
    
    @classmethod
    def trueMatrix(cls, QTransform, int, int_):
        'trueMatrix(QTransform, int, int) -> QTransform'
        pass
    
    @classmethod
    def valid(cls, self, int, int_):
        'valid(self, QPoint) -> bool\nvalid(self, int, int) -> bool'
        return True
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QImageIOHandler(_mod_sip.simplewrapper):
    'QImageIOHandler()'
    Animation = ImageOption()
    BackgroundColor = ImageOption()
    ClipRect = ImageOption()
    CompressionRatio = ImageOption()
    Description = ImageOption()
    Endianness = ImageOption()
    Gamma = ImageOption()
    ImageOption = ImageOption()
    ImageTransformation = ImageOption()
    IncrementalReading = ImageOption()
    Name = ImageOption()
    OptimizedWrite = ImageOption()
    ProgressiveScanWrite = ImageOption()
    Quality = ImageOption()
    ScaledClipRect = ImageOption()
    ScaledSize = ImageOption()
    Size = ImageOption()
    SubType = ImageOption()
    SupportedSubTypes = ImageOption()
    Transformation = Transformation()
    TransformationFlip = Transformation()
    TransformationFlipAndRotate90 = Transformation()
    TransformationMirror = Transformation()
    TransformationMirrorAndRotate90 = Transformation()
    TransformationNone = Transformation()
    TransformationRotate180 = Transformation()
    TransformationRotate270 = Transformation()
    TransformationRotate90 = Transformation()
    Transformations = Transformations()
    TransformedByDefault = ImageOption()
    __class__ = QImageIOHandler
    __dict__ = {}
    def __init__(self):
        'QImageIOHandler()'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def canRead(cls, self):
        'canRead(self) -> bool'
        return True
    
    @classmethod
    def currentImageNumber(cls, self):
        'currentImageNumber(self) -> int'
        return 1
    
    @classmethod
    def currentImageRect(cls, self):
        'currentImageRect(self) -> QRect'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QIODevice'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QByteArray'
        pass
    
    @classmethod
    def imageCount(cls, self):
        'imageCount(self) -> int'
        return 1
    
    @classmethod
    def jumpToImage(cls, self, int):
        'jumpToImage(self, int) -> bool'
        return True
    
    @classmethod
    def jumpToNextImage(cls, self):
        'jumpToNextImage(self) -> bool'
        return True
    
    @classmethod
    def loopCount(cls, self):
        'loopCount(self) -> int'
        return 1
    
    @classmethod
    def nextImageDelay(cls, self):
        'nextImageDelay(self) -> int'
        return 1
    
    @classmethod
    def option(cls, self, QImageIOHandlerImageOption):
        'option(self, QImageIOHandler.ImageOption) -> Any'
        pass
    
    @classmethod
    def read(cls, self, QImage):
        'read(self, QImage) -> bool'
        return True
    
    @classmethod
    def setDevice(cls, self, QIODevice):
        'setDevice(self, QIODevice)'
        pass
    
    @classmethod
    def setFormat(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setFormat(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def setOption(cls, self, QImageIOHandlerImageOption, Any):
        'setOption(self, QImageIOHandler.ImageOption, Any)'
        pass
    
    @classmethod
    def supportsOption(cls, self, QImageIOHandlerImageOption):
        'supportsOption(self, QImageIOHandler.ImageOption) -> bool'
        return True
    
    @classmethod
    def write(cls, self, QImage):
        'write(self, QImage) -> bool'
        return True
    

class QImageReader(_mod_sip.simplewrapper):
    'QImageReader()\nQImageReader(QIODevice, format: Union[QByteArray, bytes, bytearray] = QByteArray())\nQImageReader(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
    DeviceError = ImageReaderError()
    FileNotFoundError = ImageReaderError()
    ImageReaderError = ImageReaderError()
    InvalidDataError = ImageReaderError()
    UnknownError = ImageReaderError()
    UnsupportedFormatError = ImageReaderError()
    __class__ = QImageReader
    __dict__ = {}
    def __init__(self, QIODevice, format: Union[QByteArray,bytes,bytearray]=QByteArray()):
        'QImageReader()\nQImageReader(QIODevice, format: Union[QByteArray, bytes, bytearray] = QByteArray())\nQImageReader(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def autoDetectImageFormat(cls, self):
        'autoDetectImageFormat(self) -> bool'
        return True
    
    @classmethod
    def autoTransform(cls, self):
        'autoTransform(self) -> bool'
        return True
    
    @classmethod
    def backgroundColor(cls, self):
        'backgroundColor(self) -> QColor'
        pass
    
    @classmethod
    def canRead(cls, self):
        'canRead(self) -> bool'
        return True
    
    @classmethod
    def clipRect(cls, self):
        'clipRect(self) -> QRect'
        pass
    
    @classmethod
    def currentImageNumber(cls, self):
        'currentImageNumber(self) -> int'
        return 1
    
    @classmethod
    def currentImageRect(cls, self):
        'currentImageRect(self) -> QRect'
        pass
    
    @classmethod
    def decideFormatFromContent(cls, self):
        'decideFormatFromContent(self) -> bool'
        return True
    
    @classmethod
    def device(cls, self):
        'device(self) -> QIODevice'
        pass
    
    @classmethod
    def error(cls, self):
        'error(self) -> QImageReader.ImageReaderError'
        pass
    
    @classmethod
    def errorString(cls, self):
        'errorString(self) -> str'
        return ''
    
    @classmethod
    def fileName(cls, self):
        'fileName(self) -> str'
        return ''
    
    @classmethod
    def format(cls, self):
        'format(self) -> QByteArray'
        pass
    
    @classmethod
    def gamma(cls, self):
        'gamma(self) -> float'
        return 1.0
    
    @classmethod
    def imageCount(cls, self):
        'imageCount(self) -> int'
        return 1
    
    @classmethod
    def imageFormat(cls, QIODevice):
        'imageFormat(str) -> QByteArray\nimageFormat(QIODevice) -> QByteArray\nimageFormat(self) -> QImage.Format'
        pass
    
    @classmethod
    def jumpToImage(cls, self, int):
        'jumpToImage(self, int) -> bool'
        return True
    
    @classmethod
    def jumpToNextImage(cls, self):
        'jumpToNextImage(self) -> bool'
        return True
    
    @classmethod
    def loopCount(cls, self):
        'loopCount(self) -> int'
        return 1
    
    @classmethod
    def nextImageDelay(cls, self):
        'nextImageDelay(self) -> int'
        return 1
    
    @classmethod
    def quality(cls, self):
        'quality(self) -> int'
        return 1
    
    @classmethod
    def read(cls, self, QImage):
        'read(self) -> QImage\nread(self, QImage) -> bool'
        pass
    
    @classmethod
    def scaledClipRect(cls, self):
        'scaledClipRect(self) -> QRect'
        pass
    
    @classmethod
    def scaledSize(cls, self):
        'scaledSize(self) -> QSize'
        pass
    
    @classmethod
    def setAutoDetectImageFormat(cls, self, bool):
        'setAutoDetectImageFormat(self, bool)'
        pass
    
    @classmethod
    def setAutoTransform(cls, self, bool):
        'setAutoTransform(self, bool)'
        pass
    
    @classmethod
    def setBackgroundColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setBackgroundColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setClipRect(cls, self, QRect):
        'setClipRect(self, QRect)'
        pass
    
    @classmethod
    def setDecideFormatFromContent(cls, self, bool):
        'setDecideFormatFromContent(self, bool)'
        pass
    
    @classmethod
    def setDevice(cls, self, QIODevice):
        'setDevice(self, QIODevice)'
        pass
    
    @classmethod
    def setFileName(cls, self, str):
        'setFileName(self, str)'
        pass
    
    @classmethod
    def setFormat(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setFormat(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def setGamma(cls, self, float):
        'setGamma(self, float)'
        pass
    
    @classmethod
    def setQuality(cls, self, int):
        'setQuality(self, int)'
        pass
    
    @classmethod
    def setScaledClipRect(cls, self, QRect):
        'setScaledClipRect(self, QRect)'
        pass
    
    @classmethod
    def setScaledSize(cls, self, QSize):
        'setScaledSize(self, QSize)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def subType(cls, self):
        'subType(self) -> QByteArray'
        pass
    
    @classmethod
    def supportedImageFormats(cls):
        'supportedImageFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def supportedMimeTypes(cls):
        'supportedMimeTypes() -> List[QByteArray]'
        pass
    
    @classmethod
    def supportedSubTypes(cls, self):
        'supportedSubTypes(self) -> List[QByteArray]'
        pass
    
    @classmethod
    def supportsAnimation(cls, self):
        'supportsAnimation(self) -> bool'
        return True
    
    @classmethod
    def supportsOption(cls, self, QImageIOHandlerImageOption):
        'supportsOption(self, QImageIOHandler.ImageOption) -> bool'
        return True
    
    @classmethod
    def text(cls, self, str):
        'text(self, str) -> str'
        return ''
    
    @classmethod
    def textKeys(cls, self):
        'textKeys(self) -> List[str]'
        pass
    
    @classmethod
    def transformation(cls, self):
        'transformation(self) -> QImageIOHandler.Transformations'
        pass
    

class QImageWriter(_mod_sip.simplewrapper):
    'QImageWriter()\nQImageWriter(QIODevice, Union[QByteArray, bytes, bytearray])\nQImageWriter(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
    DeviceError = ImageWriterError()
    ImageWriterError = ImageWriterError()
    UnknownError = ImageWriterError()
    UnsupportedFormatError = ImageWriterError()
    __class__ = QImageWriter
    __dict__ = {}
    def __init__(self, str, format: Union[QByteArray,bytes,bytearray]=QByteArray()):
        'QImageWriter()\nQImageWriter(QIODevice, Union[QByteArray, bytes, bytearray])\nQImageWriter(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def canWrite(cls, self):
        'canWrite(self) -> bool'
        return True
    
    @classmethod
    def compression(cls, self):
        'compression(self) -> int'
        return 1
    
    @classmethod
    def device(cls, self):
        'device(self) -> QIODevice'
        pass
    
    @classmethod
    def error(cls, self):
        'error(self) -> QImageWriter.ImageWriterError'
        pass
    
    @classmethod
    def errorString(cls, self):
        'errorString(self) -> str'
        return ''
    
    @classmethod
    def fileName(cls, self):
        'fileName(self) -> str'
        return ''
    
    @classmethod
    def format(cls, self):
        'format(self) -> QByteArray'
        pass
    
    @classmethod
    def gamma(cls, self):
        'gamma(self) -> float'
        return 1.0
    
    @classmethod
    def optimizedWrite(cls, self):
        'optimizedWrite(self) -> bool'
        return True
    
    @classmethod
    def progressiveScanWrite(cls, self):
        'progressiveScanWrite(self) -> bool'
        return True
    
    @classmethod
    def quality(cls, self):
        'quality(self) -> int'
        return 1
    
    @classmethod
    def setCompression(cls, self, int):
        'setCompression(self, int)'
        pass
    
    @classmethod
    def setDevice(cls, self, QIODevice):
        'setDevice(self, QIODevice)'
        pass
    
    @classmethod
    def setFileName(cls, self, str):
        'setFileName(self, str)'
        pass
    
    @classmethod
    def setFormat(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setFormat(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def setGamma(cls, self, float):
        'setGamma(self, float)'
        pass
    
    @classmethod
    def setOptimizedWrite(cls, self, bool):
        'setOptimizedWrite(self, bool)'
        pass
    
    @classmethod
    def setProgressiveScanWrite(cls, self, bool):
        'setProgressiveScanWrite(self, bool)'
        pass
    
    @classmethod
    def setQuality(cls, self, int):
        'setQuality(self, int)'
        pass
    
    @classmethod
    def setSubType(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setSubType(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def setText(cls, self, str, str_):
        'setText(self, str, str)'
        pass
    
    @classmethod
    def setTransformation(cls, self, UnionQImageIOHandlerTransformations=None, QImageIOHandlerTransformation=None):
        'setTransformation(self, Union[QImageIOHandler.Transformations, QImageIOHandler.Transformation])'
        pass
    
    @classmethod
    def subType(cls, self):
        'subType(self) -> QByteArray'
        pass
    
    @classmethod
    def supportedImageFormats(cls):
        'supportedImageFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def supportedMimeTypes(cls):
        'supportedMimeTypes() -> List[QByteArray]'
        pass
    
    @classmethod
    def supportedSubTypes(cls, self):
        'supportedSubTypes(self) -> List[QByteArray]'
        pass
    
    @classmethod
    def supportsOption(cls, self, QImageIOHandlerImageOption):
        'supportsOption(self, QImageIOHandler.ImageOption) -> bool'
        return True
    
    @classmethod
    def transformation(cls, self):
        'transformation(self) -> QImageIOHandler.Transformations'
        pass
    
    @classmethod
    def write(cls, self, QImage):
        'write(self, QImage) -> bool'
        return True
    

class QInputEvent(_mod_PyQt5_QtCore.QEvent):
    __class__ = QInputEvent
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QInputMethod(_mod_PyQt5_QtCore.QObject):
    Action = Action()
    Click = Action()
    ContextMenu = Action()
    __class__ = QInputMethod
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def anchorRectangle(cls, self):
        'anchorRectangle(self) -> QRectF'
        pass
    
    def anchorRectangleChanged(self):
        'anchorRectangleChanged(self) [signal]'
        pass
    
    def animatingChanged(self):
        'animatingChanged(self) [signal]'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def commit(cls, self):
        'commit(self)'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def cursorRectangle(cls, self):
        'cursorRectangle(self) -> QRectF'
        pass
    
    def cursorRectangleChanged(self):
        'cursorRectangleChanged(self) [signal]'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def hide(cls, self):
        'hide(self)'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def inputDirection(cls, self):
        'inputDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def inputItemClipRectangle(cls, self):
        'inputItemClipRectangle(self) -> QRectF'
        pass
    
    def inputItemClipRectangleChanged(self):
        'inputItemClipRectangleChanged(self) [signal]'
        pass
    
    @classmethod
    def inputItemRectangle(cls, self):
        'inputItemRectangle(self) -> QRectF'
        pass
    
    @classmethod
    def inputItemTransform(cls, self):
        'inputItemTransform(self) -> QTransform'
        pass
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def invokeAction(cls, self, QInputMethodAction, int):
        'invokeAction(self, QInputMethod.Action, int)'
        pass
    
    @classmethod
    def isAnimating(cls, self):
        'isAnimating(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyboardRectangle(cls, self):
        'keyboardRectangle(self) -> QRectF'
        pass
    
    def keyboardRectangleChanged(self):
        'keyboardRectangleChanged(self) [signal]'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    def localeChanged(self):
        'localeChanged(self) [signal]'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def queryFocusObject(cls, QtInputMethodQuery, Any):
        'queryFocusObject(Qt.InputMethodQuery, Any) -> Any'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reset(cls, self):
        'reset(self)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setInputItemRectangle(cls, self, QRectF):
        'setInputItemRectangle(self, QRectF)'
        pass
    
    @classmethod
    def setInputItemTransform(cls, self, QTransform):
        'setInputItemTransform(self, QTransform)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def show(cls, self):
        'show(self)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def update(cls, self, UnionQtInputMethodQueries=None, QtInputMethodQuery=None):
        'update(self, Union[Qt.InputMethodQueries, Qt.InputMethodQuery])'
        pass
    
    def visibleChanged(self):
        'visibleChanged(self) [signal]'
        pass
    

class QInputMethodEvent(_mod_PyQt5_QtCore.QEvent):
    'QInputMethodEvent()\nQInputMethodEvent(str, object)\nQInputMethodEvent(QInputMethodEvent)'
    Attribute = Attribute()
    AttributeType = AttributeType()
    Cursor = AttributeType()
    Language = AttributeType()
    Ruby = AttributeType()
    Selection = AttributeType()
    TextFormat = AttributeType()
    __class__ = QInputMethodEvent
    __dict__ = {}
    def __init__(self, QInputMethodEvent):
        'QInputMethodEvent()\nQInputMethodEvent(str, object)\nQInputMethodEvent(QInputMethodEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def attributes(cls, self):
        'attributes(self) -> List[QInputMethodEvent.Attribute]'
        pass
    
    @classmethod
    def commitString(cls, self):
        'commitString(self) -> str'
        return ''
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def preeditString(cls, self):
        'preeditString(self) -> str'
        return ''
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def replacementLength(cls, self):
        'replacementLength(self) -> int'
        return 1
    
    @classmethod
    def replacementStart(cls, self):
        'replacementStart(self) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setCommitString(cls, self, str, from_: int=0, length: int=0):
        'setCommitString(self, str, from_: int = 0, length: int = 0)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QInputMethodQueryEvent(_mod_PyQt5_QtCore.QEvent):
    'QInputMethodQueryEvent(Union[Qt.InputMethodQueries, Qt.InputMethodQuery])\nQInputMethodQueryEvent(QInputMethodQueryEvent)'
    __class__ = QInputMethodQueryEvent
    __dict__ = {}
    def __init__(self, UnionQtInputMethodQueries=None, QtInputMethodQuery=None):
        'QInputMethodQueryEvent(Union[Qt.InputMethodQueries, Qt.InputMethodQuery])\nQInputMethodQueryEvent(QInputMethodQueryEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def queries(cls, self):
        'queries(self) -> Qt.InputMethodQueries'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setValue(cls, self, QtInputMethodQuery, Any):
        'setValue(self, Qt.InputMethodQuery, Any)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def value(cls, self, QtInputMethodQuery):
        'value(self, Qt.InputMethodQuery) -> Any'
        pass
    

class QIntValidator(QValidator):
    'QIntValidator(parent: QObject = None)\nQIntValidator(int, int, parent: QObject = None)'
    __class__ = QIntValidator
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, int, int_, parent: QObject=None):
        'QIntValidator(parent: QObject = None)\nQIntValidator(int, int, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def bottom(cls, self):
        'bottom(self) -> int'
        return 1
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fixup(cls, self, str):
        'fixup(self, str) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBottom(cls, self, int):
        'setBottom(self, int)'
        pass
    
    @classmethod
    def setLocale(cls, self, QLocale):
        'setLocale(self, QLocale)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRange(cls, self, int, int_):
        'setRange(self, int, int)'
        pass
    
    @classmethod
    def setTop(cls, self, int):
        'setTop(self, int)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def top(cls, self):
        'top(self) -> int'
        return 1
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def validate(cls, self, str, int):
        'validate(self, str, int) -> Tuple[QValidator.State, str, int]'
        pass
    

class QKeyEvent(QInputEvent):
    "QKeyEvent(QEvent.Type, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int, int, int, text: str = '', autorep: bool = False, count: int = 1)\nQKeyEvent(QEvent.Type, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], text: str = '', autorep: bool = False, count: int = 1)\nQKeyEvent(QKeyEvent)"
    __class__ = QKeyEvent
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QEventType, int, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, int_=None, int_1=None, int_2=None, text: str='', autorep: bool=False, count: int=1):
        "QKeyEvent(QEvent.Type, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int, int, int, text: str = '', autorep: bool = False, count: int = 1)\nQKeyEvent(QEvent.Type, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], text: str = '', autorep: bool = False, count: int = 1)\nQKeyEvent(QKeyEvent)"
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def count(cls, self):
        'count(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def isAutoRepeat(cls, self):
        'isAutoRepeat(self) -> bool'
        return True
    
    @classmethod
    def key(cls, self):
        'key(self) -> int'
        return 1
    
    @classmethod
    def matches(cls, self, QKeySequenceStandardKey):
        'matches(self, QKeySequence.StandardKey) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def nativeModifiers(cls, self):
        'nativeModifiers(self) -> int'
        return 1
    
    @classmethod
    def nativeScanCode(cls, self):
        'nativeScanCode(self) -> int'
        return 1
    
    @classmethod
    def nativeVirtualKey(cls, self):
        'nativeVirtualKey(self) -> int'
        return 1
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QKeySequence(_mod_sip.simplewrapper):
    'QKeySequence()\nQKeySequence(Union[QKeySequence, QKeySequence.StandardKey, str, int])\nQKeySequence(str, format: QKeySequence.SequenceFormat = QKeySequence.NativeText)\nQKeySequence(int, key2: int = 0, key3: int = 0, key4: int = 0)\nQKeySequence(Any)'
    AddTab = StandardKey()
    Back = StandardKey()
    Backspace = StandardKey()
    Bold = StandardKey()
    Cancel = StandardKey()
    Close = StandardKey()
    Copy = StandardKey()
    Cut = StandardKey()
    Delete = StandardKey()
    DeleteCompleteLine = StandardKey()
    DeleteEndOfLine = StandardKey()
    DeleteEndOfWord = StandardKey()
    DeleteStartOfWord = StandardKey()
    Deselect = StandardKey()
    ExactMatch = SequenceMatch()
    Find = StandardKey()
    FindNext = StandardKey()
    FindPrevious = StandardKey()
    Forward = StandardKey()
    FullScreen = StandardKey()
    HelpContents = StandardKey()
    InsertLineSeparator = StandardKey()
    InsertParagraphSeparator = StandardKey()
    Italic = StandardKey()
    MoveToEndOfBlock = StandardKey()
    MoveToEndOfDocument = StandardKey()
    MoveToEndOfLine = StandardKey()
    MoveToNextChar = StandardKey()
    MoveToNextLine = StandardKey()
    MoveToNextPage = StandardKey()
    MoveToNextWord = StandardKey()
    MoveToPreviousChar = StandardKey()
    MoveToPreviousLine = StandardKey()
    MoveToPreviousPage = StandardKey()
    MoveToPreviousWord = StandardKey()
    MoveToStartOfBlock = StandardKey()
    MoveToStartOfDocument = StandardKey()
    MoveToStartOfLine = StandardKey()
    NativeText = SequenceFormat()
    New = StandardKey()
    NextChild = StandardKey()
    NoMatch = SequenceMatch()
    Open = StandardKey()
    PartialMatch = SequenceMatch()
    Paste = StandardKey()
    PortableText = SequenceFormat()
    Preferences = StandardKey()
    PreviousChild = StandardKey()
    Print = StandardKey()
    Quit = StandardKey()
    Redo = StandardKey()
    Refresh = StandardKey()
    Replace = StandardKey()
    Save = StandardKey()
    SaveAs = StandardKey()
    SelectAll = StandardKey()
    SelectEndOfBlock = StandardKey()
    SelectEndOfDocument = StandardKey()
    SelectEndOfLine = StandardKey()
    SelectNextChar = StandardKey()
    SelectNextLine = StandardKey()
    SelectNextPage = StandardKey()
    SelectNextWord = StandardKey()
    SelectPreviousChar = StandardKey()
    SelectPreviousLine = StandardKey()
    SelectPreviousPage = StandardKey()
    SelectPreviousWord = StandardKey()
    SelectStartOfBlock = StandardKey()
    SelectStartOfDocument = StandardKey()
    SelectStartOfLine = StandardKey()
    SequenceFormat = SequenceFormat()
    SequenceMatch = SequenceMatch()
    StandardKey = StandardKey()
    Underline = StandardKey()
    Undo = StandardKey()
    UnknownKey = StandardKey()
    WhatsThis = StandardKey()
    ZoomIn = StandardKey()
    ZoomOut = StandardKey()
    __class__ = QKeySequence
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    def __hash__(self):
        'Return hash(self).'
        return 0
    
    def __init__(self, str, format: QKeySequence.SequenceFormat=QKeySequence.NativeText):
        'QKeySequence()\nQKeySequence(Union[QKeySequence, QKeySequence.StandardKey, str, int])\nQKeySequence(str, format: QKeySequence.SequenceFormat = QKeySequence.NativeText)\nQKeySequence(int, key2: int = 0, key3: int = 0, key4: int = 0)\nQKeySequence(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def count(cls, self):
        'count(self) -> int'
        return 1
    
    @classmethod
    def fromString(cls, str, format: QKeySequence.SequenceFormat=QKeySequence.PortableText):
        'fromString(str, format: QKeySequence.SequenceFormat = QKeySequence.PortableText) -> QKeySequence'
        pass
    
    @classmethod
    def isDetached(cls, self):
        'isDetached(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def keyBindings(cls, QKeySequenceStandardKey):
        'keyBindings(QKeySequence.StandardKey) -> object'
        pass
    
    @classmethod
    def listFromString(cls, str, format: QKeySequence.SequenceFormat=QKeySequence.PortableText):
        'listFromString(str, format: QKeySequence.SequenceFormat = QKeySequence.PortableText) -> List[QKeySequence]'
        pass
    
    @classmethod
    def listToString(cls, IterableUnionQKeySequence=None, QKeySequenceStandardKey=None, str=None, int=None, format: QKeySequence.SequenceFormat=QKeySequence.PortableText):
        'listToString(Iterable[Union[QKeySequence, QKeySequence.StandardKey, str, int]], format: QKeySequence.SequenceFormat = QKeySequence.PortableText) -> str'
        return ''
    
    @classmethod
    def matches(cls, self, UnionQKeySequence=None, QKeySequenceStandardKey=None, str=None, int=None):
        'matches(self, Union[QKeySequence, QKeySequence.StandardKey, str, int]) -> QKeySequence.SequenceMatch'
        pass
    
    @classmethod
    def mnemonic(cls, str):
        'mnemonic(str) -> QKeySequence'
        pass
    
    @classmethod
    def swap(cls, self, QKeySequence):
        'swap(self, QKeySequence)'
        pass
    
    @classmethod
    def toString(cls, self, format: QKeySequence.SequenceFormat=QKeySequence.PortableText):
        'toString(self, format: QKeySequence.SequenceFormat = QKeySequence.PortableText) -> str'
        return ''
    

class QLinearGradient(QGradient):
    'QLinearGradient()\nQLinearGradient(Union[QPointF, QPoint], Union[QPointF, QPoint])\nQLinearGradient(float, float, float, float)\nQLinearGradient(QLinearGradient)'
    __class__ = QLinearGradient
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None):
        'QLinearGradient()\nQLinearGradient(Union[QPointF, QPoint], Union[QPointF, QPoint])\nQLinearGradient(float, float, float, float)\nQLinearGradient(QLinearGradient)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def coordinateMode(cls, self):
        'coordinateMode(self) -> QGradient.CoordinateMode'
        pass
    
    @classmethod
    def finalStop(cls, self):
        'finalStop(self) -> QPointF'
        pass
    
    @classmethod
    def setColorAt(cls, self, float, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColorAt(self, float, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCoordinateMode(cls, self, QGradientCoordinateMode):
        'setCoordinateMode(self, QGradient.CoordinateMode)'
        pass
    
    @classmethod
    def setFinalStop(cls, self, UnionQPointF=None, QPoint=None):
        'setFinalStop(self, Union[QPointF, QPoint])\nsetFinalStop(self, float, float)'
        pass
    
    @classmethod
    def setSpread(cls, self, QGradientSpread):
        'setSpread(self, QGradient.Spread)'
        pass
    
    @classmethod
    def setStart(cls, self, UnionQPointF=None, QPoint=None):
        'setStart(self, Union[QPointF, QPoint])\nsetStart(self, float, float)'
        pass
    
    @classmethod
    def setStops(cls, self, object):
        'setStops(self, object)'
        pass
    
    @classmethod
    def spread(cls, self):
        'spread(self) -> QGradient.Spread'
        pass
    
    @classmethod
    def start(cls, self):
        'start(self) -> QPointF'
        pass
    
    @classmethod
    def stops(cls, self):
        'stops(self) -> object'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QGradient.Type'
        pass
    

class QMatrix2x2(_mod_sip.simplewrapper):
    'QMatrix2x2()\nQMatrix2x2(QMatrix2x2)\nQMatrix2x2(Sequence[float])'
    __class__ = QMatrix2x2
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix2x2()\nQMatrix2x2(QMatrix2x2)\nQMatrix2x2(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix2x2'
        pass
    

class QMatrix2x3(_mod_sip.simplewrapper):
    'QMatrix2x3()\nQMatrix2x3(QMatrix2x3)\nQMatrix2x3(Sequence[float])'
    __class__ = QMatrix2x3
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix2x3()\nQMatrix2x3(QMatrix2x3)\nQMatrix2x3(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix3x2'
        pass
    

class QMatrix2x4(_mod_sip.simplewrapper):
    'QMatrix2x4()\nQMatrix2x4(QMatrix2x4)\nQMatrix2x4(Sequence[float])'
    __class__ = QMatrix2x4
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix2x4()\nQMatrix2x4(QMatrix2x4)\nQMatrix2x4(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix4x2'
        pass
    

class QMatrix3x2(_mod_sip.simplewrapper):
    'QMatrix3x2()\nQMatrix3x2(QMatrix3x2)\nQMatrix3x2(Sequence[float])'
    __class__ = QMatrix3x2
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix3x2()\nQMatrix3x2(QMatrix3x2)\nQMatrix3x2(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix2x3'
        pass
    

class QMatrix3x3(_mod_sip.simplewrapper):
    'QMatrix3x3()\nQMatrix3x3(QMatrix3x3)\nQMatrix3x3(Sequence[float])'
    __class__ = QMatrix3x3
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix3x3()\nQMatrix3x3(QMatrix3x3)\nQMatrix3x3(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix3x3'
        pass
    

class QMatrix3x4(_mod_sip.simplewrapper):
    'QMatrix3x4()\nQMatrix3x4(QMatrix3x4)\nQMatrix3x4(Sequence[float])'
    __class__ = QMatrix3x4
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix3x4()\nQMatrix3x4(QMatrix3x4)\nQMatrix3x4(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix4x3'
        pass
    

class QMatrix4x2(_mod_sip.simplewrapper):
    'QMatrix4x2()\nQMatrix4x2(QMatrix4x2)\nQMatrix4x2(Sequence[float])'
    __class__ = QMatrix4x2
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix4x2()\nQMatrix4x2(QMatrix4x2)\nQMatrix4x2(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix2x4'
        pass
    

class QMatrix4x3(_mod_sip.simplewrapper):
    'QMatrix4x3()\nQMatrix4x3(QMatrix4x3)\nQMatrix4x3(Sequence[float])'
    __class__ = QMatrix4x3
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, Sequencefloat=None):
        'QMatrix4x3()\nQMatrix4x3(QMatrix4x3)\nQMatrix4x3(Sequence[float])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix3x4'
        pass
    

class QMatrix4x4(_mod_sip.simplewrapper):
    'QMatrix4x4()\nQMatrix4x4(Sequence[float])\nQMatrix4x4(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float)\nQMatrix4x4(QTransform)\nQMatrix4x4(QMatrix4x4)'
    def __add__(self, value):
        'Return self+value.'
        return QMatrix4x4()
    
    __class__ = QMatrix4x4
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imatmul__(self, value):
        'Return self@=value.'
        pass
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, float, float_, float_1, float_2, float_3, float_4, float_5, float_6, float_7, float_8, float_9, float_10, float_11, float_12, float_13, float_14):
        'QMatrix4x4()\nQMatrix4x4(Sequence[float])\nQMatrix4x4(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float)\nQMatrix4x4(QTransform)\nQMatrix4x4(QMatrix4x4)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    def __matmul__(self, value):
        'Return self@value.'
        pass
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QMatrix4x4()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __neg__(self):
        '-self'
        return QMatrix4x4()
    
    def __radd__(self, value):
        'Return value+self.'
        return QMatrix4x4()
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __rmatmul__(self, value):
        'Return value@self.'
        pass
    
    def __rmul__(self, value):
        'Return value*self.'
        return QMatrix4x4()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QMatrix4x4()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QMatrix4x4()
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    def __sub__(self, value):
        'Return self-value.'
        return QMatrix4x4()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def column(cls, self, int):
        'column(self, int) -> QVector4D'
        pass
    
    @classmethod
    def copyDataTo(cls, self):
        'copyDataTo(self) -> List[float]'
        pass
    
    @classmethod
    def data(cls, self):
        'data(self) -> List[float]'
        pass
    
    @classmethod
    def determinant(cls, self):
        'determinant(self) -> float'
        return 1.0
    
    @classmethod
    def fill(cls, self, float):
        'fill(self, float)'
        pass
    
    @classmethod
    def frustum(cls, self, float, float_, float_1, float_2, float_3, float_4):
        'frustum(self, float, float, float, float, float, float)'
        pass
    
    @classmethod
    def inverted(cls, self):
        'inverted(self) -> Tuple[QMatrix4x4, bool]'
        pass
    
    @classmethod
    def isAffine(cls, self):
        'isAffine(self) -> bool'
        return True
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def lookAt(cls, self, QVector3D, QVector3D_, QVector3D_1):
        'lookAt(self, QVector3D, QVector3D, QVector3D)'
        pass
    
    @classmethod
    def map(cls, self, UnionQPointF=None, QPoint=None):
        'map(self, QPoint) -> QPoint\nmap(self, Union[QPointF, QPoint]) -> QPointF\nmap(self, QVector3D) -> QVector3D\nmap(self, QVector4D) -> QVector4D'
        pass
    
    @classmethod
    def mapRect(cls, self, QRectF):
        'mapRect(self, QRect) -> QRect\nmapRect(self, QRectF) -> QRectF'
        pass
    
    @classmethod
    def mapVector(cls, self, QVector3D):
        'mapVector(self, QVector3D) -> QVector3D'
        pass
    
    @classmethod
    def normalMatrix(cls, self):
        'normalMatrix(self) -> QMatrix3x3'
        pass
    
    @classmethod
    def optimize(cls, self):
        'optimize(self)'
        pass
    
    @classmethod
    def ortho(cls, self, float, float_, float_1, float_2, float_3, float_4):
        'ortho(self, QRect)\northo(self, QRectF)\northo(self, float, float, float, float, float, float)'
        pass
    
    @classmethod
    def perspective(cls, self, float, float_, float_1, float_2):
        'perspective(self, float, float, float, float)'
        pass
    
    @classmethod
    def rotate(cls, self, float, float_, float_1, z: float=0):
        'rotate(self, float, QVector3D)\nrotate(self, float, float, float, z: float = 0)\nrotate(self, QQuaternion)'
        pass
    
    @classmethod
    def row(cls, self, int):
        'row(self, int) -> QVector4D'
        pass
    
    @classmethod
    def scale(cls, self, float, float_, float_1):
        'scale(self, QVector3D)\nscale(self, float, float)\nscale(self, float, float, float)\nscale(self, float)'
        pass
    
    @classmethod
    def setColumn(cls, self, int, QVector4D):
        'setColumn(self, int, QVector4D)'
        pass
    
    @classmethod
    def setRow(cls, self, int, QVector4D):
        'setRow(self, int, QVector4D)'
        pass
    
    @classmethod
    def setToIdentity(cls, self):
        'setToIdentity(self)'
        pass
    
    @classmethod
    def toTransform(cls, self, float):
        'toTransform(self) -> QTransform\ntoTransform(self, float) -> QTransform'
        pass
    
    @classmethod
    def translate(cls, self, float, float_, float_1):
        'translate(self, QVector3D)\ntranslate(self, float, float)\ntranslate(self, float, float, float)'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QMatrix4x4'
        pass
    
    @classmethod
    def viewport(cls, self, float, float_, float_1, float_2, nearPlane: float=0, farPlane: float=1):
        'viewport(self, float, float, float, float, nearPlane: float = 0, farPlane: float = 1)\nviewport(self, QRectF)'
        pass
    

class QMouseEvent(QInputEvent):
    'QMouseEvent(QEvent.Type, Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.MouseEventSource)\nQMouseEvent(QMouseEvent)'
    __class__ = QMouseEvent
    __dict__ = {}
    def __init__(self, QEventType, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, UnionQPointF_1=None, QPoint_1=None, QtMouseButton=None, UnionQtMouseButtons=None, QtMouseButton_=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, QtMouseEventSource=None):
        'QMouseEvent(QEvent.Type, Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQMouseEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.MouseEventSource)\nQMouseEvent(QMouseEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def button(cls, self):
        'button(self) -> Qt.MouseButton'
        pass
    
    @classmethod
    def buttons(cls, self):
        'buttons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.MouseEventFlags'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def localPos(cls, self):
        'localPos(self) -> QPointF'
        pass
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def screenPos(cls, self):
        'screenPos(self) -> QPointF'
        pass
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> Qt.MouseEventSource'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def windowPos(cls, self):
        'windowPos(self) -> QPointF'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QMoveEvent(_mod_PyQt5_QtCore.QEvent):
    'QMoveEvent(QPoint, QPoint)\nQMoveEvent(QMoveEvent)'
    __class__ = QMoveEvent
    __dict__ = {}
    def __init__(self, QPoint, QPoint_):
        'QMoveEvent(QPoint, QPoint)\nQMoveEvent(QMoveEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def oldPos(cls, self):
        'oldPos(self) -> QPoint'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QMovie(_mod_PyQt5_QtCore.QObject):
    'QMovie(parent: QObject = None)\nQMovie(QIODevice, format: Union[QByteArray, bytes, bytearray] = QByteArray(), parent: QObject = None)\nQMovie(str, format: Union[QByteArray, bytes, bytearray] = QByteArray(), parent: QObject = None)'
    CacheAll = CacheMode()
    CacheMode = CacheMode()
    CacheNone = CacheMode()
    MovieState = MovieState()
    NotRunning = MovieState()
    Paused = MovieState()
    Running = MovieState()
    __class__ = QMovie
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QIODevice, format: Union[QByteArray,bytes,bytearray]=QByteArray(), parent: QObject=None):
        'QMovie(parent: QObject = None)\nQMovie(QIODevice, format: Union[QByteArray, bytes, bytearray] = QByteArray(), parent: QObject = None)\nQMovie(str, format: Union[QByteArray, bytes, bytearray] = QByteArray(), parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def backgroundColor(cls, self):
        'backgroundColor(self) -> QColor'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def cacheMode(cls, self):
        'cacheMode(self) -> QMovie.CacheMode'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def currentFrameNumber(cls, self):
        'currentFrameNumber(self) -> int'
        return 1
    
    @classmethod
    def currentImage(cls, self):
        'currentImage(self) -> QImage'
        pass
    
    @classmethod
    def currentPixmap(cls, self):
        'currentPixmap(self) -> QPixmap'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QIODevice'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    def error(self, QImageReaderImageReaderError):
        'error(self, QImageReader.ImageReaderError) [signal]'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def fileName(cls, self):
        'fileName(self) -> str'
        return ''
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    def finished(self):
        'finished(self) [signal]'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QByteArray'
        pass
    
    def frameChanged(self, int):
        'frameChanged(self, int) [signal]'
        pass
    
    @classmethod
    def frameCount(cls, self):
        'frameCount(self) -> int'
        return 1
    
    @classmethod
    def frameRect(cls, self):
        'frameRect(self) -> QRect'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def jumpToFrame(cls, self, int):
        'jumpToFrame(self, int) -> bool'
        return True
    
    @classmethod
    def jumpToNextFrame(cls, self):
        'jumpToNextFrame(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def loopCount(cls, self):
        'loopCount(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def nextFrameDelay(cls, self):
        'nextFrameDelay(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    def resized(self, QSize):
        'resized(self, QSize) [signal]'
        pass
    
    @classmethod
    def scaledSize(cls, self):
        'scaledSize(self) -> QSize'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBackgroundColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setBackgroundColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCacheMode(cls, self, QMovieCacheMode):
        'setCacheMode(self, QMovie.CacheMode)'
        pass
    
    @classmethod
    def setDevice(cls, self, QIODevice):
        'setDevice(self, QIODevice)'
        pass
    
    @classmethod
    def setFileName(cls, self, str):
        'setFileName(self, str)'
        pass
    
    @classmethod
    def setFormat(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setFormat(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setPaused(cls, self, bool):
        'setPaused(self, bool)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScaledSize(cls, self, QSize):
        'setScaledSize(self, QSize)'
        pass
    
    @classmethod
    def setSpeed(cls, self, int):
        'setSpeed(self, int)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def speed(cls, self):
        'speed(self) -> int'
        return 1
    
    @classmethod
    def start(cls, self):
        'start(self)'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    def started(self):
        'started(self) [signal]'
        pass
    
    @classmethod
    def state(cls, self):
        'state(self) -> QMovie.MovieState'
        pass
    
    def stateChanged(self, QMovieMovieState):
        'stateChanged(self, QMovie.MovieState) [signal]'
        pass
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def stop(cls, self):
        'stop(self)'
        pass
    
    @classmethod
    def supportedFormats(cls):
        'supportedFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    def updated(self, QRect):
        'updated(self, QRect) [signal]'
        pass
    

class QNativeGestureEvent(QInputEvent):
    'QNativeGestureEvent(Qt.NativeGestureType, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], float, int, int)\nQNativeGestureEvent(QNativeGestureEvent)'
    __class__ = QNativeGestureEvent
    __dict__ = {}
    def __init__(self, QtNativeGestureType, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, UnionQPointF_1=None, QPoint_1=None, float=None, int=None, int_=None):
        'QNativeGestureEvent(Qt.NativeGestureType, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint], float, int, int)\nQNativeGestureEvent(QNativeGestureEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def gestureType(cls, self):
        'gestureType(self) -> Qt.NativeGestureType'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def localPos(cls, self):
        'localPos(self) -> QPointF'
        pass
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def screenPos(cls, self):
        'screenPos(self) -> QPointF'
        pass
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def value(cls, self):
        'value(self) -> float'
        return 1.0
    
    @classmethod
    def windowPos(cls, self):
        'windowPos(self) -> QPointF'
        pass
    

class QOffscreenSurface(_mod_PyQt5_QtCore.QObject,QSurface):
    'QOffscreenSurface(screen: QScreen = None)'
    __class__ = QOffscreenSurface
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, screen: QScreen=None):
        'QOffscreenSurface(screen: QScreen = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def nativeHandle(cls, self):
        'nativeHandle(self) -> sip.voidptr'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def requestedFormat(cls, self):
        'requestedFormat(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    def screenChanged(self, QScreen):
        'screenChanged(self, QScreen) [signal]'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setNativeHandle(cls, self, sipvoidptr):
        'setNativeHandle(self, sip.voidptr)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QOpenGLBuffer(_mod_sip.simplewrapper):
    'QOpenGLBuffer()\nQOpenGLBuffer(QOpenGLBuffer.Type)\nQOpenGLBuffer(QOpenGLBuffer)'
    Access = Access()
    DynamicCopy = UsagePattern()
    DynamicDraw = UsagePattern()
    DynamicRead = UsagePattern()
    IndexBuffer = Type()
    PixelPackBuffer = Type()
    PixelUnpackBuffer = Type()
    RangeAccessFlag = RangeAccessFlag()
    RangeAccessFlags = RangeAccessFlags()
    RangeFlushExplicit = RangeAccessFlag()
    RangeInvalidate = RangeAccessFlag()
    RangeInvalidateBuffer = RangeAccessFlag()
    RangeRead = RangeAccessFlag()
    RangeUnsynchronized = RangeAccessFlag()
    RangeWrite = RangeAccessFlag()
    ReadOnly = Access()
    ReadWrite = Access()
    StaticCopy = UsagePattern()
    StaticDraw = UsagePattern()
    StaticRead = UsagePattern()
    StreamCopy = UsagePattern()
    StreamDraw = UsagePattern()
    StreamRead = UsagePattern()
    Type = Type()
    UsagePattern = UsagePattern()
    VertexBuffer = Type()
    WriteOnly = Access()
    __class__ = QOpenGLBuffer
    __dict__ = {}
    def __init__(self, QOpenGLBufferType):
        'QOpenGLBuffer()\nQOpenGLBuffer(QOpenGLBuffer.Type)\nQOpenGLBuffer(QOpenGLBuffer)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def allocate(cls, self, sipvoidptr, int):
        'allocate(self, sip.voidptr, int)\nallocate(self, int)'
        pass
    
    @classmethod
    def bind(cls, self):
        'bind(self) -> bool'
        return True
    
    @classmethod
    def bufferId(cls, self):
        'bufferId(self) -> int'
        return 1
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def map(cls, self, QOpenGLBufferAccess):
        'map(self, QOpenGLBuffer.Access) -> sip.voidptr'
        pass
    
    @classmethod
    def mapRange(cls, self, int, int_, UnionQOpenGLBufferRangeAccessFlags=None, QOpenGLBufferRangeAccessFlag=None):
        'mapRange(self, int, int, Union[QOpenGLBuffer.RangeAccessFlags, QOpenGLBuffer.RangeAccessFlag]) -> sip.voidptr'
        pass
    
    @classmethod
    def read(cls, self, int, sipvoidptr, int_):
        'read(self, int, sip.voidptr, int) -> bool'
        return True
    
    @classmethod
    def release(cls, QOpenGLBufferType):
        'release(self)\nrelease(QOpenGLBuffer.Type)'
        pass
    
    @classmethod
    def setUsagePattern(cls, self, QOpenGLBufferUsagePattern):
        'setUsagePattern(self, QOpenGLBuffer.UsagePattern)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QOpenGLBuffer.Type'
        pass
    
    @classmethod
    def unmap(cls, self):
        'unmap(self) -> bool'
        return True
    
    @classmethod
    def usagePattern(cls, self):
        'usagePattern(self) -> QOpenGLBuffer.UsagePattern'
        pass
    
    @classmethod
    def write(cls, self, int, sipvoidptr, int_):
        'write(self, int, sip.voidptr, int)'
        pass
    

class QOpenGLContext(_mod_PyQt5_QtCore.QObject):
    'QOpenGLContext(parent: QObject = None)'
    LibGL = OpenGLModuleType()
    LibGLES = OpenGLModuleType()
    OpenGLModuleType = OpenGLModuleType()
    __class__ = QOpenGLContext
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLContext(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def aboutToBeDestroyed(self):
        'aboutToBeDestroyed(self) [signal]'
        pass
    
    @classmethod
    def areSharing(cls, QOpenGLContext, QOpenGLContext_):
        'areSharing(QOpenGLContext, QOpenGLContext) -> bool'
        return True
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def currentContext(cls):
        'currentContext() -> QOpenGLContext'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def defaultFramebufferObject(cls, self):
        'defaultFramebufferObject(self) -> int'
        return 1
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def doneCurrent(cls, self):
        'doneCurrent(self)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def extensions(cls, self):
        'extensions(self) -> object'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def globalShareContext(cls):
        'globalShareContext() -> QOpenGLContext'
        pass
    
    @classmethod
    def hasExtension(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'hasExtension(self, Union[QByteArray, bytes, bytearray]) -> bool'
        return True
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isOpenGLES(cls, self):
        'isOpenGLES(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def makeCurrent(cls, self, QSurface):
        'makeCurrent(self, QSurface) -> bool'
        return True
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def nativeHandle(cls, self):
        'nativeHandle(self) -> Any'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def openGLModuleHandle(cls):
        'openGLModuleHandle() -> sip.voidptr'
        pass
    
    @classmethod
    def openGLModuleType(cls):
        'openGLModuleType() -> QOpenGLContext.OpenGLModuleType'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setNativeHandle(cls, self, Any):
        'setNativeHandle(self, Any)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def setShareContext(cls, self, QOpenGLContext):
        'setShareContext(self, QOpenGLContext)'
        pass
    
    @classmethod
    def shareContext(cls, self):
        'shareContext(self) -> QOpenGLContext'
        pass
    
    @classmethod
    def shareGroup(cls, self):
        'shareGroup(self) -> QOpenGLContextGroup'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsThreadedOpenGL(cls):
        'supportsThreadedOpenGL() -> bool'
        return True
    
    @classmethod
    def surface(cls, self):
        'surface(self) -> QSurface'
        pass
    
    @classmethod
    def swapBuffers(cls, self, QSurface):
        'swapBuffers(self, QSurface)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def versionFunctions(cls, self, versionProfile: QOpenGLVersionProfile=None):
        'versionFunctions(self, versionProfile: QOpenGLVersionProfile = None) -> object'
        pass
    

class QOpenGLContextGroup(_mod_PyQt5_QtCore.QObject):
    __class__ = QOpenGLContextGroup
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def currentContextGroup(cls):
        'currentContextGroup() -> QOpenGLContextGroup'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def shares(cls, self):
        'shares(self) -> object'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QOpenGLDebugLogger(_mod_PyQt5_QtCore.QObject):
    'QOpenGLDebugLogger(parent: QObject = None)'
    AsynchronousLogging = LoggingMode()
    LoggingMode = LoggingMode()
    SynchronousLogging = LoggingMode()
    __class__ = QOpenGLDebugLogger
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLDebugLogger(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disableMessages(cls, self, sources: Union[QOpenGLDebugMessage.Sources,QOpenGLDebugMessage.Source]=QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types,QOpenGLDebugMessage.Type]=QOpenGLDebugMessage.AnyType, severities: Union[QOpenGLDebugMessage.Severities,QOpenGLDebugMessage.Severity]=QOpenGLDebugMessage.AnySeverity):
        'disableMessages(self, sources: Union[QOpenGLDebugMessage.Sources, QOpenGLDebugMessage.Source] = QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types, QOpenGLDebugMessage.Type] = QOpenGLDebugMessage.AnyType, severities: Union[QOpenGLDebugMessage.Severities, QOpenGLDebugMessage.Severity] = QOpenGLDebugMessage.AnySeverity)\ndisableMessages(self, Iterable[int], sources: Union[QOpenGLDebugMessage.Sources, QOpenGLDebugMessage.Source] = QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types, QOpenGLDebugMessage.Type] = QOpenGLDebugMessage.AnyType)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def enableMessages(cls, self, sources: Union[QOpenGLDebugMessage.Sources,QOpenGLDebugMessage.Source]=QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types,QOpenGLDebugMessage.Type]=QOpenGLDebugMessage.AnyType, severities: Union[QOpenGLDebugMessage.Severities,QOpenGLDebugMessage.Severity]=QOpenGLDebugMessage.AnySeverity):
        'enableMessages(self, sources: Union[QOpenGLDebugMessage.Sources, QOpenGLDebugMessage.Source] = QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types, QOpenGLDebugMessage.Type] = QOpenGLDebugMessage.AnyType, severities: Union[QOpenGLDebugMessage.Severities, QOpenGLDebugMessage.Severity] = QOpenGLDebugMessage.AnySeverity)\nenableMessages(self, Iterable[int], sources: Union[QOpenGLDebugMessage.Sources, QOpenGLDebugMessage.Source] = QOpenGLDebugMessage.AnySource, types: Union[QOpenGLDebugMessage.Types, QOpenGLDebugMessage.Type] = QOpenGLDebugMessage.AnyType)'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def initialize(cls, self):
        'initialize(self) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isLogging(cls, self):
        'isLogging(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logMessage(cls, self, QOpenGLDebugMessage):
        'logMessage(self, QOpenGLDebugMessage)'
        pass
    
    @classmethod
    def loggedMessages(cls, self):
        'loggedMessages(self) -> object'
        pass
    
    @classmethod
    def loggingMode(cls, self):
        'loggingMode(self) -> QOpenGLDebugLogger.LoggingMode'
        pass
    
    @classmethod
    def maximumMessageLength(cls, self):
        'maximumMessageLength(self) -> int'
        return 1
    
    def messageLogged(self, QOpenGLDebugMessage):
        'messageLogged(self, QOpenGLDebugMessage) [signal]'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def popGroup(cls, self):
        'popGroup(self)'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pushGroup(cls, self, str, id: int=0, source: QOpenGLDebugMessage.Source=QOpenGLDebugMessage.ApplicationSource):
        'pushGroup(self, str, id: int = 0, source: QOpenGLDebugMessage.Source = QOpenGLDebugMessage.ApplicationSource)'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startLogging(cls, self, loggingMode: QOpenGLDebugLogger.LoggingMode=QOpenGLDebugLogger.AsynchronousLogging):
        'startLogging(self, loggingMode: QOpenGLDebugLogger.LoggingMode = QOpenGLDebugLogger.AsynchronousLogging)'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def stopLogging(cls, self):
        'stopLogging(self)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QOpenGLDebugMessage(_mod_sip.simplewrapper):
    'QOpenGLDebugMessage()\nQOpenGLDebugMessage(QOpenGLDebugMessage)'
    APISource = Source()
    AnySeverity = Severity()
    AnySource = Source()
    AnyType = Type()
    ApplicationSource = Source()
    DeprecatedBehaviorType = Type()
    ErrorType = Type()
    GroupPopType = Type()
    GroupPushType = Type()
    HighSeverity = Severity()
    InvalidSeverity = Severity()
    InvalidSource = Source()
    InvalidType = Type()
    LowSeverity = Severity()
    MarkerType = Type()
    MediumSeverity = Severity()
    NotificationSeverity = Severity()
    OtherSource = Source()
    OtherType = Type()
    PerformanceType = Type()
    PortabilityType = Type()
    Severities = Severities()
    Severity = Severity()
    ShaderCompilerSource = Source()
    Source = Source()
    Sources = Sources()
    ThirdPartySource = Source()
    Type = Type()
    Types = Types()
    UndefinedBehaviorType = Type()
    WindowSystemSource = Source()
    __class__ = QOpenGLDebugMessage
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QOpenGLDebugMessage):
        'QOpenGLDebugMessage()\nQOpenGLDebugMessage(QOpenGLDebugMessage)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def createApplicationMessage(cls, str, id: int=0, severity: QOpenGLDebugMessage.Severity=QOpenGLDebugMessage.NotificationSeverity, type: QOpenGLDebugMessage.Type=QOpenGLDebugMessage.OtherType):
        'createApplicationMessage(str, id: int = 0, severity: QOpenGLDebugMessage.Severity = QOpenGLDebugMessage.NotificationSeverity, type: QOpenGLDebugMessage.Type = QOpenGLDebugMessage.OtherType) -> QOpenGLDebugMessage'
        pass
    
    @classmethod
    def createThirdPartyMessage(cls, str, id: int=0, severity: QOpenGLDebugMessage.Severity=QOpenGLDebugMessage.NotificationSeverity, type: QOpenGLDebugMessage.Type=QOpenGLDebugMessage.OtherType):
        'createThirdPartyMessage(str, id: int = 0, severity: QOpenGLDebugMessage.Severity = QOpenGLDebugMessage.NotificationSeverity, type: QOpenGLDebugMessage.Type = QOpenGLDebugMessage.OtherType) -> QOpenGLDebugMessage'
        pass
    
    @classmethod
    def id(cls, self):
        'id(self) -> int'
        return 1
    
    @classmethod
    def message(cls, self):
        'message(self) -> str'
        return ''
    
    @classmethod
    def severity(cls, self):
        'severity(self) -> QOpenGLDebugMessage.Severity'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> QOpenGLDebugMessage.Source'
        pass
    
    @classmethod
    def swap(cls, self, QOpenGLDebugMessage):
        'swap(self, QOpenGLDebugMessage)'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QOpenGLDebugMessage.Type'
        pass
    

class QOpenGLFramebufferObject(_mod_sip.simplewrapper):
    'QOpenGLFramebufferObject(QSize, target: int = GL_TEXTURE_2D)\nQOpenGLFramebufferObject(int, int, target: int = GL_TEXTURE_2D)\nQOpenGLFramebufferObject(QSize, QOpenGLFramebufferObject.Attachment, target: int = GL_TEXTURE_2D, internal_format: int = GL_RGBA8)\nQOpenGLFramebufferObject(int, int, QOpenGLFramebufferObject.Attachment, target: int = GL_TEXTURE_2D, internal_format: int = GL_RGBA8)\nQOpenGLFramebufferObject(QSize, QOpenGLFramebufferObjectFormat)\nQOpenGLFramebufferObject(int, int, QOpenGLFramebufferObjectFormat)'
    Attachment = Attachment()
    CombinedDepthStencil = Attachment()
    Depth = Attachment()
    DontRestoreFramebufferBinding = FramebufferRestorePolicy()
    FramebufferRestorePolicy = FramebufferRestorePolicy()
    NoAttachment = Attachment()
    RestoreFrameBufferBinding = FramebufferRestorePolicy()
    RestoreFramebufferBindingToDefault = FramebufferRestorePolicy()
    __class__ = QOpenGLFramebufferObject
    __dict__ = {}
    def __init__(self, int, int_, QOpenGLFramebufferObjectAttachment, target: int=GL_TEXTURE_2D, internal_format: int=GL_RGBA8):
        'QOpenGLFramebufferObject(QSize, target: int = GL_TEXTURE_2D)\nQOpenGLFramebufferObject(int, int, target: int = GL_TEXTURE_2D)\nQOpenGLFramebufferObject(QSize, QOpenGLFramebufferObject.Attachment, target: int = GL_TEXTURE_2D, internal_format: int = GL_RGBA8)\nQOpenGLFramebufferObject(int, int, QOpenGLFramebufferObject.Attachment, target: int = GL_TEXTURE_2D, internal_format: int = GL_RGBA8)\nQOpenGLFramebufferObject(QSize, QOpenGLFramebufferObjectFormat)\nQOpenGLFramebufferObject(int, int, QOpenGLFramebufferObjectFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def addColorAttachment(cls, self, int, int_, internal_format: int=0):
        'addColorAttachment(self, QSize, internal_format: int = 0)\naddColorAttachment(self, int, int, internal_format: int = 0)'
        pass
    
    @classmethod
    def attachment(cls, self):
        'attachment(self) -> QOpenGLFramebufferObject.Attachment'
        pass
    
    @classmethod
    def bind(cls, self):
        'bind(self) -> bool'
        return True
    
    @classmethod
    def bindDefault(cls):
        'bindDefault() -> bool'
        return True
    
    @classmethod
    def blitFramebuffer(cls, QOpenGLFramebufferObject, QRect, QOpenGLFramebufferObject_, QRect_, int, int_, int_1, int_2, QOpenGLFramebufferObjectFramebufferRestorePolicy):
        'blitFramebuffer(QOpenGLFramebufferObject, QRect, QOpenGLFramebufferObject, QRect, buffers: int = GL_COLOR_BUFFER_BIT, filter: int = GL_NEAREST)\nblitFramebuffer(QOpenGLFramebufferObject, QOpenGLFramebufferObject, buffers: int = GL_COLOR_BUFFER_BIT, filter: int = GL_NEAREST)\nblitFramebuffer(QOpenGLFramebufferObject, QRect, QOpenGLFramebufferObject, QRect, int, int, int, int)\nblitFramebuffer(QOpenGLFramebufferObject, QRect, QOpenGLFramebufferObject, QRect, int, int, int, int, QOpenGLFramebufferObject.FramebufferRestorePolicy)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QOpenGLFramebufferObjectFormat'
        pass
    
    @classmethod
    def handle(cls, self):
        'handle(self) -> int'
        return 1
    
    @classmethod
    def hasOpenGLFramebufferBlit(cls):
        'hasOpenGLFramebufferBlit() -> bool'
        return True
    
    @classmethod
    def hasOpenGLFramebufferObjects(cls):
        'hasOpenGLFramebufferObjects() -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def isBound(cls, self):
        'isBound(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def release(cls, self):
        'release(self) -> bool'
        return True
    
    @classmethod
    def setAttachment(cls, self, QOpenGLFramebufferObjectAttachment):
        'setAttachment(self, QOpenGLFramebufferObject.Attachment)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def sizes(cls, self):
        'sizes(self) -> object'
        pass
    
    @classmethod
    def takeTexture(cls, self, int):
        'takeTexture(self) -> int\ntakeTexture(self, int) -> int'
        return 1
    
    @classmethod
    def texture(cls, self):
        'texture(self) -> int'
        return 1
    
    @classmethod
    def textures(cls, self):
        'textures(self) -> List[int]'
        pass
    
    @classmethod
    def toImage(cls, self, bool, int):
        'toImage(self) -> QImage\ntoImage(self, bool) -> QImage\ntoImage(self, bool, int) -> QImage'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    

class QOpenGLFramebufferObjectFormat(_mod_sip.simplewrapper):
    'QOpenGLFramebufferObjectFormat()\nQOpenGLFramebufferObjectFormat(QOpenGLFramebufferObjectFormat)'
    __class__ = QOpenGLFramebufferObjectFormat
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QOpenGLFramebufferObjectFormat):
        'QOpenGLFramebufferObjectFormat()\nQOpenGLFramebufferObjectFormat(QOpenGLFramebufferObjectFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def attachment(cls, self):
        'attachment(self) -> QOpenGLFramebufferObject.Attachment'
        pass
    
    @classmethod
    def internalTextureFormat(cls, self):
        'internalTextureFormat(self) -> int'
        return 1
    
    @classmethod
    def mipmap(cls, self):
        'mipmap(self) -> bool'
        return True
    
    @classmethod
    def samples(cls, self):
        'samples(self) -> int'
        return 1
    
    @classmethod
    def setAttachment(cls, self, QOpenGLFramebufferObjectAttachment):
        'setAttachment(self, QOpenGLFramebufferObject.Attachment)'
        pass
    
    @classmethod
    def setInternalTextureFormat(cls, self, int):
        'setInternalTextureFormat(self, int)'
        pass
    
    @classmethod
    def setMipmap(cls, self, bool):
        'setMipmap(self, bool)'
        pass
    
    @classmethod
    def setSamples(cls, self, int):
        'setSamples(self, int)'
        pass
    
    @classmethod
    def setTextureTarget(cls, self, int):
        'setTextureTarget(self, int)'
        pass
    
    @classmethod
    def textureTarget(cls, self):
        'textureTarget(self) -> int'
        return 1
    

class QOpenGLPaintDevice(QPaintDevice):
    'QOpenGLPaintDevice()\nQOpenGLPaintDevice(QSize)\nQOpenGLPaintDevice(int, int)'
    __class__ = QOpenGLPaintDevice
    __dict__ = {}
    def __init__(self, int, int_):
        'QOpenGLPaintDevice()\nQOpenGLPaintDevice(QSize)\nQOpenGLPaintDevice(int, int)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def context(cls, self):
        'context(self) -> QOpenGLContext'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def dotsPerMeterX(cls, self):
        'dotsPerMeterX(self) -> float'
        return 1.0
    
    @classmethod
    def dotsPerMeterY(cls, self):
        'dotsPerMeterY(self) -> float'
        return 1.0
    
    @classmethod
    def ensureActiveTarget(cls, self):
        'ensureActiveTarget(self)'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintFlipped(cls, self):
        'paintFlipped(self) -> bool'
        return True
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def setDevicePixelRatio(cls, self, float):
        'setDevicePixelRatio(self, float)'
        pass
    
    @classmethod
    def setDotsPerMeterX(cls, self, float):
        'setDotsPerMeterX(self, float)'
        pass
    
    @classmethod
    def setDotsPerMeterY(cls, self, float):
        'setDotsPerMeterY(self, float)'
        pass
    
    @classmethod
    def setPaintFlipped(cls, self, bool):
        'setPaintFlipped(self, bool)'
        pass
    
    @classmethod
    def setSize(cls, self, QSize):
        'setSize(self, QSize)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QOpenGLPixelTransferOptions(_mod_sip.simplewrapper):
    'QOpenGLPixelTransferOptions()\nQOpenGLPixelTransferOptions(QOpenGLPixelTransferOptions)'
    __class__ = QOpenGLPixelTransferOptions
    __dict__ = {}
    def __init__(self, QOpenGLPixelTransferOptions):
        'QOpenGLPixelTransferOptions()\nQOpenGLPixelTransferOptions(QOpenGLPixelTransferOptions)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alignment(cls, self):
        'alignment(self) -> int'
        return 1
    
    @classmethod
    def imageHeight(cls, self):
        'imageHeight(self) -> int'
        return 1
    
    @classmethod
    def isLeastSignificantBitFirst(cls, self):
        'isLeastSignificantBitFirst(self) -> bool'
        return True
    
    @classmethod
    def isSwapBytesEnabled(cls, self):
        'isSwapBytesEnabled(self) -> bool'
        return True
    
    @classmethod
    def rowLength(cls, self):
        'rowLength(self) -> int'
        return 1
    
    @classmethod
    def setAlignment(cls, self, int):
        'setAlignment(self, int)'
        pass
    
    @classmethod
    def setImageHeight(cls, self, int):
        'setImageHeight(self, int)'
        pass
    
    @classmethod
    def setLeastSignificantByteFirst(cls, self, bool):
        'setLeastSignificantByteFirst(self, bool)'
        pass
    
    @classmethod
    def setRowLength(cls, self, int):
        'setRowLength(self, int)'
        pass
    
    @classmethod
    def setSkipImages(cls, self, int):
        'setSkipImages(self, int)'
        pass
    
    @classmethod
    def setSkipPixels(cls, self, int):
        'setSkipPixels(self, int)'
        pass
    
    @classmethod
    def setSkipRows(cls, self, int):
        'setSkipRows(self, int)'
        pass
    
    @classmethod
    def setSwapBytesEnabled(cls, self, bool):
        'setSwapBytesEnabled(self, bool)'
        pass
    
    @classmethod
    def skipImages(cls, self):
        'skipImages(self) -> int'
        return 1
    
    @classmethod
    def skipPixels(cls, self):
        'skipPixels(self) -> int'
        return 1
    
    @classmethod
    def skipRows(cls, self):
        'skipRows(self) -> int'
        return 1
    
    @classmethod
    def swap(cls, self, QOpenGLPixelTransferOptions):
        'swap(self, QOpenGLPixelTransferOptions)'
        pass
    

class QOpenGLShader(_mod_PyQt5_QtCore.QObject):
    'QOpenGLShader(Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], parent: QObject = None)'
    Compute = ShaderTypeBit()
    Fragment = ShaderTypeBit()
    Geometry = ShaderTypeBit()
    ShaderType = ShaderType()
    ShaderTypeBit = ShaderTypeBit()
    TessellationControl = ShaderTypeBit()
    TessellationEvaluation = ShaderTypeBit()
    Vertex = ShaderTypeBit()
    __class__ = QOpenGLShader
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, parent: QObject=None):
        'QOpenGLShader(Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def compileSourceCode(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'compileSourceCode(self, Union[QByteArray, bytes, bytearray]) -> bool\ncompileSourceCode(self, str) -> bool'
        return True
    
    @classmethod
    def compileSourceFile(cls, self, str):
        'compileSourceFile(self, str) -> bool'
        return True
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def hasOpenGLShaders(cls, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, context: QOpenGLContext=None):
        'hasOpenGLShaders(Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], context: QOpenGLContext = None) -> bool'
        return True
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isCompiled(cls, self):
        'isCompiled(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def log(cls, self):
        'log(self) -> str'
        return ''
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def shaderId(cls, self):
        'shaderId(self) -> int'
        return 1
    
    @classmethod
    def shaderType(cls, self):
        'shaderType(self) -> QOpenGLShader.ShaderType'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def sourceCode(cls, self):
        'sourceCode(self) -> QByteArray'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QOpenGLShaderProgram(_mod_PyQt5_QtCore.QObject):
    'QOpenGLShaderProgram(parent: QObject = None)'
    __class__ = QOpenGLShaderProgram
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLShaderProgram(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def addCacheableShaderFromSourceCode(cls, self, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, UnionQByteArray=None, bytes=None, bytearray=None):
        'addCacheableShaderFromSourceCode(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], Union[QByteArray, bytes, bytearray]) -> bool\naddCacheableShaderFromSourceCode(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], str) -> bool'
        return True
    
    @classmethod
    def addCacheableShaderFromSourceFile(cls, self, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, str=None):
        'addCacheableShaderFromSourceFile(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], str) -> bool'
        return True
    
    @classmethod
    def addShader(cls, self, QOpenGLShader):
        'addShader(self, QOpenGLShader) -> bool'
        return True
    
    @classmethod
    def addShaderFromSourceCode(cls, self, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, UnionQByteArray=None, bytes=None, bytearray=None):
        'addShaderFromSourceCode(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], Union[QByteArray, bytes, bytearray]) -> bool\naddShaderFromSourceCode(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], str) -> bool'
        return True
    
    @classmethod
    def addShaderFromSourceFile(cls, self, UnionQOpenGLShaderShaderType=None, QOpenGLShaderShaderTypeBit=None, str=None):
        'addShaderFromSourceFile(self, Union[QOpenGLShader.ShaderType, QOpenGLShader.ShaderTypeBit], str) -> bool'
        return True
    
    @classmethod
    def attributeLocation(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'attributeLocation(self, Union[QByteArray, bytes, bytearray]) -> int\nattributeLocation(self, str) -> int'
        return 1
    
    @classmethod
    def bind(cls, self):
        'bind(self) -> bool'
        return True
    
    @classmethod
    def bindAttributeLocation(cls, self, UnionQByteArray=None, bytes=None, bytearray=None, int=None):
        'bindAttributeLocation(self, Union[QByteArray, bytes, bytearray], int)\nbindAttributeLocation(self, str, int)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def defaultInnerTessellationLevels(cls, self):
        'defaultInnerTessellationLevels(self) -> List[float]'
        pass
    
    @classmethod
    def defaultOuterTessellationLevels(cls, self):
        'defaultOuterTessellationLevels(self) -> List[float]'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disableAttributeArray(cls, self, str):
        'disableAttributeArray(self, int)\ndisableAttributeArray(self, str)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def enableAttributeArray(cls, self, str):
        'enableAttributeArray(self, int)\nenableAttributeArray(self, str)'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def hasOpenGLShaderPrograms(cls, context: QOpenGLContext=None):
        'hasOpenGLShaderPrograms(context: QOpenGLContext = None) -> bool'
        return True
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isLinked(cls, self):
        'isLinked(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def link(cls, self):
        'link(self) -> bool'
        return True
    
    @classmethod
    def log(cls, self):
        'log(self) -> str'
        return ''
    
    @classmethod
    def maxGeometryOutputVertices(cls, self):
        'maxGeometryOutputVertices(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def patchVertexCount(cls, self):
        'patchVertexCount(self) -> int'
        return 1
    
    @classmethod
    def programId(cls, self):
        'programId(self) -> int'
        return 1
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def release(cls, self):
        'release(self)'
        pass
    
    @classmethod
    def removeAllShaders(cls, self):
        'removeAllShaders(self)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def removeShader(cls, self, QOpenGLShader):
        'removeShader(self, QOpenGLShader)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setAttributeArray(cls, self, str, PYQT_SHADER_ATTRIBUTE_ARRAY):
        'setAttributeArray(self, int, PYQT_SHADER_ATTRIBUTE_ARRAY)\nsetAttributeArray(self, str, PYQT_SHADER_ATTRIBUTE_ARRAY)'
        pass
    
    @classmethod
    def setAttributeBuffer(cls, self, str, int, int_, int_1, stride: int=0):
        'setAttributeBuffer(self, int, int, int, int, stride: int = 0)\nsetAttributeBuffer(self, str, int, int, int, stride: int = 0)'
        pass
    
    @classmethod
    def setAttributeValue(cls, self, str, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setAttributeValue(self, int, float)\nsetAttributeValue(self, int, float, float)\nsetAttributeValue(self, int, float, float, float)\nsetAttributeValue(self, int, float, float, float, float)\nsetAttributeValue(self, int, QVector2D)\nsetAttributeValue(self, int, QVector3D)\nsetAttributeValue(self, int, QVector4D)\nsetAttributeValue(self, int, Union[QColor, Qt.GlobalColor, QGradient])\nsetAttributeValue(self, str, float)\nsetAttributeValue(self, str, float, float)\nsetAttributeValue(self, str, float, float, float)\nsetAttributeValue(self, str, float, float, float, float)\nsetAttributeValue(self, str, QVector2D)\nsetAttributeValue(self, str, QVector3D)\nsetAttributeValue(self, str, QVector4D)\nsetAttributeValue(self, str, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setDefaultInnerTessellationLevels(cls, self, Iterablefloat=None):
        'setDefaultInnerTessellationLevels(self, Iterable[float])'
        pass
    
    @classmethod
    def setDefaultOuterTessellationLevels(cls, self, Iterablefloat=None):
        'setDefaultOuterTessellationLevels(self, Iterable[float])'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setPatchVertexCount(cls, self, int):
        'setPatchVertexCount(self, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setUniformValue(cls, self, str, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setUniformValue(self, int, int)\nsetUniformValue(self, int, float)\nsetUniformValue(self, int, float, float)\nsetUniformValue(self, int, float, float, float)\nsetUniformValue(self, int, float, float, float, float)\nsetUniformValue(self, int, QVector2D)\nsetUniformValue(self, int, QVector3D)\nsetUniformValue(self, int, QVector4D)\nsetUniformValue(self, int, Union[QColor, Qt.GlobalColor, QGradient])\nsetUniformValue(self, int, QPoint)\nsetUniformValue(self, int, Union[QPointF, QPoint])\nsetUniformValue(self, int, QSize)\nsetUniformValue(self, int, QSizeF)\nsetUniformValue(self, int, QMatrix2x2)\nsetUniformValue(self, int, QMatrix2x3)\nsetUniformValue(self, int, QMatrix2x4)\nsetUniformValue(self, int, QMatrix3x2)\nsetUniformValue(self, int, QMatrix3x3)\nsetUniformValue(self, int, QMatrix3x4)\nsetUniformValue(self, int, QMatrix4x2)\nsetUniformValue(self, int, QMatrix4x3)\nsetUniformValue(self, int, QMatrix4x4)\nsetUniformValue(self, int, QTransform)\nsetUniformValue(self, str, int)\nsetUniformValue(self, str, float)\nsetUniformValue(self, str, float, float)\nsetUniformValue(self, str, float, float, float)\nsetUniformValue(self, str, float, float, float, float)\nsetUniformValue(self, str, QVector2D)\nsetUniformValue(self, str, QVector3D)\nsetUniformValue(self, str, QVector4D)\nsetUniformValue(self, str, Union[QColor, Qt.GlobalColor, QGradient])\nsetUniformValue(self, str, QPoint)\nsetUniformValue(self, str, Union[QPointF, QPoint])\nsetUniformValue(self, str, QSize)\nsetUniformValue(self, str, QSizeF)\nsetUniformValue(self, str, QMatrix2x2)\nsetUniformValue(self, str, QMatrix2x3)\nsetUniformValue(self, str, QMatrix2x4)\nsetUniformValue(self, str, QMatrix3x2)\nsetUniformValue(self, str, QMatrix3x3)\nsetUniformValue(self, str, QMatrix3x4)\nsetUniformValue(self, str, QMatrix4x2)\nsetUniformValue(self, str, QMatrix4x3)\nsetUniformValue(self, str, QMatrix4x4)\nsetUniformValue(self, str, QTransform)'
        pass
    
    @classmethod
    def setUniformValueArray(cls, self, str, PYQT_SHADER_UNIFORM_VALUE_ARRAY):
        'setUniformValueArray(self, int, PYQT_SHADER_UNIFORM_VALUE_ARRAY)\nsetUniformValueArray(self, str, PYQT_SHADER_UNIFORM_VALUE_ARRAY)'
        pass
    
    @classmethod
    def shaders(cls, self):
        'shaders(self) -> object'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def uniformLocation(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'uniformLocation(self, Union[QByteArray, bytes, bytearray]) -> int\nuniformLocation(self, str) -> int'
        return 1
    

class QOpenGLTexture(_mod_sip.simplewrapper):
    'QOpenGLTexture(QOpenGLTexture.Target)\nQOpenGLTexture(QImage, genMipMaps: QOpenGLTexture.MipMapGeneration = QOpenGLTexture.GenerateMipMaps)'
    Alpha = PixelFormat()
    AlphaFormat = TextureFormat()
    AlphaValue = SwizzleValue()
    AnisotropicFiltering = Feature()
    BGR = PixelFormat()
    BGRA = PixelFormat()
    BGRA_Integer = PixelFormat()
    BGR_Integer = PixelFormat()
    BindingTarget = BindingTarget()
    BindingTarget1D = BindingTarget()
    BindingTarget1DArray = BindingTarget()
    BindingTarget2D = BindingTarget()
    BindingTarget2DArray = BindingTarget()
    BindingTarget2DMultisample = BindingTarget()
    BindingTarget2DMultisampleArray = BindingTarget()
    BindingTarget3D = BindingTarget()
    BindingTargetBuffer = BindingTarget()
    BindingTargetCubeMap = BindingTarget()
    BindingTargetCubeMapArray = BindingTarget()
    BindingTargetRectangle = BindingTarget()
    BlueValue = SwizzleValue()
    ClampToBorder = WrapMode()
    ClampToEdge = WrapMode()
    CommpareNotEqual = ComparisonFunction()
    CompareAlways = ComparisonFunction()
    CompareEqual = ComparisonFunction()
    CompareGreater = ComparisonFunction()
    CompareGreaterEqual = ComparisonFunction()
    CompareLess = ComparisonFunction()
    CompareLessEqual = ComparisonFunction()
    CompareNever = ComparisonFunction()
    CompareNone = ComparisonMode()
    CompareRefToTexture = ComparisonMode()
    ComparisonFunction = ComparisonFunction()
    ComparisonMode = ComparisonMode()
    CoordinateDirection = CoordinateDirection()
    CubeMapFace = CubeMapFace()
    CubeMapNegativeX = CubeMapFace()
    CubeMapNegativeY = CubeMapFace()
    CubeMapNegativeZ = CubeMapFace()
    CubeMapPositiveX = CubeMapFace()
    CubeMapPositiveY = CubeMapFace()
    CubeMapPositiveZ = CubeMapFace()
    D16 = TextureFormat()
    D24 = TextureFormat()
    D24S8 = TextureFormat()
    D32 = TextureFormat()
    D32F = TextureFormat()
    D32FS8X24 = TextureFormat()
    Depth = PixelFormat()
    DepthFormat = TextureFormat()
    DepthMode = DepthStencilMode()
    DepthStencil = PixelFormat()
    DepthStencilMode = DepthStencilMode()
    DirectionR = CoordinateDirection()
    DirectionS = CoordinateDirection()
    DirectionT = CoordinateDirection()
    DontGenerateMipMaps = MipMapGeneration()
    DontResetTextureUnit = TextureUnitReset()
    Feature = Feature()
    Features = Features()
    Filter = Filter()
    Float16 = PixelType()
    Float16OES = PixelType()
    Float32 = PixelType()
    Float32_D32_UInt32_S8_X24 = PixelType()
    GenerateMipMaps = MipMapGeneration()
    GreenValue = SwizzleValue()
    ImmutableMultisampleStorage = Feature()
    ImmutableStorage = Feature()
    Int16 = PixelType()
    Int32 = PixelType()
    Int8 = PixelType()
    Linear = Filter()
    LinearMipMapLinear = Filter()
    LinearMipMapNearest = Filter()
    Luminance = PixelFormat()
    LuminanceAlpha = PixelFormat()
    LuminanceAlphaFormat = TextureFormat()
    LuminanceFormat = TextureFormat()
    MipMapGeneration = MipMapGeneration()
    MirroredRepeat = WrapMode()
    NPOTTextureRepeat = Feature()
    NPOTTextures = Feature()
    Nearest = Filter()
    NearestMipMapLinear = Filter()
    NearestMipMapNearest = Filter()
    NoFormat = TextureFormat()
    NoPixelType = PixelType()
    NoSourceFormat = PixelFormat()
    OneValue = SwizzleValue()
    PixelFormat = PixelFormat()
    PixelType = PixelType()
    R11_EAC_SNorm = TextureFormat()
    R11_EAC_UNorm = TextureFormat()
    R16F = TextureFormat()
    R16I = TextureFormat()
    R16U = TextureFormat()
    R16_SNorm = TextureFormat()
    R16_UNorm = TextureFormat()
    R32F = TextureFormat()
    R32I = TextureFormat()
    R32U = TextureFormat()
    R5G6B5 = TextureFormat()
    R8I = TextureFormat()
    R8U = TextureFormat()
    R8_SNorm = TextureFormat()
    R8_UNorm = TextureFormat()
    RG = PixelFormat()
    RG11B10F = TextureFormat()
    RG11_EAC_SNorm = TextureFormat()
    RG11_EAC_UNorm = TextureFormat()
    RG16F = TextureFormat()
    RG16I = TextureFormat()
    RG16U = TextureFormat()
    RG16_SNorm = TextureFormat()
    RG16_UNorm = TextureFormat()
    RG32F = TextureFormat()
    RG32I = TextureFormat()
    RG32U = TextureFormat()
    RG3B2 = TextureFormat()
    RG8I = TextureFormat()
    RG8U = TextureFormat()
    RG8_SNorm = TextureFormat()
    RG8_UNorm = TextureFormat()
    RGB = PixelFormat()
    RGB10A2 = TextureFormat()
    RGB16F = TextureFormat()
    RGB16I = TextureFormat()
    RGB16U = TextureFormat()
    RGB16_SNorm = TextureFormat()
    RGB16_UNorm = TextureFormat()
    RGB32F = TextureFormat()
    RGB32I = TextureFormat()
    RGB32U = TextureFormat()
    RGB5A1 = TextureFormat()
    RGB8I = TextureFormat()
    RGB8U = TextureFormat()
    RGB8_ETC1 = TextureFormat()
    RGB8_ETC2 = TextureFormat()
    RGB8_PunchThrough_Alpha1_ETC2 = TextureFormat()
    RGB8_SNorm = TextureFormat()
    RGB8_UNorm = TextureFormat()
    RGB9E5 = TextureFormat()
    RGBA = PixelFormat()
    RGBA16F = TextureFormat()
    RGBA16I = TextureFormat()
    RGBA16U = TextureFormat()
    RGBA16_SNorm = TextureFormat()
    RGBA16_UNorm = TextureFormat()
    RGBA32F = TextureFormat()
    RGBA32I = TextureFormat()
    RGBA32U = TextureFormat()
    RGBA4 = TextureFormat()
    RGBA8I = TextureFormat()
    RGBA8U = TextureFormat()
    RGBA8_ETC2_EAC = TextureFormat()
    RGBA8_SNorm = TextureFormat()
    RGBA8_UNorm = TextureFormat()
    RGBAFormat = TextureFormat()
    RGBA_ASTC_10x10 = TextureFormat()
    RGBA_ASTC_10x5 = TextureFormat()
    RGBA_ASTC_10x6 = TextureFormat()
    RGBA_ASTC_10x8 = TextureFormat()
    RGBA_ASTC_12x10 = TextureFormat()
    RGBA_ASTC_12x12 = TextureFormat()
    RGBA_ASTC_4x4 = TextureFormat()
    RGBA_ASTC_5x4 = TextureFormat()
    RGBA_ASTC_5x5 = TextureFormat()
    RGBA_ASTC_6x5 = TextureFormat()
    RGBA_ASTC_6x6 = TextureFormat()
    RGBA_ASTC_8x5 = TextureFormat()
    RGBA_ASTC_8x6 = TextureFormat()
    RGBA_ASTC_8x8 = TextureFormat()
    RGBA_DXT1 = TextureFormat()
    RGBA_DXT3 = TextureFormat()
    RGBA_DXT5 = TextureFormat()
    RGBA_Integer = PixelFormat()
    RGBFormat = TextureFormat()
    RGB_BP_SIGNED_FLOAT = TextureFormat()
    RGB_BP_UNSIGNED_FLOAT = TextureFormat()
    RGB_BP_UNorm = TextureFormat()
    RGB_DXT1 = TextureFormat()
    RGB_Integer = PixelFormat()
    RG_ATI2N_SNorm = TextureFormat()
    RG_ATI2N_UNorm = TextureFormat()
    RG_Integer = PixelFormat()
    R_ATI1N_SNorm = TextureFormat()
    R_ATI1N_UNorm = TextureFormat()
    Red = PixelFormat()
    RedValue = SwizzleValue()
    Red_Integer = PixelFormat()
    Repeat = WrapMode()
    ResetTextureUnit = TextureUnitReset()
    S8 = TextureFormat()
    SRGB8 = TextureFormat()
    SRGB8_Alpha8 = TextureFormat()
    SRGB8_Alpha8_ASTC_10x10 = TextureFormat()
    SRGB8_Alpha8_ASTC_10x5 = TextureFormat()
    SRGB8_Alpha8_ASTC_10x6 = TextureFormat()
    SRGB8_Alpha8_ASTC_10x8 = TextureFormat()
    SRGB8_Alpha8_ASTC_12x10 = TextureFormat()
    SRGB8_Alpha8_ASTC_12x12 = TextureFormat()
    SRGB8_Alpha8_ASTC_4x4 = TextureFormat()
    SRGB8_Alpha8_ASTC_5x4 = TextureFormat()
    SRGB8_Alpha8_ASTC_5x5 = TextureFormat()
    SRGB8_Alpha8_ASTC_6x5 = TextureFormat()
    SRGB8_Alpha8_ASTC_6x6 = TextureFormat()
    SRGB8_Alpha8_ASTC_8x5 = TextureFormat()
    SRGB8_Alpha8_ASTC_8x6 = TextureFormat()
    SRGB8_Alpha8_ASTC_8x8 = TextureFormat()
    SRGB8_Alpha8_ETC2_EAC = TextureFormat()
    SRGB8_ETC2 = TextureFormat()
    SRGB8_PunchThrough_Alpha1_ETC2 = TextureFormat()
    SRGB_Alpha_DXT1 = TextureFormat()
    SRGB_Alpha_DXT3 = TextureFormat()
    SRGB_Alpha_DXT5 = TextureFormat()
    SRGB_BP_UNorm = TextureFormat()
    SRGB_DXT1 = TextureFormat()
    Stencil = PixelFormat()
    StencilMode = DepthStencilMode()
    StencilTexturing = Feature()
    Swizzle = Feature()
    SwizzleAlpha = SwizzleComponent()
    SwizzleBlue = SwizzleComponent()
    SwizzleComponent = SwizzleComponent()
    SwizzleGreen = SwizzleComponent()
    SwizzleRed = SwizzleComponent()
    SwizzleValue = SwizzleValue()
    Target = Target()
    Target1D = Target()
    Target1DArray = Target()
    Target2D = Target()
    Target2DArray = Target()
    Target2DMultisample = Target()
    Target2DMultisampleArray = Target()
    Target3D = Target()
    TargetBuffer = Target()
    TargetCubeMap = Target()
    TargetCubeMapArray = Target()
    TargetRectangle = Target()
    Texture1D = Feature()
    Texture3D = Feature()
    TextureArrays = Feature()
    TextureBuffer = Feature()
    TextureComparisonOperators = Feature()
    TextureCubeMapArrays = Feature()
    TextureFormat = TextureFormat()
    TextureMipMapLevel = Feature()
    TextureMultisample = Feature()
    TextureRectangle = Feature()
    TextureUnitReset = TextureUnitReset()
    UInt16 = PixelType()
    UInt16_R5G6B5 = PixelType()
    UInt16_R5G6B5_Rev = PixelType()
    UInt16_RGB5A1 = PixelType()
    UInt16_RGB5A1_Rev = PixelType()
    UInt16_RGBA4 = PixelType()
    UInt16_RGBA4_Rev = PixelType()
    UInt32 = PixelType()
    UInt32_D24S8 = PixelType()
    UInt32_RG11B10F = PixelType()
    UInt32_RGB10A2 = PixelType()
    UInt32_RGB10A2_Rev = PixelType()
    UInt32_RGB9_E5 = PixelType()
    UInt32_RGBA8 = PixelType()
    UInt32_RGBA8_Rev = PixelType()
    UInt8 = PixelType()
    UInt8_RG3B2 = PixelType()
    UInt8_RG3B2_Rev = PixelType()
    WrapMode = WrapMode()
    ZeroValue = SwizzleValue()
    __class__ = QOpenGLTexture
    __dict__ = {}
    def __init__(self, QImage, genMipMaps: QOpenGLTexture.MipMapGeneration=QOpenGLTexture.GenerateMipMaps):
        'QOpenGLTexture(QOpenGLTexture.Target)\nQOpenGLTexture(QImage, genMipMaps: QOpenGLTexture.MipMapGeneration = QOpenGLTexture.GenerateMipMaps)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def allocateStorage(cls, self, QOpenGLTexturePixelFormat, QOpenGLTexturePixelType):
        'allocateStorage(self)\nallocateStorage(self, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType)'
        pass
    
    @classmethod
    def bind(cls, self, int, reset: QOpenGLTexture.TextureUnitReset=QOpenGLTexture.DontResetTextureUnit):
        'bind(self)\nbind(self, int, reset: QOpenGLTexture.TextureUnitReset = QOpenGLTexture.DontResetTextureUnit)'
        pass
    
    @classmethod
    def borderColor(cls, self):
        'borderColor(self) -> QColor'
        pass
    
    @classmethod
    def boundTextureId(cls, int, QOpenGLTextureBindingTarget):
        'boundTextureId(QOpenGLTexture.BindingTarget) -> int\nboundTextureId(int, QOpenGLTexture.BindingTarget) -> int'
        return 1
    
    @classmethod
    def comparisonFunction(cls, self):
        'comparisonFunction(self) -> QOpenGLTexture.ComparisonFunction'
        pass
    
    @classmethod
    def comparisonMode(cls, self):
        'comparisonMode(self) -> QOpenGLTexture.ComparisonMode'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def createTextureView(cls, self, QOpenGLTextureTarget, QOpenGLTextureTextureFormat, int, int_, int_1, int_2):
        'createTextureView(self, QOpenGLTexture.Target, QOpenGLTexture.TextureFormat, int, int, int, int) -> QOpenGLTexture'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def depthStencilMode(cls, self):
        'depthStencilMode(self) -> QOpenGLTexture.DepthStencilMode'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def faces(cls, self):
        'faces(self) -> int'
        return 1
    
    @classmethod
    def format(cls, self):
        'format(self) -> QOpenGLTexture.TextureFormat'
        pass
    
    @classmethod
    def generateMipMaps(cls, self, int, resetBaseLevel: bool=True):
        'generateMipMaps(self)\ngenerateMipMaps(self, int, resetBaseLevel: bool = True)'
        pass
    
    @classmethod
    def hasFeature(cls, QOpenGLTextureFeature):
        'hasFeature(QOpenGLTexture.Feature) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def isAutoMipMapGenerationEnabled(cls, self):
        'isAutoMipMapGenerationEnabled(self) -> bool'
        return True
    
    @classmethod
    def isBound(cls, self, int):
        'isBound(self) -> bool\nisBound(self, int) -> bool'
        return True
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def isFixedSamplePositions(cls, self):
        'isFixedSamplePositions(self) -> bool'
        return True
    
    @classmethod
    def isStorageAllocated(cls, self):
        'isStorageAllocated(self) -> bool'
        return True
    
    @classmethod
    def isTextureView(cls, self):
        'isTextureView(self) -> bool'
        return True
    
    @classmethod
    def layers(cls, self):
        'layers(self) -> int'
        return 1
    
    @classmethod
    def levelOfDetailRange(cls, self):
        'levelOfDetailRange(self) -> Tuple[float, float]'
        pass
    
    @classmethod
    def levelofDetailBias(cls, self):
        'levelofDetailBias(self) -> float'
        return 1.0
    
    @classmethod
    def magnificationFilter(cls, self):
        'magnificationFilter(self) -> QOpenGLTexture.Filter'
        pass
    
    @classmethod
    def maximumAnisotropy(cls, self):
        'maximumAnisotropy(self) -> float'
        return 1.0
    
    @classmethod
    def maximumLevelOfDetail(cls, self):
        'maximumLevelOfDetail(self) -> float'
        return 1.0
    
    @classmethod
    def maximumMipLevels(cls, self):
        'maximumMipLevels(self) -> int'
        return 1
    
    @classmethod
    def minMagFilters(cls, self):
        'minMagFilters(self) -> Tuple[QOpenGLTexture.Filter, QOpenGLTexture.Filter]'
        pass
    
    @classmethod
    def minificationFilter(cls, self):
        'minificationFilter(self) -> QOpenGLTexture.Filter'
        pass
    
    @classmethod
    def minimumLevelOfDetail(cls, self):
        'minimumLevelOfDetail(self) -> float'
        return 1.0
    
    @classmethod
    def mipBaseLevel(cls, self):
        'mipBaseLevel(self) -> int'
        return 1
    
    @classmethod
    def mipLevelRange(cls, self):
        'mipLevelRange(self) -> Tuple[int, int]'
        pass
    
    @classmethod
    def mipLevels(cls, self):
        'mipLevels(self) -> int'
        return 1
    
    @classmethod
    def mipMaxLevel(cls, self):
        'mipMaxLevel(self) -> int'
        return 1
    
    @classmethod
    def release(cls, self, int, reset: QOpenGLTexture.TextureUnitReset=QOpenGLTexture.DontResetTextureUnit):
        'release(self)\nrelease(self, int, reset: QOpenGLTexture.TextureUnitReset = QOpenGLTexture.DontResetTextureUnit)'
        pass
    
    @classmethod
    def samples(cls, self):
        'samples(self) -> int'
        return 1
    
    @classmethod
    def setAutoMipMapGenerationEnabled(cls, self, bool):
        'setAutoMipMapGenerationEnabled(self, bool)'
        pass
    
    @classmethod
    def setBorderColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setBorderColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setComparisonFunction(cls, self, QOpenGLTextureComparisonFunction):
        'setComparisonFunction(self, QOpenGLTexture.ComparisonFunction)'
        pass
    
    @classmethod
    def setComparisonMode(cls, self, QOpenGLTextureComparisonMode):
        'setComparisonMode(self, QOpenGLTexture.ComparisonMode)'
        pass
    
    @classmethod
    def setCompressedData(cls, self, int, int_, int_1, QOpenGLTextureCubeMapFace, int_2, sipvoidptr, options: QOpenGLPixelTransferOptions=None):
        'setCompressedData(self, int, int, QOpenGLTexture.CubeMapFace, int, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetCompressedData(self, int, int, int, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetCompressedData(self, int, int, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetCompressedData(self, int, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetCompressedData(self, int, int, int, QOpenGLTexture.CubeMapFace, int, sip.voidptr, options: QOpenGLPixelTransferOptions = None)'
        pass
    
    @classmethod
    def setData(cls, self, int, int_, int_1, QOpenGLTextureCubeMapFace, QOpenGLTexturePixelFormat, QOpenGLTexturePixelType, sipvoidptr, options: QOpenGLPixelTransferOptions=None):
        'setData(self, int, int, QOpenGLTexture.CubeMapFace, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetData(self, int, int, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetData(self, int, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetData(self, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType, sip.voidptr, options: QOpenGLPixelTransferOptions = None)\nsetData(self, QImage, genMipMaps: QOpenGLTexture.MipMapGeneration = QOpenGLTexture.GenerateMipMaps)\nsetData(self, int, int, int, QOpenGLTexture.CubeMapFace, QOpenGLTexture.PixelFormat, QOpenGLTexture.PixelType, sip.voidptr, options: QOpenGLPixelTransferOptions = None)'
        pass
    
    @classmethod
    def setDepthStencilMode(cls, self, QOpenGLTextureDepthStencilMode):
        'setDepthStencilMode(self, QOpenGLTexture.DepthStencilMode)'
        pass
    
    @classmethod
    def setFixedSamplePositions(cls, self, bool):
        'setFixedSamplePositions(self, bool)'
        pass
    
    @classmethod
    def setFormat(cls, self, QOpenGLTextureTextureFormat):
        'setFormat(self, QOpenGLTexture.TextureFormat)'
        pass
    
    @classmethod
    def setLayers(cls, self, int):
        'setLayers(self, int)'
        pass
    
    @classmethod
    def setLevelOfDetailRange(cls, self, float, float_):
        'setLevelOfDetailRange(self, float, float)'
        pass
    
    @classmethod
    def setLevelofDetailBias(cls, self, float):
        'setLevelofDetailBias(self, float)'
        pass
    
    @classmethod
    def setMagnificationFilter(cls, self, QOpenGLTextureFilter):
        'setMagnificationFilter(self, QOpenGLTexture.Filter)'
        pass
    
    @classmethod
    def setMaximumAnisotropy(cls, self, float):
        'setMaximumAnisotropy(self, float)'
        pass
    
    @classmethod
    def setMaximumLevelOfDetail(cls, self, float):
        'setMaximumLevelOfDetail(self, float)'
        pass
    
    @classmethod
    def setMinMagFilters(cls, self, QOpenGLTextureFilter, QOpenGLTextureFilter_):
        'setMinMagFilters(self, QOpenGLTexture.Filter, QOpenGLTexture.Filter)'
        pass
    
    @classmethod
    def setMinificationFilter(cls, self, QOpenGLTextureFilter):
        'setMinificationFilter(self, QOpenGLTexture.Filter)'
        pass
    
    @classmethod
    def setMinimumLevelOfDetail(cls, self, float):
        'setMinimumLevelOfDetail(self, float)'
        pass
    
    @classmethod
    def setMipBaseLevel(cls, self, int):
        'setMipBaseLevel(self, int)'
        pass
    
    @classmethod
    def setMipLevelRange(cls, self, int, int_):
        'setMipLevelRange(self, int, int)'
        pass
    
    @classmethod
    def setMipLevels(cls, self, int):
        'setMipLevels(self, int)'
        pass
    
    @classmethod
    def setMipMaxLevel(cls, self, int):
        'setMipMaxLevel(self, int)'
        pass
    
    @classmethod
    def setSamples(cls, self, int):
        'setSamples(self, int)'
        pass
    
    @classmethod
    def setSize(cls, self, int, height: int=1, depth: int=1):
        'setSize(self, int, height: int = 1, depth: int = 1)'
        pass
    
    @classmethod
    def setSwizzleMask(cls, self, QOpenGLTextureSwizzleValue, QOpenGLTextureSwizzleValue_, QOpenGLTextureSwizzleValue_1, QOpenGLTextureSwizzleValue_2):
        'setSwizzleMask(self, QOpenGLTexture.SwizzleComponent, QOpenGLTexture.SwizzleValue)\nsetSwizzleMask(self, QOpenGLTexture.SwizzleValue, QOpenGLTexture.SwizzleValue, QOpenGLTexture.SwizzleValue, QOpenGLTexture.SwizzleValue)'
        pass
    
    @classmethod
    def setWrapMode(cls, self, QOpenGLTextureCoordinateDirection, QOpenGLTextureWrapMode):
        'setWrapMode(self, QOpenGLTexture.WrapMode)\nsetWrapMode(self, QOpenGLTexture.CoordinateDirection, QOpenGLTexture.WrapMode)'
        pass
    
    @classmethod
    def swizzleMask(cls, self, QOpenGLTextureSwizzleComponent):
        'swizzleMask(self, QOpenGLTexture.SwizzleComponent) -> QOpenGLTexture.SwizzleValue'
        pass
    
    @classmethod
    def target(cls, self):
        'target(self) -> QOpenGLTexture.Target'
        pass
    
    @classmethod
    def textureId(cls, self):
        'textureId(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def wrapMode(cls, self, QOpenGLTextureCoordinateDirection):
        'wrapMode(self, QOpenGLTexture.CoordinateDirection) -> QOpenGLTexture.WrapMode'
        pass
    

class QOpenGLTextureBlitter(_mod_sip.simplewrapper):
    'QOpenGLTextureBlitter()'
    Origin = Origin()
    OriginBottomLeft = Origin()
    OriginTopLeft = Origin()
    __class__ = QOpenGLTextureBlitter
    __dict__ = {}
    def __init__(self):
        'QOpenGLTextureBlitter()'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def bind(cls, self, target: int=GL_TEXTURE_2D):
        'bind(self, target: int = GL_TEXTURE_2D)'
        pass
    
    @classmethod
    def blit(cls, self, int, QMatrix4x4, QOpenGLTextureBlitterOrigin):
        'blit(self, int, QMatrix4x4, QOpenGLTextureBlitter.Origin)\nblit(self, int, QMatrix4x4, QMatrix3x3)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def release(cls, self):
        'release(self)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setRedBlueSwizzle(cls, self, bool):
        'setRedBlueSwizzle(self, bool)'
        pass
    
    @classmethod
    def sourceTransform(cls, QRectF, QSize, QOpenGLTextureBlitterOrigin):
        'sourceTransform(QRectF, QSize, QOpenGLTextureBlitter.Origin) -> QMatrix3x3'
        pass
    
    @classmethod
    def supportsExternalOESTarget(cls, self):
        'supportsExternalOESTarget(self) -> bool'
        return True
    
    @classmethod
    def targetTransform(cls, QRectF, QRect):
        'targetTransform(QRectF, QRect) -> QMatrix4x4'
        pass
    

class QOpenGLTimeMonitor(_mod_PyQt5_QtCore.QObject):
    'QOpenGLTimeMonitor(parent: QObject = None)'
    __class__ = QOpenGLTimeMonitor
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLTimeMonitor(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def isResultAvailable(cls, self):
        'isResultAvailable(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIds(cls, self):
        'objectIds(self) -> List[int]'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def recordSample(cls, self):
        'recordSample(self) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reset(cls, self):
        'reset(self)'
        pass
    
    @classmethod
    def sampleCount(cls, self):
        'sampleCount(self) -> int'
        return 1
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setSampleCount(cls, self, int):
        'setSampleCount(self, int)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def waitForIntervals(cls, self):
        'waitForIntervals(self) -> List[int]'
        pass
    
    @classmethod
    def waitForSamples(cls, self):
        'waitForSamples(self) -> List[int]'
        pass
    

class QOpenGLTimerQuery(_mod_PyQt5_QtCore.QObject):
    'QOpenGLTimerQuery(parent: QObject = None)'
    __class__ = QOpenGLTimerQuery
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLTimerQuery(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def begin(cls, self):
        'begin(self)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self)'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def isResultAvailable(cls, self):
        'isResultAvailable(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectId(cls, self):
        'objectId(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def recordTimestamp(cls, self):
        'recordTimestamp(self)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def waitForResult(cls, self):
        'waitForResult(self) -> int'
        return 1
    
    @classmethod
    def waitForTimestamp(cls, self):
        'waitForTimestamp(self) -> int'
        return 1
    

class QOpenGLVersionProfile(_mod_sip.simplewrapper):
    'QOpenGLVersionProfile()\nQOpenGLVersionProfile(QSurfaceFormat)\nQOpenGLVersionProfile(QOpenGLVersionProfile)'
    __class__ = QOpenGLVersionProfile
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QOpenGLVersionProfile):
        'QOpenGLVersionProfile()\nQOpenGLVersionProfile(QSurfaceFormat)\nQOpenGLVersionProfile(QOpenGLVersionProfile)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def hasProfiles(cls, self):
        'hasProfiles(self) -> bool'
        return True
    
    @classmethod
    def isLegacyVersion(cls, self):
        'isLegacyVersion(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def profile(cls, self):
        'profile(self) -> QSurfaceFormat.OpenGLContextProfile'
        pass
    
    @classmethod
    def setProfile(cls, self, QSurfaceFormatOpenGLContextProfile):
        'setProfile(self, QSurfaceFormat.OpenGLContextProfile)'
        pass
    
    @classmethod
    def setVersion(cls, self, int, int_):
        'setVersion(self, int, int)'
        pass
    
    @classmethod
    def version(cls, self):
        'version(self) -> Tuple[int, int]'
        pass
    

class QOpenGLVertexArrayObject(_mod_PyQt5_QtCore.QObject):
    'QOpenGLVertexArrayObject(parent: QObject = None)'
    Binder = Binder()
    __class__ = QOpenGLVertexArrayObject
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QOpenGLVertexArrayObject(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def bind(cls, self):
        'bind(self)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self) -> bool'
        return True
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isCreated(cls, self):
        'isCreated(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectId(cls, self):
        'objectId(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def release(cls, self):
        'release(self)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QOpenGLWindow(QPaintDeviceWindow):
    'QOpenGLWindow(updateBehavior: QOpenGLWindow.UpdateBehavior = QOpenGLWindow.NoPartialUpdate, parent: QWindow = None)\nQOpenGLWindow(QOpenGLContext, updateBehavior: QOpenGLWindow.UpdateBehavior = QOpenGLWindow.NoPartialUpdate, parent: QWindow = None)'
    NoPartialUpdate = UpdateBehavior()
    PartialUpdateBlend = UpdateBehavior()
    PartialUpdateBlit = UpdateBehavior()
    UpdateBehavior = UpdateBehavior()
    __class__ = QOpenGLWindow
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QOpenGLContext, updateBehavior: QOpenGLWindow.UpdateBehavior=QOpenGLWindow.NoPartialUpdate, parent: QWindow=None):
        'QOpenGLWindow(updateBehavior: QOpenGLWindow.UpdateBehavior = QOpenGLWindow.NoPartialUpdate, parent: QWindow = None)\nQOpenGLWindow(QOpenGLContext, updateBehavior: QOpenGLWindow.UpdateBehavior = QOpenGLWindow.NoPartialUpdate, parent: QWindow = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def alert(cls, self, int):
        'alert(self, int)'
        pass
    
    @classmethod
    def baseSize(cls, self):
        'baseSize(self) -> QSize'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def close(cls, self):
        'close(self) -> bool'
        return True
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def contentOrientation(cls, self):
        'contentOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def context(cls, self):
        'context(self) -> QOpenGLContext'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self)'
        pass
    
    @classmethod
    def cursor(cls, self):
        'cursor(self) -> QCursor'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def defaultFramebufferObject(cls, self):
        'defaultFramebufferObject(self) -> int'
        return 1
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def doneCurrent(cls, self):
        'doneCurrent(self)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exposeEvent(cls, self, QExposeEvent):
        'exposeEvent(self, QExposeEvent)'
        pass
    
    @classmethod
    def filePath(cls, self):
        'filePath(self) -> str'
        return ''
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.WindowFlags'
        pass
    
    @classmethod
    def focusInEvent(cls, self, QFocusEvent):
        'focusInEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def focusObject(cls, self):
        'focusObject(self) -> QObject'
        pass
    
    @classmethod
    def focusOutEvent(cls, self, QFocusEvent):
        'focusOutEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def frameGeometry(cls, self):
        'frameGeometry(self) -> QRect'
        pass
    
    @classmethod
    def frameMargins(cls, self):
        'frameMargins(self) -> QMargins'
        pass
    
    @classmethod
    def framePosition(cls, self):
        'framePosition(self) -> QPoint'
        pass
    
    def frameSwapped(self):
        'frameSwapped(self) [signal]'
        pass
    
    @classmethod
    def fromWinId(cls, sipvoidptr):
        'fromWinId(sip.voidptr) -> QWindow'
        pass
    
    @classmethod
    def geometry(cls, self):
        'geometry(self) -> QRect'
        pass
    
    @classmethod
    def grabFramebuffer(cls, self):
        'grabFramebuffer(self) -> QImage'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def hide(cls, self):
        'hide(self)'
        pass
    
    @classmethod
    def hideEvent(cls, self, QHideEvent):
        'hideEvent(self, QHideEvent)'
        pass
    
    @classmethod
    def icon(cls, self):
        'icon(self) -> QIcon'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def initializeGL(cls, self):
        'initializeGL(self)'
        pass
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def isAncestorOf(cls, self, QWindow, mode: QWindow.AncestorMode=QWindow.IncludeTransients):
        'isAncestorOf(self, QWindow, mode: QWindow.AncestorMode = QWindow.IncludeTransients) -> bool'
        return True
    
    @classmethod
    def isExposed(cls, self):
        'isExposed(self) -> bool'
        return True
    
    @classmethod
    def isModal(cls, self):
        'isModal(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isTopLevel(cls, self):
        'isTopLevel(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyPressEvent(cls, self, QKeyEvent):
        'keyPressEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def keyReleaseEvent(cls, self, QKeyEvent):
        'keyReleaseEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def lower(cls, self):
        'lower(self)'
        pass
    
    @classmethod
    def makeCurrent(cls, self):
        'makeCurrent(self)'
        pass
    
    @classmethod
    def mapFromGlobal(cls, self, QPoint):
        'mapFromGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mapToGlobal(cls, self, QPoint):
        'mapToGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QRegion'
        pass
    
    @classmethod
    def maximumHeight(cls, self):
        'maximumHeight(self) -> int'
        return 1
    
    @classmethod
    def maximumSize(cls, self):
        'maximumSize(self) -> QSize'
        pass
    
    @classmethod
    def maximumWidth(cls, self):
        'maximumWidth(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def minimumHeight(cls, self):
        'minimumHeight(self) -> int'
        return 1
    
    @classmethod
    def minimumSize(cls, self):
        'minimumSize(self) -> QSize'
        pass
    
    @classmethod
    def minimumWidth(cls, self):
        'minimumWidth(self) -> int'
        return 1
    
    @classmethod
    def modality(cls, self):
        'modality(self) -> Qt.WindowModality'
        pass
    
    @classmethod
    def mouseDoubleClickEvent(cls, self, QMouseEvent):
        'mouseDoubleClickEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseMoveEvent(cls, self, QMouseEvent):
        'mouseMoveEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mousePressEvent(cls, self, QMouseEvent):
        'mousePressEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseReleaseEvent(cls, self, QMouseEvent):
        'mouseReleaseEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def moveEvent(cls, self, QMoveEvent):
        'moveEvent(self, QMoveEvent)'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintEvent(cls, self, QPaintEvent):
        'paintEvent(self, QPaintEvent)'
        pass
    
    @classmethod
    def paintGL(cls, self):
        'paintGL(self)'
        pass
    
    @classmethod
    def paintOverGL(cls, self):
        'paintOverGL(self)'
        pass
    
    @classmethod
    def paintUnderGL(cls, self):
        'paintUnderGL(self)'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def parent(cls, self, QWindowAncestorMode):
        'parent(self) -> QWindow\nparent(self, QWindow.AncestorMode) -> QWindow'
        pass
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPoint'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def raise_(cls, self):
        'raise_(self)'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reportContentOrientationChange(cls, self, QtScreenOrientation):
        'reportContentOrientationChange(self, Qt.ScreenOrientation)'
        pass
    
    @classmethod
    def requestActivate(cls, self):
        'requestActivate(self)'
        pass
    
    @classmethod
    def requestUpdate(cls, self):
        'requestUpdate(self)'
        pass
    
    @classmethod
    def requestedFormat(cls, self):
        'requestedFormat(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def resize(cls, self, int, int_):
        'resize(self, QSize)\nresize(self, int, int)'
        pass
    
    @classmethod
    def resizeEvent(cls, self, QResizeEvent):
        'resizeEvent(self, QResizeEvent)'
        pass
    
    @classmethod
    def resizeGL(cls, self, int, int_):
        'resizeGL(self, int, int)'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBaseSize(cls, self, QSize):
        'setBaseSize(self, QSize)'
        pass
    
    @classmethod
    def setCursor(cls, self, UnionQCursor=None, QtCursorShape=None):
        'setCursor(self, Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def setFilePath(cls, self, str):
        'setFilePath(self, str)'
        pass
    
    @classmethod
    def setFlag(cls, self, QtWindowType, on: bool=True):
        'setFlag(self, Qt.WindowType, on: bool = True)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQtWindowFlags=None, QtWindowType=None):
        'setFlags(self, Union[Qt.WindowFlags, Qt.WindowType])'
        pass
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setFramePosition(cls, self, QPoint):
        'setFramePosition(self, QPoint)'
        pass
    
    @classmethod
    def setGeometry(cls, self, int, int_, int_1, int_2):
        'setGeometry(self, int, int, int, int)\nsetGeometry(self, QRect)'
        pass
    
    @classmethod
    def setHeight(cls, self, int):
        'setHeight(self, int)'
        pass
    
    @classmethod
    def setIcon(cls, self, QIcon):
        'setIcon(self, QIcon)'
        pass
    
    @classmethod
    def setKeyboardGrabEnabled(cls, self, bool):
        'setKeyboardGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setMask(cls, self, QRegion):
        'setMask(self, QRegion)'
        pass
    
    @classmethod
    def setMaximumHeight(cls, self, int):
        'setMaximumHeight(self, int)'
        pass
    
    @classmethod
    def setMaximumSize(cls, self, QSize):
        'setMaximumSize(self, QSize)'
        pass
    
    @classmethod
    def setMaximumWidth(cls, self, int):
        'setMaximumWidth(self, int)'
        pass
    
    @classmethod
    def setMinimumHeight(cls, self, int):
        'setMinimumHeight(self, int)'
        pass
    
    @classmethod
    def setMinimumSize(cls, self, QSize):
        'setMinimumSize(self, QSize)'
        pass
    
    @classmethod
    def setMinimumWidth(cls, self, int):
        'setMinimumWidth(self, int)'
        pass
    
    @classmethod
    def setModality(cls, self, QtWindowModality):
        'setModality(self, Qt.WindowModality)'
        pass
    
    @classmethod
    def setMouseGrabEnabled(cls, self, bool):
        'setMouseGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setParent(cls, self, QWindow):
        'setParent(self, QWindow)'
        pass
    
    @classmethod
    def setPosition(cls, self, int, int_):
        'setPosition(self, QPoint)\nsetPosition(self, int, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def setSizeIncrement(cls, self, QSize):
        'setSizeIncrement(self, QSize)'
        pass
    
    @classmethod
    def setSurfaceType(cls, self, QSurfaceSurfaceType):
        'setSurfaceType(self, QSurface.SurfaceType)'
        pass
    
    @classmethod
    def setTitle(cls, self, str):
        'setTitle(self, str)'
        pass
    
    @classmethod
    def setTransientParent(cls, self, QWindow):
        'setTransientParent(self, QWindow)'
        pass
    
    @classmethod
    def setVisibility(cls, self, QWindowVisibility):
        'setVisibility(self, QWindow.Visibility)'
        pass
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def setWidth(cls, self, int):
        'setWidth(self, int)'
        pass
    
    @classmethod
    def setWindowState(cls, self, QtWindowState):
        'setWindowState(self, Qt.WindowState)'
        pass
    
    @classmethod
    def setX(cls, self, int):
        'setX(self, int)'
        pass
    
    @classmethod
    def setY(cls, self, int):
        'setY(self, int)'
        pass
    
    @classmethod
    def shareContext(cls, self):
        'shareContext(self) -> QOpenGLContext'
        pass
    
    @classmethod
    def show(cls, self):
        'show(self)'
        pass
    
    @classmethod
    def showEvent(cls, self, QShowEvent):
        'showEvent(self, QShowEvent)'
        pass
    
    @classmethod
    def showFullScreen(cls, self):
        'showFullScreen(self)'
        pass
    
    @classmethod
    def showMaximized(cls, self):
        'showMaximized(self)'
        pass
    
    @classmethod
    def showMinimized(cls, self):
        'showMinimized(self)'
        pass
    
    @classmethod
    def showNormal(cls, self):
        'showNormal(self)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def sizeIncrement(cls, self):
        'sizeIncrement(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    
    @classmethod
    def tabletEvent(cls, self, QTabletEvent):
        'tabletEvent(self, QTabletEvent)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def title(cls, self):
        'title(self) -> str'
        return ''
    
    @classmethod
    def touchEvent(cls, self, QTouchEvent):
        'touchEvent(self, QTouchEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def transientParent(cls, self):
        'transientParent(self) -> QWindow'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> Qt.WindowType'
        pass
    
    @classmethod
    def unsetCursor(cls, self):
        'unsetCursor(self)'
        pass
    
    @classmethod
    def update(cls, self, QRegion):
        'update(self, QRect)\nupdate(self, QRegion)\nupdate(self)'
        pass
    
    @classmethod
    def updateBehavior(cls, self):
        'updateBehavior(self) -> QOpenGLWindow.UpdateBehavior'
        pass
    
    @classmethod
    def visibility(cls, self):
        'visibility(self) -> QWindow.Visibility'
        pass
    
    @classmethod
    def wheelEvent(cls, self, QWheelEvent):
        'wheelEvent(self, QWheelEvent)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    
    @classmethod
    def winId(cls, self):
        'winId(self) -> sip.voidptr'
        pass
    
    @classmethod
    def windowState(cls, self):
        'windowState(self) -> Qt.WindowState'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QPageLayout(_mod_sip.simplewrapper):
    'QPageLayout()\nQPageLayout(QPageSize, QPageLayout.Orientation, QMarginsF, units: QPageLayout.Unit = QPageLayout.Point, minMargins: QMarginsF = QMarginsF(0,0,0,0))\nQPageLayout(QPageLayout)'
    Cicero = Unit()
    Didot = Unit()
    FullPageMode = Mode()
    Inch = Unit()
    Landscape = Orientation()
    Millimeter = Unit()
    Mode = Mode()
    Orientation = Orientation()
    Pica = Unit()
    Point = Unit()
    Portrait = Orientation()
    StandardMode = Mode()
    Unit = Unit()
    __class__ = QPageLayout
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QPageSize, QPageLayoutOrientation, QMarginsF, units: QPageLayout.Unit=QPageLayout.Point, minMargins: QMarginsF=QMarginsF(0,0,0,0)):
        'QPageLayout()\nQPageLayout(QPageSize, QPageLayout.Orientation, QMarginsF, units: QPageLayout.Unit = QPageLayout.Point, minMargins: QMarginsF = QMarginsF(0,0,0,0))\nQPageLayout(QPageLayout)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def fullRect(cls, self, QPageLayoutUnit):
        'fullRect(self) -> QRectF\nfullRect(self, QPageLayout.Unit) -> QRectF'
        pass
    
    @classmethod
    def fullRectPixels(cls, self, int):
        'fullRectPixels(self, int) -> QRect'
        pass
    
    @classmethod
    def fullRectPoints(cls, self):
        'fullRectPoints(self) -> QRect'
        pass
    
    @classmethod
    def isEquivalentTo(cls, self, QPageLayout):
        'isEquivalentTo(self, QPageLayout) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def margins(cls, self, QPageLayoutUnit):
        'margins(self) -> QMarginsF\nmargins(self, QPageLayout.Unit) -> QMarginsF'
        pass
    
    @classmethod
    def marginsPixels(cls, self, int):
        'marginsPixels(self, int) -> QMargins'
        pass
    
    @classmethod
    def marginsPoints(cls, self):
        'marginsPoints(self) -> QMargins'
        pass
    
    @classmethod
    def maximumMargins(cls, self):
        'maximumMargins(self) -> QMarginsF'
        pass
    
    @classmethod
    def minimumMargins(cls, self):
        'minimumMargins(self) -> QMarginsF'
        pass
    
    @classmethod
    def mode(cls, self):
        'mode(self) -> QPageLayout.Mode'
        pass
    
    @classmethod
    def orientation(cls, self):
        'orientation(self) -> QPageLayout.Orientation'
        pass
    
    @classmethod
    def pageSize(cls, self):
        'pageSize(self) -> QPageSize'
        pass
    
    @classmethod
    def paintRect(cls, self, QPageLayoutUnit):
        'paintRect(self) -> QRectF\npaintRect(self, QPageLayout.Unit) -> QRectF'
        pass
    
    @classmethod
    def paintRectPixels(cls, self, int):
        'paintRectPixels(self, int) -> QRect'
        pass
    
    @classmethod
    def paintRectPoints(cls, self):
        'paintRectPoints(self) -> QRect'
        pass
    
    @classmethod
    def setBottomMargin(cls, self, float):
        'setBottomMargin(self, float) -> bool'
        return True
    
    @classmethod
    def setLeftMargin(cls, self, float):
        'setLeftMargin(self, float) -> bool'
        return True
    
    @classmethod
    def setMargins(cls, self, QMarginsF):
        'setMargins(self, QMarginsF) -> bool'
        return True
    
    @classmethod
    def setMinimumMargins(cls, self, QMarginsF):
        'setMinimumMargins(self, QMarginsF)'
        pass
    
    @classmethod
    def setMode(cls, self, QPageLayoutMode):
        'setMode(self, QPageLayout.Mode)'
        pass
    
    @classmethod
    def setOrientation(cls, self, QPageLayoutOrientation):
        'setOrientation(self, QPageLayout.Orientation)'
        pass
    
    @classmethod
    def setPageSize(cls, self, QPageSize, minMargins: QMarginsF=QMarginsF(0,0,0,0)):
        'setPageSize(self, QPageSize, minMargins: QMarginsF = QMarginsF(0,0,0,0))'
        pass
    
    @classmethod
    def setRightMargin(cls, self, float):
        'setRightMargin(self, float) -> bool'
        return True
    
    @classmethod
    def setTopMargin(cls, self, float):
        'setTopMargin(self, float) -> bool'
        return True
    
    @classmethod
    def setUnits(cls, self, QPageLayoutUnit):
        'setUnits(self, QPageLayout.Unit)'
        pass
    
    @classmethod
    def swap(cls, self, QPageLayout):
        'swap(self, QPageLayout)'
        pass
    
    @classmethod
    def units(cls, self):
        'units(self) -> QPageLayout.Unit'
        pass
    

class QPageSize(_mod_sip.simplewrapper):
    "QPageSize()\nQPageSize(QPageSize.PageSizeId)\nQPageSize(QSize, name: str = '', matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch)\nQPageSize(QSizeF, QPageSize.Unit, name: str = '', matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch)\nQPageSize(QPageSize)"
    A0 = PageSizeId()
    A1 = PageSizeId()
    A10 = PageSizeId()
    A2 = PageSizeId()
    A3 = PageSizeId()
    A3Extra = PageSizeId()
    A4 = PageSizeId()
    A4Extra = PageSizeId()
    A4Plus = PageSizeId()
    A4Small = PageSizeId()
    A5 = PageSizeId()
    A5Extra = PageSizeId()
    A6 = PageSizeId()
    A7 = PageSizeId()
    A8 = PageSizeId()
    A9 = PageSizeId()
    AnsiA = PageSizeId()
    AnsiB = PageSizeId()
    AnsiC = PageSizeId()
    AnsiD = PageSizeId()
    AnsiE = PageSizeId()
    ArchA = PageSizeId()
    ArchB = PageSizeId()
    ArchC = PageSizeId()
    ArchD = PageSizeId()
    ArchE = PageSizeId()
    B0 = PageSizeId()
    B1 = PageSizeId()
    B10 = PageSizeId()
    B2 = PageSizeId()
    B3 = PageSizeId()
    B4 = PageSizeId()
    B5 = PageSizeId()
    B5Extra = PageSizeId()
    B6 = PageSizeId()
    B7 = PageSizeId()
    B8 = PageSizeId()
    B9 = PageSizeId()
    C5E = PageSizeId()
    Cicero = Unit()
    Comm10E = PageSizeId()
    Custom = PageSizeId()
    DLE = PageSizeId()
    Didot = Unit()
    DoublePostcard = PageSizeId()
    Envelope10 = PageSizeId()
    Envelope11 = PageSizeId()
    Envelope12 = PageSizeId()
    Envelope14 = PageSizeId()
    Envelope9 = PageSizeId()
    EnvelopeB4 = PageSizeId()
    EnvelopeB5 = PageSizeId()
    EnvelopeB6 = PageSizeId()
    EnvelopeC0 = PageSizeId()
    EnvelopeC1 = PageSizeId()
    EnvelopeC2 = PageSizeId()
    EnvelopeC3 = PageSizeId()
    EnvelopeC4 = PageSizeId()
    EnvelopeC5 = PageSizeId()
    EnvelopeC6 = PageSizeId()
    EnvelopeC65 = PageSizeId()
    EnvelopeC7 = PageSizeId()
    EnvelopeChou3 = PageSizeId()
    EnvelopeChou4 = PageSizeId()
    EnvelopeDL = PageSizeId()
    EnvelopeInvite = PageSizeId()
    EnvelopeItalian = PageSizeId()
    EnvelopeKaku2 = PageSizeId()
    EnvelopeKaku3 = PageSizeId()
    EnvelopeMonarch = PageSizeId()
    EnvelopePersonal = PageSizeId()
    EnvelopePrc1 = PageSizeId()
    EnvelopePrc10 = PageSizeId()
    EnvelopePrc2 = PageSizeId()
    EnvelopePrc3 = PageSizeId()
    EnvelopePrc4 = PageSizeId()
    EnvelopePrc5 = PageSizeId()
    EnvelopePrc6 = PageSizeId()
    EnvelopePrc7 = PageSizeId()
    EnvelopePrc8 = PageSizeId()
    EnvelopePrc9 = PageSizeId()
    EnvelopeYou4 = PageSizeId()
    ExactMatch = SizeMatchPolicy()
    Executive = PageSizeId()
    ExecutiveStandard = PageSizeId()
    FanFoldGerman = PageSizeId()
    FanFoldGermanLegal = PageSizeId()
    FanFoldUS = PageSizeId()
    Folio = PageSizeId()
    FuzzyMatch = SizeMatchPolicy()
    FuzzyOrientationMatch = SizeMatchPolicy()
    Imperial10x11 = PageSizeId()
    Imperial10x13 = PageSizeId()
    Imperial10x14 = PageSizeId()
    Imperial12x11 = PageSizeId()
    Imperial15x11 = PageSizeId()
    Imperial7x9 = PageSizeId()
    Imperial8x10 = PageSizeId()
    Imperial9x11 = PageSizeId()
    Imperial9x12 = PageSizeId()
    Inch = Unit()
    JisB0 = PageSizeId()
    JisB1 = PageSizeId()
    JisB10 = PageSizeId()
    JisB2 = PageSizeId()
    JisB3 = PageSizeId()
    JisB4 = PageSizeId()
    JisB5 = PageSizeId()
    JisB6 = PageSizeId()
    JisB7 = PageSizeId()
    JisB8 = PageSizeId()
    JisB9 = PageSizeId()
    LastPageSize = PageSizeId()
    Ledger = PageSizeId()
    Legal = PageSizeId()
    LegalExtra = PageSizeId()
    Letter = PageSizeId()
    LetterExtra = PageSizeId()
    LetterPlus = PageSizeId()
    LetterSmall = PageSizeId()
    Millimeter = Unit()
    NPageSize = PageSizeId()
    NPaperSize = PageSizeId()
    Note = PageSizeId()
    PageSizeId = PageSizeId()
    Pica = Unit()
    Point = Unit()
    Postcard = PageSizeId()
    Prc16K = PageSizeId()
    Prc32K = PageSizeId()
    Prc32KBig = PageSizeId()
    Quarto = PageSizeId()
    SizeMatchPolicy = SizeMatchPolicy()
    Statement = PageSizeId()
    SuperA = PageSizeId()
    SuperB = PageSizeId()
    Tabloid = PageSizeId()
    TabloidExtra = PageSizeId()
    Unit = Unit()
    __class__ = QPageSize
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QSizeF, QPageSizeUnit, name: str='', matchPolicy: QPageSize.SizeMatchPolicy=QPageSize.FuzzyMatch):
        "QPageSize()\nQPageSize(QPageSize.PageSizeId)\nQPageSize(QSize, name: str = '', matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch)\nQPageSize(QSizeF, QPageSize.Unit, name: str = '', matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch)\nQPageSize(QPageSize)"
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def definitionSize(cls, QPageSizePageSizeId):
        'definitionSize(self) -> QSizeF\ndefinitionSize(QPageSize.PageSizeId) -> QSizeF'
        pass
    
    @classmethod
    def definitionUnits(cls, QPageSizePageSizeId):
        'definitionUnits(self) -> QPageSize.Unit\ndefinitionUnits(QPageSize.PageSizeId) -> QPageSize.Unit'
        pass
    
    @classmethod
    def id(cls, QSizeF, QPageSizeUnit, matchPolicy: QPageSize.SizeMatchPolicy=QPageSize.FuzzyMatch):
        'id(self) -> QPageSize.PageSizeId\nid(QSize, matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch) -> QPageSize.PageSizeId\nid(QSizeF, QPageSize.Unit, matchPolicy: QPageSize.SizeMatchPolicy = QPageSize.FuzzyMatch) -> QPageSize.PageSizeId\nid(int) -> QPageSize.PageSizeId'
        pass
    
    @classmethod
    def isEquivalentTo(cls, self, QPageSize):
        'isEquivalentTo(self, QPageSize) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def key(cls, QPageSizePageSizeId):
        'key(self) -> str\nkey(QPageSize.PageSizeId) -> str'
        return ''
    
    @classmethod
    def name(cls, QPageSizePageSizeId):
        'name(self) -> str\nname(QPageSize.PageSizeId) -> str'
        return ''
    
    @classmethod
    def rect(cls, self, QPageSizeUnit):
        'rect(self, QPageSize.Unit) -> QRectF'
        pass
    
    @classmethod
    def rectPixels(cls, self, int):
        'rectPixels(self, int) -> QRect'
        pass
    
    @classmethod
    def rectPoints(cls, self):
        'rectPoints(self) -> QRect'
        pass
    
    @classmethod
    def size(cls, QPageSizePageSizeId, QPageSizeUnit):
        'size(self, QPageSize.Unit) -> QSizeF\nsize(QPageSize.PageSizeId, QPageSize.Unit) -> QSizeF'
        pass
    
    @classmethod
    def sizePixels(cls, QPageSizePageSizeId, int):
        'sizePixels(self, int) -> QSize\nsizePixels(QPageSize.PageSizeId, int) -> QSize'
        pass
    
    @classmethod
    def sizePoints(cls, QPageSizePageSizeId):
        'sizePoints(self) -> QSize\nsizePoints(QPageSize.PageSizeId) -> QSize'
        pass
    
    @classmethod
    def swap(cls, self, QPageSize):
        'swap(self, QPageSize)'
        pass
    
    @classmethod
    def windowsId(cls, QPageSizePageSizeId):
        'windowsId(self) -> int\nwindowsId(QPageSize.PageSizeId) -> int'
        return 1
    

class QPagedPaintDevice(QPaintDevice):
    'QPagedPaintDevice()'
    A0 = PageSize()
    A1 = PageSize()
    A10 = PageSize()
    A2 = PageSize()
    A3 = PageSize()
    A3Extra = PageSize()
    A4 = PageSize()
    A4Extra = PageSize()
    A4Plus = PageSize()
    A4Small = PageSize()
    A5 = PageSize()
    A5Extra = PageSize()
    A6 = PageSize()
    A7 = PageSize()
    A8 = PageSize()
    A9 = PageSize()
    AnsiA = PageSize()
    AnsiB = PageSize()
    AnsiC = PageSize()
    AnsiD = PageSize()
    AnsiE = PageSize()
    ArchA = PageSize()
    ArchB = PageSize()
    ArchC = PageSize()
    ArchD = PageSize()
    ArchE = PageSize()
    B0 = PageSize()
    B1 = PageSize()
    B10 = PageSize()
    B2 = PageSize()
    B3 = PageSize()
    B4 = PageSize()
    B5 = PageSize()
    B5Extra = PageSize()
    B6 = PageSize()
    B7 = PageSize()
    B8 = PageSize()
    B9 = PageSize()
    C5E = PageSize()
    Comm10E = PageSize()
    Custom = PageSize()
    DLE = PageSize()
    DoublePostcard = PageSize()
    Envelope10 = PageSize()
    Envelope11 = PageSize()
    Envelope12 = PageSize()
    Envelope14 = PageSize()
    Envelope9 = PageSize()
    EnvelopeB4 = PageSize()
    EnvelopeB5 = PageSize()
    EnvelopeB6 = PageSize()
    EnvelopeC0 = PageSize()
    EnvelopeC1 = PageSize()
    EnvelopeC2 = PageSize()
    EnvelopeC3 = PageSize()
    EnvelopeC4 = PageSize()
    EnvelopeC5 = PageSize()
    EnvelopeC6 = PageSize()
    EnvelopeC65 = PageSize()
    EnvelopeC7 = PageSize()
    EnvelopeChou3 = PageSize()
    EnvelopeChou4 = PageSize()
    EnvelopeDL = PageSize()
    EnvelopeInvite = PageSize()
    EnvelopeItalian = PageSize()
    EnvelopeKaku2 = PageSize()
    EnvelopeKaku3 = PageSize()
    EnvelopeMonarch = PageSize()
    EnvelopePersonal = PageSize()
    EnvelopePrc1 = PageSize()
    EnvelopePrc10 = PageSize()
    EnvelopePrc2 = PageSize()
    EnvelopePrc3 = PageSize()
    EnvelopePrc4 = PageSize()
    EnvelopePrc5 = PageSize()
    EnvelopePrc6 = PageSize()
    EnvelopePrc7 = PageSize()
    EnvelopePrc8 = PageSize()
    EnvelopePrc9 = PageSize()
    EnvelopeYou4 = PageSize()
    Executive = PageSize()
    ExecutiveStandard = PageSize()
    FanFoldGerman = PageSize()
    FanFoldGermanLegal = PageSize()
    FanFoldUS = PageSize()
    Folio = PageSize()
    Imperial10x11 = PageSize()
    Imperial10x13 = PageSize()
    Imperial10x14 = PageSize()
    Imperial12x11 = PageSize()
    Imperial15x11 = PageSize()
    Imperial7x9 = PageSize()
    Imperial8x10 = PageSize()
    Imperial9x11 = PageSize()
    Imperial9x12 = PageSize()
    JisB0 = PageSize()
    JisB1 = PageSize()
    JisB10 = PageSize()
    JisB2 = PageSize()
    JisB3 = PageSize()
    JisB4 = PageSize()
    JisB5 = PageSize()
    JisB6 = PageSize()
    JisB7 = PageSize()
    JisB8 = PageSize()
    JisB9 = PageSize()
    LastPageSize = PageSize()
    Ledger = PageSize()
    Legal = PageSize()
    LegalExtra = PageSize()
    Letter = PageSize()
    LetterExtra = PageSize()
    LetterPlus = PageSize()
    LetterSmall = PageSize()
    Margins = Margins()
    NPaperSize = PageSize()
    Note = PageSize()
    PageSize = PageSize()
    Postcard = PageSize()
    Prc16K = PageSize()
    Prc32K = PageSize()
    Prc32KBig = PageSize()
    Quarto = PageSize()
    Statement = PageSize()
    SuperA = PageSize()
    SuperB = PageSize()
    Tabloid = PageSize()
    TabloidExtra = PageSize()
    __class__ = QPagedPaintDevice
    __dict__ = {}
    def __init__(self):
        'QPagedPaintDevice()'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def margins(cls, self):
        'margins(self) -> QPagedPaintDevice.Margins'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def newPage(cls, self):
        'newPage(self) -> bool'
        return True
    
    @classmethod
    def pageLayout(cls, self):
        'pageLayout(self) -> QPageLayout'
        pass
    
    @classmethod
    def pageSize(cls, self):
        'pageSize(self) -> QPagedPaintDevice.PageSize'
        pass
    
    @classmethod
    def pageSizeMM(cls, self):
        'pageSizeMM(self) -> QSizeF'
        pass
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def setMargins(cls, self, QPagedPaintDeviceMargins):
        'setMargins(self, QPagedPaintDevice.Margins)'
        pass
    
    @classmethod
    def setPageLayout(cls, self, QPageLayout):
        'setPageLayout(self, QPageLayout) -> bool'
        return True
    
    @classmethod
    def setPageMargins(cls, self, QMarginsF, QPageLayoutUnit):
        'setPageMargins(self, QMarginsF) -> bool\nsetPageMargins(self, QMarginsF, QPageLayout.Unit) -> bool'
        return True
    
    @classmethod
    def setPageOrientation(cls, self, QPageLayoutOrientation):
        'setPageOrientation(self, QPageLayout.Orientation) -> bool'
        return True
    
    @classmethod
    def setPageSize(cls, self, QPagedPaintDevicePageSize):
        'setPageSize(self, QPagedPaintDevice.PageSize)\nsetPageSize(self, QPageSize) -> bool'
        pass
    
    @classmethod
    def setPageSizeMM(cls, self, QSizeF):
        'setPageSizeMM(self, QSizeF)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QPaintDevice(_mod_sip.simplewrapper):
    'QPaintDevice()'
    PaintDeviceMetric = PaintDeviceMetric()
    PdmDepth = PaintDeviceMetric()
    PdmDevicePixelRatio = PaintDeviceMetric()
    PdmDevicePixelRatioScaled = PaintDeviceMetric()
    PdmDpiX = PaintDeviceMetric()
    PdmDpiY = PaintDeviceMetric()
    PdmHeight = PaintDeviceMetric()
    PdmHeightMM = PaintDeviceMetric()
    PdmNumColors = PaintDeviceMetric()
    PdmPhysicalDpiX = PaintDeviceMetric()
    PdmPhysicalDpiY = PaintDeviceMetric()
    PdmWidth = PaintDeviceMetric()
    PdmWidthMM = PaintDeviceMetric()
    __class__ = QPaintDevice
    __dict__ = {}
    def __init__(self):
        'QPaintDevice()'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QPaintDeviceWindow(QWindow,QPaintDevice):
    __class__ = QPaintDeviceWindow
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def alert(cls, self, int):
        'alert(self, int)'
        pass
    
    @classmethod
    def baseSize(cls, self):
        'baseSize(self) -> QSize'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def close(cls, self):
        'close(self) -> bool'
        return True
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def contentOrientation(cls, self):
        'contentOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self)'
        pass
    
    @classmethod
    def cursor(cls, self):
        'cursor(self) -> QCursor'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exposeEvent(cls, self, QExposeEvent):
        'exposeEvent(self, QExposeEvent)'
        pass
    
    @classmethod
    def filePath(cls, self):
        'filePath(self) -> str'
        return ''
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.WindowFlags'
        pass
    
    @classmethod
    def focusInEvent(cls, self, QFocusEvent):
        'focusInEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def focusObject(cls, self):
        'focusObject(self) -> QObject'
        pass
    
    @classmethod
    def focusOutEvent(cls, self, QFocusEvent):
        'focusOutEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def frameGeometry(cls, self):
        'frameGeometry(self) -> QRect'
        pass
    
    @classmethod
    def frameMargins(cls, self):
        'frameMargins(self) -> QMargins'
        pass
    
    @classmethod
    def framePosition(cls, self):
        'framePosition(self) -> QPoint'
        pass
    
    @classmethod
    def fromWinId(cls, sipvoidptr):
        'fromWinId(sip.voidptr) -> QWindow'
        pass
    
    @classmethod
    def geometry(cls, self):
        'geometry(self) -> QRect'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def hide(cls, self):
        'hide(self)'
        pass
    
    @classmethod
    def hideEvent(cls, self, QHideEvent):
        'hideEvent(self, QHideEvent)'
        pass
    
    @classmethod
    def icon(cls, self):
        'icon(self) -> QIcon'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def isAncestorOf(cls, self, QWindow, mode: QWindow.AncestorMode=QWindow.IncludeTransients):
        'isAncestorOf(self, QWindow, mode: QWindow.AncestorMode = QWindow.IncludeTransients) -> bool'
        return True
    
    @classmethod
    def isExposed(cls, self):
        'isExposed(self) -> bool'
        return True
    
    @classmethod
    def isModal(cls, self):
        'isModal(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isTopLevel(cls, self):
        'isTopLevel(self) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyPressEvent(cls, self, QKeyEvent):
        'keyPressEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def keyReleaseEvent(cls, self, QKeyEvent):
        'keyReleaseEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def lower(cls, self):
        'lower(self)'
        pass
    
    @classmethod
    def mapFromGlobal(cls, self, QPoint):
        'mapFromGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mapToGlobal(cls, self, QPoint):
        'mapToGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QRegion'
        pass
    
    @classmethod
    def maximumHeight(cls, self):
        'maximumHeight(self) -> int'
        return 1
    
    @classmethod
    def maximumSize(cls, self):
        'maximumSize(self) -> QSize'
        pass
    
    @classmethod
    def maximumWidth(cls, self):
        'maximumWidth(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def minimumHeight(cls, self):
        'minimumHeight(self) -> int'
        return 1
    
    @classmethod
    def minimumSize(cls, self):
        'minimumSize(self) -> QSize'
        pass
    
    @classmethod
    def minimumWidth(cls, self):
        'minimumWidth(self) -> int'
        return 1
    
    @classmethod
    def modality(cls, self):
        'modality(self) -> Qt.WindowModality'
        pass
    
    @classmethod
    def mouseDoubleClickEvent(cls, self, QMouseEvent):
        'mouseDoubleClickEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseMoveEvent(cls, self, QMouseEvent):
        'mouseMoveEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mousePressEvent(cls, self, QMouseEvent):
        'mousePressEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseReleaseEvent(cls, self, QMouseEvent):
        'mouseReleaseEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def moveEvent(cls, self, QMoveEvent):
        'moveEvent(self, QMoveEvent)'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintEvent(cls, self, QPaintEvent):
        'paintEvent(self, QPaintEvent)'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def parent(cls, self, QWindowAncestorMode):
        'parent(self) -> QWindow\nparent(self, QWindow.AncestorMode) -> QWindow'
        pass
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPoint'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def raise_(cls, self):
        'raise_(self)'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reportContentOrientationChange(cls, self, QtScreenOrientation):
        'reportContentOrientationChange(self, Qt.ScreenOrientation)'
        pass
    
    @classmethod
    def requestActivate(cls, self):
        'requestActivate(self)'
        pass
    
    @classmethod
    def requestUpdate(cls, self):
        'requestUpdate(self)'
        pass
    
    @classmethod
    def requestedFormat(cls, self):
        'requestedFormat(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def resize(cls, self, int, int_):
        'resize(self, QSize)\nresize(self, int, int)'
        pass
    
    @classmethod
    def resizeEvent(cls, self, QResizeEvent):
        'resizeEvent(self, QResizeEvent)'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBaseSize(cls, self, QSize):
        'setBaseSize(self, QSize)'
        pass
    
    @classmethod
    def setCursor(cls, self, UnionQCursor=None, QtCursorShape=None):
        'setCursor(self, Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def setFilePath(cls, self, str):
        'setFilePath(self, str)'
        pass
    
    @classmethod
    def setFlag(cls, self, QtWindowType, on: bool=True):
        'setFlag(self, Qt.WindowType, on: bool = True)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQtWindowFlags=None, QtWindowType=None):
        'setFlags(self, Union[Qt.WindowFlags, Qt.WindowType])'
        pass
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setFramePosition(cls, self, QPoint):
        'setFramePosition(self, QPoint)'
        pass
    
    @classmethod
    def setGeometry(cls, self, int, int_, int_1, int_2):
        'setGeometry(self, int, int, int, int)\nsetGeometry(self, QRect)'
        pass
    
    @classmethod
    def setHeight(cls, self, int):
        'setHeight(self, int)'
        pass
    
    @classmethod
    def setIcon(cls, self, QIcon):
        'setIcon(self, QIcon)'
        pass
    
    @classmethod
    def setKeyboardGrabEnabled(cls, self, bool):
        'setKeyboardGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setMask(cls, self, QRegion):
        'setMask(self, QRegion)'
        pass
    
    @classmethod
    def setMaximumHeight(cls, self, int):
        'setMaximumHeight(self, int)'
        pass
    
    @classmethod
    def setMaximumSize(cls, self, QSize):
        'setMaximumSize(self, QSize)'
        pass
    
    @classmethod
    def setMaximumWidth(cls, self, int):
        'setMaximumWidth(self, int)'
        pass
    
    @classmethod
    def setMinimumHeight(cls, self, int):
        'setMinimumHeight(self, int)'
        pass
    
    @classmethod
    def setMinimumSize(cls, self, QSize):
        'setMinimumSize(self, QSize)'
        pass
    
    @classmethod
    def setMinimumWidth(cls, self, int):
        'setMinimumWidth(self, int)'
        pass
    
    @classmethod
    def setModality(cls, self, QtWindowModality):
        'setModality(self, Qt.WindowModality)'
        pass
    
    @classmethod
    def setMouseGrabEnabled(cls, self, bool):
        'setMouseGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setParent(cls, self, QWindow):
        'setParent(self, QWindow)'
        pass
    
    @classmethod
    def setPosition(cls, self, int, int_):
        'setPosition(self, QPoint)\nsetPosition(self, int, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def setSizeIncrement(cls, self, QSize):
        'setSizeIncrement(self, QSize)'
        pass
    
    @classmethod
    def setSurfaceType(cls, self, QSurfaceSurfaceType):
        'setSurfaceType(self, QSurface.SurfaceType)'
        pass
    
    @classmethod
    def setTitle(cls, self, str):
        'setTitle(self, str)'
        pass
    
    @classmethod
    def setTransientParent(cls, self, QWindow):
        'setTransientParent(self, QWindow)'
        pass
    
    @classmethod
    def setVisibility(cls, self, QWindowVisibility):
        'setVisibility(self, QWindow.Visibility)'
        pass
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def setWidth(cls, self, int):
        'setWidth(self, int)'
        pass
    
    @classmethod
    def setWindowState(cls, self, QtWindowState):
        'setWindowState(self, Qt.WindowState)'
        pass
    
    @classmethod
    def setX(cls, self, int):
        'setX(self, int)'
        pass
    
    @classmethod
    def setY(cls, self, int):
        'setY(self, int)'
        pass
    
    @classmethod
    def show(cls, self):
        'show(self)'
        pass
    
    @classmethod
    def showEvent(cls, self, QShowEvent):
        'showEvent(self, QShowEvent)'
        pass
    
    @classmethod
    def showFullScreen(cls, self):
        'showFullScreen(self)'
        pass
    
    @classmethod
    def showMaximized(cls, self):
        'showMaximized(self)'
        pass
    
    @classmethod
    def showMinimized(cls, self):
        'showMinimized(self)'
        pass
    
    @classmethod
    def showNormal(cls, self):
        'showNormal(self)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def sizeIncrement(cls, self):
        'sizeIncrement(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    
    @classmethod
    def tabletEvent(cls, self, QTabletEvent):
        'tabletEvent(self, QTabletEvent)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def title(cls, self):
        'title(self) -> str'
        return ''
    
    @classmethod
    def touchEvent(cls, self, QTouchEvent):
        'touchEvent(self, QTouchEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def transientParent(cls, self):
        'transientParent(self) -> QWindow'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> Qt.WindowType'
        pass
    
    @classmethod
    def unsetCursor(cls, self):
        'unsetCursor(self)'
        pass
    
    @classmethod
    def update(cls, self, QRegion):
        'update(self, QRect)\nupdate(self, QRegion)\nupdate(self)'
        pass
    
    @classmethod
    def visibility(cls, self):
        'visibility(self) -> QWindow.Visibility'
        pass
    
    @classmethod
    def wheelEvent(cls, self, QWheelEvent):
        'wheelEvent(self, QWheelEvent)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    
    @classmethod
    def winId(cls, self):
        'winId(self) -> sip.voidptr'
        pass
    
    @classmethod
    def windowState(cls, self):
        'windowState(self) -> Qt.WindowState'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QPaintEngine(_mod_sip.simplewrapper):
    'QPaintEngine(features: Union[QPaintEngine.PaintEngineFeatures, QPaintEngine.PaintEngineFeature] = QPaintEngine.PaintEngineFeatures())'
    AllDirty = DirtyFlag()
    AllFeatures = PaintEngineFeature()
    AlphaBlend = PaintEngineFeature()
    Antialiasing = PaintEngineFeature()
    BlendModes = PaintEngineFeature()
    Blitter = Type()
    BrushStroke = PaintEngineFeature()
    ConicalGradientFill = PaintEngineFeature()
    ConstantOpacity = PaintEngineFeature()
    ConvexMode = PolygonDrawMode()
    CoreGraphics = Type()
    Direct2D = Type()
    Direct3D = Type()
    DirtyBackground = DirtyFlag()
    DirtyBackgroundMode = DirtyFlag()
    DirtyBrush = DirtyFlag()
    DirtyBrushOrigin = DirtyFlag()
    DirtyClipEnabled = DirtyFlag()
    DirtyClipPath = DirtyFlag()
    DirtyClipRegion = DirtyFlag()
    DirtyCompositionMode = DirtyFlag()
    DirtyFlag = DirtyFlag()
    DirtyFlags = DirtyFlags()
    DirtyFont = DirtyFlag()
    DirtyHints = DirtyFlag()
    DirtyOpacity = DirtyFlag()
    DirtyPen = DirtyFlag()
    DirtyTransform = DirtyFlag()
    LinearGradientFill = PaintEngineFeature()
    MacPrinter = Type()
    MaskedBrush = PaintEngineFeature()
    MaxUser = Type()
    ObjectBoundingModeGradients = PaintEngineFeature()
    OddEvenMode = PolygonDrawMode()
    OpenGL = Type()
    OpenGL2 = Type()
    OpenVG = Type()
    PaintBuffer = Type()
    PaintEngineFeature = PaintEngineFeature()
    PaintEngineFeatures = PaintEngineFeatures()
    PaintOutsidePaintEvent = PaintEngineFeature()
    PainterPaths = PaintEngineFeature()
    PatternBrush = PaintEngineFeature()
    PatternTransform = PaintEngineFeature()
    Pdf = Type()
    PerspectiveTransform = PaintEngineFeature()
    Picture = Type()
    PixmapTransform = PaintEngineFeature()
    PolygonDrawMode = PolygonDrawMode()
    PolylineMode = PolygonDrawMode()
    PorterDuff = PaintEngineFeature()
    PostScript = Type()
    PrimitiveTransform = PaintEngineFeature()
    QWindowSystem = Type()
    QuickDraw = Type()
    RadialGradientFill = PaintEngineFeature()
    Raster = Type()
    RasterOpModes = PaintEngineFeature()
    SVG = Type()
    Type = Type()
    User = Type()
    WindingMode = PolygonDrawMode()
    Windows = Type()
    X11 = Type()
    __class__ = QPaintEngine
    __dict__ = {}
    def __init__(self, features: Union[QPaintEngine.PaintEngineFeatures,QPaintEngine.PaintEngineFeature]=QPaintEngine.PaintEngineFeatures()):
        'QPaintEngine(features: Union[QPaintEngine.PaintEngineFeatures, QPaintEngine.PaintEngineFeature] = QPaintEngine.PaintEngineFeatures())'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def begin(cls, self, QPaintDevice):
        'begin(self, QPaintDevice) -> bool'
        return True
    
    @classmethod
    def drawEllipse(cls, self, QRectF):
        'drawEllipse(self, QRectF)\ndrawEllipse(self, QRect)'
        pass
    
    @classmethod
    def drawImage(cls, self, QRectF, QImage, QRectF_, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'drawImage(self, QRectF, QImage, QRectF, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)'
        pass
    
    @classmethod
    def drawLines(cls, self, QLineF):
        'drawLines(self, QLine)\ndrawLines(self, QLineF)'
        pass
    
    @classmethod
    def drawPath(cls, self, QPainterPath):
        'drawPath(self, QPainterPath)'
        pass
    
    @classmethod
    def drawPixmap(cls, self, QRectF, QPixmap, QRectF_):
        'drawPixmap(self, QRectF, QPixmap, QRectF)'
        pass
    
    @classmethod
    def drawPoints(cls, self, UnionQPointF=None, QPoint=None):
        'drawPoints(self, Union[QPointF, QPoint])\ndrawPoints(self, QPoint)'
        pass
    
    @classmethod
    def drawPolygon(cls, self, UnionQPointF=None, QPoint=None, QPaintEnginePolygonDrawMode=None):
        'drawPolygon(self, Union[QPointF, QPoint], QPaintEngine.PolygonDrawMode)\ndrawPolygon(self, QPoint, QPaintEngine.PolygonDrawMode)'
        pass
    
    @classmethod
    def drawRects(cls, self, QRectF):
        'drawRects(self, QRect)\ndrawRects(self, QRectF)'
        pass
    
    @classmethod
    def drawTextItem(cls, self, UnionQPointF=None, QPoint=None, QTextItem=None):
        'drawTextItem(self, Union[QPointF, QPoint], QTextItem)'
        pass
    
    @classmethod
    def drawTiledPixmap(cls, self, QRectF, QPixmap, UnionQPointF=None, QPoint=None):
        'drawTiledPixmap(self, QRectF, QPixmap, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> bool'
        return True
    
    @classmethod
    def hasFeature(cls, self, UnionQPaintEnginePaintEngineFeatures=None, QPaintEnginePaintEngineFeature=None):
        'hasFeature(self, Union[QPaintEngine.PaintEngineFeatures, QPaintEngine.PaintEngineFeature]) -> bool'
        return True
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def paintDevice(cls, self):
        'paintDevice(self) -> QPaintDevice'
        pass
    
    @classmethod
    def painter(cls, self):
        'painter(self) -> QPainter'
        pass
    
    @classmethod
    def setActive(cls, self, bool):
        'setActive(self, bool)'
        pass
    
    @classmethod
    def setPaintDevice(cls, self, QPaintDevice):
        'setPaintDevice(self, QPaintDevice)'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QPaintEngine.Type'
        pass
    
    @classmethod
    def updateState(cls, self, QPaintEngineState):
        'updateState(self, QPaintEngineState)'
        pass
    

class QPaintEngineState(_mod_sip.simplewrapper):
    'QPaintEngineState()\nQPaintEngineState(QPaintEngineState)'
    __class__ = QPaintEngineState
    __dict__ = {}
    def __init__(self, QPaintEngineState):
        'QPaintEngineState()\nQPaintEngineState(QPaintEngineState)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def backgroundBrush(cls, self):
        'backgroundBrush(self) -> QBrush'
        pass
    
    @classmethod
    def backgroundMode(cls, self):
        'backgroundMode(self) -> Qt.BGMode'
        pass
    
    @classmethod
    def brush(cls, self):
        'brush(self) -> QBrush'
        pass
    
    @classmethod
    def brushNeedsResolving(cls, self):
        'brushNeedsResolving(self) -> bool'
        return True
    
    @classmethod
    def brushOrigin(cls, self):
        'brushOrigin(self) -> QPointF'
        pass
    
    @classmethod
    def clipOperation(cls, self):
        'clipOperation(self) -> Qt.ClipOperation'
        pass
    
    @classmethod
    def clipPath(cls, self):
        'clipPath(self) -> QPainterPath'
        pass
    
    @classmethod
    def clipRegion(cls, self):
        'clipRegion(self) -> QRegion'
        pass
    
    @classmethod
    def compositionMode(cls, self):
        'compositionMode(self) -> QPainter.CompositionMode'
        pass
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def isClipEnabled(cls, self):
        'isClipEnabled(self) -> bool'
        return True
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    @classmethod
    def painter(cls, self):
        'painter(self) -> QPainter'
        pass
    
    @classmethod
    def pen(cls, self):
        'pen(self) -> QPen'
        pass
    
    @classmethod
    def penNeedsResolving(cls, self):
        'penNeedsResolving(self) -> bool'
        return True
    
    @classmethod
    def renderHints(cls, self):
        'renderHints(self) -> QPainter.RenderHints'
        pass
    
    @classmethod
    def state(cls, self):
        'state(self) -> QPaintEngine.DirtyFlags'
        pass
    
    @classmethod
    def transform(cls, self):
        'transform(self) -> QTransform'
        pass
    

class QPaintEvent(_mod_PyQt5_QtCore.QEvent):
    'QPaintEvent(QRegion)\nQPaintEvent(QRect)\nQPaintEvent(QPaintEvent)'
    __class__ = QPaintEvent
    __dict__ = {}
    def __init__(self, QPaintEvent):
        'QPaintEvent(QRegion)\nQPaintEvent(QRect)\nQPaintEvent(QPaintEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRect'
        pass
    
    @classmethod
    def region(cls, self):
        'region(self) -> QRegion'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QPainter(_mod_sip.simplewrapper):
    'QPainter()\nQPainter(QPaintDevice)'
    Antialiasing = RenderHint()
    CompositionMode = CompositionMode()
    CompositionMode_Clear = CompositionMode()
    CompositionMode_ColorBurn = CompositionMode()
    CompositionMode_ColorDodge = CompositionMode()
    CompositionMode_Darken = CompositionMode()
    CompositionMode_Destination = CompositionMode()
    CompositionMode_DestinationAtop = CompositionMode()
    CompositionMode_DestinationIn = CompositionMode()
    CompositionMode_DestinationOut = CompositionMode()
    CompositionMode_DestinationOver = CompositionMode()
    CompositionMode_Difference = CompositionMode()
    CompositionMode_Exclusion = CompositionMode()
    CompositionMode_HardLight = CompositionMode()
    CompositionMode_Lighten = CompositionMode()
    CompositionMode_Multiply = CompositionMode()
    CompositionMode_Overlay = CompositionMode()
    CompositionMode_Plus = CompositionMode()
    CompositionMode_Screen = CompositionMode()
    CompositionMode_SoftLight = CompositionMode()
    CompositionMode_Source = CompositionMode()
    CompositionMode_SourceAtop = CompositionMode()
    CompositionMode_SourceIn = CompositionMode()
    CompositionMode_SourceOut = CompositionMode()
    CompositionMode_SourceOver = CompositionMode()
    CompositionMode_Xor = CompositionMode()
    HighQualityAntialiasing = RenderHint()
    NonCosmeticDefaultPen = RenderHint()
    OpaqueHint = PixmapFragmentHint()
    PixmapFragment = PixmapFragment()
    PixmapFragmentHint = PixmapFragmentHint()
    PixmapFragmentHints = PixmapFragmentHints()
    Qt4CompatiblePainting = RenderHint()
    RasterOp_ClearDestination = CompositionMode()
    RasterOp_NotDestination = CompositionMode()
    RasterOp_NotSource = CompositionMode()
    RasterOp_NotSourceAndDestination = CompositionMode()
    RasterOp_NotSourceAndNotDestination = CompositionMode()
    RasterOp_NotSourceOrDestination = CompositionMode()
    RasterOp_NotSourceOrNotDestination = CompositionMode()
    RasterOp_NotSourceXorDestination = CompositionMode()
    RasterOp_SetDestination = CompositionMode()
    RasterOp_SourceAndDestination = CompositionMode()
    RasterOp_SourceAndNotDestination = CompositionMode()
    RasterOp_SourceOrDestination = CompositionMode()
    RasterOp_SourceOrNotDestination = CompositionMode()
    RasterOp_SourceXorDestination = CompositionMode()
    RenderHint = RenderHint()
    RenderHints = RenderHints()
    SmoothPixmapTransform = RenderHint()
    TextAntialiasing = RenderHint()
    __class__ = QPainter
    __dict__ = {}
    @classmethod
    def __enter__(cls, self):
        '__enter__(self) -> object'
        return self
    
    @classmethod
    def __exit__(cls, self, object, object_, object_1):
        '__exit__(self, object, object, object)'
        pass
    
    def __init__(self, QPaintDevice):
        'QPainter()\nQPainter(QPaintDevice)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def backgroundMode(cls, self):
        'backgroundMode(self) -> Qt.BGMode'
        pass
    
    @classmethod
    def begin(cls, self, QPaintDevice):
        'begin(self, QPaintDevice) -> bool'
        return True
    
    @classmethod
    def beginNativePainting(cls, self):
        'beginNativePainting(self)'
        pass
    
    @classmethod
    def boundingRect(cls, self, QRectF, str, option: QTextOption=QTextOption()):
        'boundingRect(self, QRectF, int, str) -> QRectF\nboundingRect(self, QRect, int, str) -> QRect\nboundingRect(self, QRectF, str, option: QTextOption = QTextOption()) -> QRectF\nboundingRect(self, int, int, int, int, int, str) -> QRect'
        pass
    
    @classmethod
    def brush(cls, self):
        'brush(self) -> QBrush'
        pass
    
    @classmethod
    def brushOrigin(cls, self):
        'brushOrigin(self) -> QPoint'
        pass
    
    @classmethod
    def clipBoundingRect(cls, self):
        'clipBoundingRect(self) -> QRectF'
        pass
    
    @classmethod
    def clipPath(cls, self):
        'clipPath(self) -> QPainterPath'
        pass
    
    @classmethod
    def clipRegion(cls, self):
        'clipRegion(self) -> QRegion'
        pass
    
    @classmethod
    def combinedTransform(cls, self):
        'combinedTransform(self) -> QTransform'
        pass
    
    @classmethod
    def compositionMode(cls, self):
        'compositionMode(self) -> QPainter.CompositionMode'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QPaintDevice'
        pass
    
    @classmethod
    def deviceTransform(cls, self):
        'deviceTransform(self) -> QTransform'
        pass
    
    @classmethod
    def drawArc(cls, self, int, int_, int_1, int_2, int_3, int_4):
        'drawArc(self, QRectF, int, int)\ndrawArc(self, QRect, int, int)\ndrawArc(self, int, int, int, int, int, int)'
        pass
    
    @classmethod
    def drawChord(cls, self, int, int_, int_1, int_2, int_3, int_4):
        'drawChord(self, QRectF, int, int)\ndrawChord(self, QRect, int, int)\ndrawChord(self, int, int, int, int, int, int)'
        pass
    
    @classmethod
    def drawConvexPolygon(cls, self, UnionQPointF=None, QPoint=None, *_):
        'drawConvexPolygon(self, Union[QPointF, QPoint], *)\ndrawConvexPolygon(self, QPolygonF)\ndrawConvexPolygon(self, QPoint, *)\ndrawConvexPolygon(self, QPolygon)'
        pass
    
    @classmethod
    def drawEllipse(cls, self, UnionQPointF=None, QPoint=None, float=None, float_=None):
        'drawEllipse(self, QRectF)\ndrawEllipse(self, QRect)\ndrawEllipse(self, int, int, int, int)\ndrawEllipse(self, Union[QPointF, QPoint], float, float)\ndrawEllipse(self, QPoint, int, int)'
        pass
    
    @classmethod
    def drawGlyphRun(cls, self, UnionQPointF=None, QPoint=None, QGlyphRun=None):
        'drawGlyphRun(self, Union[QPointF, QPoint], QGlyphRun)'
        pass
    
    @classmethod
    def drawImage(cls, self, int, int_, QImage, sx: int=0, sy: int=0, sw: int=-1, sh: int=-1, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'drawImage(self, QRectF, QImage, QRectF, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\ndrawImage(self, QRect, QImage, QRect, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\ndrawImage(self, Union[QPointF, QPoint], QImage, QRectF, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\ndrawImage(self, QPoint, QImage, QRect, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\ndrawImage(self, QRectF, QImage)\ndrawImage(self, QRect, QImage)\ndrawImage(self, Union[QPointF, QPoint], QImage)\ndrawImage(self, QPoint, QImage)\ndrawImage(self, int, int, QImage, sx: int = 0, sy: int = 0, sw: int = -1, sh: int = -1, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)'
        pass
    
    @classmethod
    def drawLine(cls, self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None):
        'drawLine(self, QLineF)\ndrawLine(self, QLine)\ndrawLine(self, int, int, int, int)\ndrawLine(self, QPoint, QPoint)\ndrawLine(self, Union[QPointF, QPoint], Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def drawLines(cls, self, IterableUnionQPointF=None, QPoint=None):
        'drawLines(self, QLineF, *)\ndrawLines(self, object)\ndrawLines(self, Union[QPointF, QPoint], *)\ndrawLines(self, Iterable[Union[QPointF, QPoint]])\ndrawLines(self, QLine, *)\ndrawLines(self, object)\ndrawLines(self, QPoint, *)\ndrawLines(self, object)'
        pass
    
    @classmethod
    def drawPath(cls, self, QPainterPath):
        'drawPath(self, QPainterPath)'
        pass
    
    @classmethod
    def drawPicture(cls, self, UnionQPointF=None, QPoint=None, QPicture=None):
        'drawPicture(self, Union[QPointF, QPoint], QPicture)\ndrawPicture(self, int, int, QPicture)\ndrawPicture(self, QPoint, QPicture)'
        pass
    
    @classmethod
    def drawPie(cls, self, int, int_, int_1, int_2, int_3, int_4):
        'drawPie(self, QRectF, int, int)\ndrawPie(self, QRect, int, int)\ndrawPie(self, int, int, int, int, int, int)'
        pass
    
    @classmethod
    def drawPixmap(cls, self, int, int_, int_1, int_2, QPixmap, int_3, int_4, int_5, int_6):
        'drawPixmap(self, QRectF, QPixmap, QRectF)\ndrawPixmap(self, QRect, QPixmap, QRect)\ndrawPixmap(self, Union[QPointF, QPoint], QPixmap)\ndrawPixmap(self, QPoint, QPixmap)\ndrawPixmap(self, QRect, QPixmap)\ndrawPixmap(self, int, int, QPixmap)\ndrawPixmap(self, int, int, int, int, QPixmap)\ndrawPixmap(self, int, int, int, int, QPixmap, int, int, int, int)\ndrawPixmap(self, int, int, QPixmap, int, int, int, int)\ndrawPixmap(self, Union[QPointF, QPoint], QPixmap, QRectF)\ndrawPixmap(self, QPoint, QPixmap, QRect)'
        pass
    
    @classmethod
    def drawPixmapFragments(cls, self, ListQPainterPixmapFragment=None, QPixmap=None, hints: QPainter.PixmapFragmentHints=0):
        'drawPixmapFragments(self, List[QPainter.PixmapFragment], QPixmap, hints: QPainter.PixmapFragmentHints = 0)'
        pass
    
    @classmethod
    def drawPoint(cls, self, UnionQPointF=None, QPoint=None):
        'drawPoint(self, Union[QPointF, QPoint])\ndrawPoint(self, int, int)\ndrawPoint(self, QPoint)'
        pass
    
    @classmethod
    def drawPoints(cls, self, UnionQPointF=None, QPoint=None, *_):
        'drawPoints(self, Union[QPointF, QPoint], *)\ndrawPoints(self, QPolygonF)\ndrawPoints(self, QPoint, *)\ndrawPoints(self, QPolygon)'
        pass
    
    @classmethod
    def drawPolygon(cls, self, QPolygonF, fillRule: Qt.FillRule=Qt.OddEvenFill):
        'drawPolygon(self, Union[QPointF, QPoint], *)\ndrawPolygon(self, QPolygonF, fillRule: Qt.FillRule = Qt.OddEvenFill)\ndrawPolygon(self, QPoint, *)\ndrawPolygon(self, QPolygon, fillRule: Qt.FillRule = Qt.OddEvenFill)'
        pass
    
    @classmethod
    def drawPolyline(cls, self, UnionQPointF=None, QPoint=None, *_):
        'drawPolyline(self, Union[QPointF, QPoint], *)\ndrawPolyline(self, QPolygonF)\ndrawPolyline(self, QPoint, *)\ndrawPolyline(self, QPolygon)'
        pass
    
    @classmethod
    def drawRect(cls, self, int, int_, int_1, int_2):
        'drawRect(self, QRectF)\ndrawRect(self, int, int, int, int)\ndrawRect(self, QRect)'
        pass
    
    @classmethod
    def drawRects(cls, self, QRectF, *_):
        'drawRects(self, QRectF, *)\ndrawRects(self, object)\ndrawRects(self, QRect, *)\ndrawRects(self, object)'
        pass
    
    @classmethod
    def drawRoundedRect(cls, self, int, int_, int_1, int_2, float, float_, mode: Qt.SizeMode=Qt.AbsoluteSize):
        'drawRoundedRect(self, QRectF, float, float, mode: Qt.SizeMode = Qt.AbsoluteSize)\ndrawRoundedRect(self, int, int, int, int, float, float, mode: Qt.SizeMode = Qt.AbsoluteSize)\ndrawRoundedRect(self, QRect, float, float, mode: Qt.SizeMode = Qt.AbsoluteSize)'
        pass
    
    @classmethod
    def drawStaticText(cls, self, UnionQPointF=None, QPoint=None, QStaticText=None):
        'drawStaticText(self, Union[QPointF, QPoint], QStaticText)\ndrawStaticText(self, QPoint, QStaticText)\ndrawStaticText(self, int, int, QStaticText)'
        pass
    
    @classmethod
    def drawText(cls, self, QRectF, str, option: QTextOption=QTextOption()):
        'drawText(self, Union[QPointF, QPoint], str)\ndrawText(self, QRectF, int, str) -> QRectF\ndrawText(self, QRect, int, str) -> QRect\ndrawText(self, QRectF, str, option: QTextOption = QTextOption())\ndrawText(self, QPoint, str)\ndrawText(self, int, int, int, int, int, str) -> QRect\ndrawText(self, int, int, str)'
        pass
    
    @classmethod
    def drawTiledPixmap(cls, self, QRectF, QPixmap, pos: Union[QPointF,QPoint]=QPointF()):
        'drawTiledPixmap(self, QRectF, QPixmap, pos: Union[QPointF, QPoint] = QPointF())\ndrawTiledPixmap(self, QRect, QPixmap, pos: QPoint = QPoint())\ndrawTiledPixmap(self, int, int, int, int, QPixmap, sx: int = 0, sy: int = 0)'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> bool'
        return True
    
    @classmethod
    def endNativePainting(cls, self):
        'endNativePainting(self)'
        pass
    
    @classmethod
    def eraseRect(cls, self, int, int_, int_1, int_2):
        'eraseRect(self, QRectF)\neraseRect(self, QRect)\neraseRect(self, int, int, int, int)'
        pass
    
    @classmethod
    def fillPath(cls, self, QPainterPath, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'fillPath(self, QPainterPath, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def fillRect(cls, self, int, int_, int_1, int_2, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'fillRect(self, QRectF, Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nfillRect(self, QRect, Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nfillRect(self, int, int, int, int, Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nfillRect(self, QRectF, Union[QColor, Qt.GlobalColor, QGradient])\nfillRect(self, QRect, Union[QColor, Qt.GlobalColor, QGradient])\nfillRect(self, int, int, int, int, Union[QColor, Qt.GlobalColor, QGradient])\nfillRect(self, int, int, int, int, Qt.GlobalColor)\nfillRect(self, QRect, Qt.GlobalColor)\nfillRect(self, QRectF, Qt.GlobalColor)\nfillRect(self, int, int, int, int, Qt.BrushStyle)\nfillRect(self, QRect, Qt.BrushStyle)\nfillRect(self, QRectF, Qt.BrushStyle)'
        pass
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def fontInfo(cls, self):
        'fontInfo(self) -> QFontInfo'
        pass
    
    @classmethod
    def fontMetrics(cls, self):
        'fontMetrics(self) -> QFontMetrics'
        pass
    
    @classmethod
    def hasClipping(cls, self):
        'hasClipping(self) -> bool'
        return True
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def pen(cls, self):
        'pen(self) -> QPen'
        pass
    
    @classmethod
    def renderHints(cls, self):
        'renderHints(self) -> QPainter.RenderHints'
        pass
    
    @classmethod
    def resetTransform(cls, self):
        'resetTransform(self)'
        pass
    
    @classmethod
    def restore(cls, self):
        'restore(self)'
        pass
    
    @classmethod
    def rotate(cls, self, float):
        'rotate(self, float)'
        pass
    
    @classmethod
    def save(cls, self):
        'save(self)'
        pass
    
    @classmethod
    def scale(cls, self, float, float_):
        'scale(self, float, float)'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBackgroundMode(cls, self, QtBGMode):
        'setBackgroundMode(self, Qt.BGMode)'
        pass
    
    @classmethod
    def setBrush(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBrush(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nsetBrush(self, Qt.BrushStyle)'
        pass
    
    @classmethod
    def setBrushOrigin(cls, self, UnionQPointF=None, QPoint=None):
        'setBrushOrigin(self, Union[QPointF, QPoint])\nsetBrushOrigin(self, int, int)\nsetBrushOrigin(self, QPoint)'
        pass
    
    @classmethod
    def setClipPath(cls, self, QPainterPath, operation: Qt.ClipOperation=Qt.ReplaceClip):
        'setClipPath(self, QPainterPath, operation: Qt.ClipOperation = Qt.ReplaceClip)'
        pass
    
    @classmethod
    def setClipRect(cls, self, int, int_, int_1, int_2, operation: Qt.ClipOperation=Qt.ReplaceClip):
        'setClipRect(self, QRectF, operation: Qt.ClipOperation = Qt.ReplaceClip)\nsetClipRect(self, int, int, int, int, operation: Qt.ClipOperation = Qt.ReplaceClip)\nsetClipRect(self, QRect, operation: Qt.ClipOperation = Qt.ReplaceClip)'
        pass
    
    @classmethod
    def setClipRegion(cls, self, QRegion, operation: Qt.ClipOperation=Qt.ReplaceClip):
        'setClipRegion(self, QRegion, operation: Qt.ClipOperation = Qt.ReplaceClip)'
        pass
    
    @classmethod
    def setClipping(cls, self, bool):
        'setClipping(self, bool)'
        pass
    
    @classmethod
    def setCompositionMode(cls, self, QPainterCompositionMode):
        'setCompositionMode(self, QPainter.CompositionMode)'
        pass
    
    @classmethod
    def setFont(cls, self, QFont):
        'setFont(self, QFont)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setPen(cls, self, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setPen(self, Union[QColor, Qt.GlobalColor, QGradient])\nsetPen(self, Union[QPen, QColor, Qt.GlobalColor, QGradient])\nsetPen(self, Qt.PenStyle)'
        pass
    
    @classmethod
    def setRenderHint(cls, self, QPainterRenderHint, on: bool=True):
        'setRenderHint(self, QPainter.RenderHint, on: bool = True)'
        pass
    
    @classmethod
    def setRenderHints(cls, self, UnionQPainterRenderHints=None, QPainterRenderHint=None, on: bool=True):
        'setRenderHints(self, Union[QPainter.RenderHints, QPainter.RenderHint], on: bool = True)'
        pass
    
    @classmethod
    def setTransform(cls, self, QTransform, combine: bool=False):
        'setTransform(self, QTransform, combine: bool = False)'
        pass
    
    @classmethod
    def setViewTransformEnabled(cls, self, bool):
        'setViewTransformEnabled(self, bool)'
        pass
    
    @classmethod
    def setViewport(cls, self, int, int_, int_1, int_2):
        'setViewport(self, QRect)\nsetViewport(self, int, int, int, int)'
        pass
    
    @classmethod
    def setWindow(cls, self, int, int_, int_1, int_2):
        'setWindow(self, QRect)\nsetWindow(self, int, int, int, int)'
        pass
    
    @classmethod
    def setWorldMatrixEnabled(cls, self, bool):
        'setWorldMatrixEnabled(self, bool)'
        pass
    
    @classmethod
    def setWorldTransform(cls, self, QTransform, combine: bool=False):
        'setWorldTransform(self, QTransform, combine: bool = False)'
        pass
    
    @classmethod
    def shear(cls, self, float, float_):
        'shear(self, float, float)'
        pass
    
    @classmethod
    def strokePath(cls, self, QPainterPath, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'strokePath(self, QPainterPath, Union[QPen, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def testRenderHint(cls, self, QPainterRenderHint):
        'testRenderHint(self, QPainter.RenderHint) -> bool'
        return True
    
    @classmethod
    def transform(cls, self):
        'transform(self) -> QTransform'
        pass
    
    @classmethod
    def translate(cls, self, UnionQPointF=None, QPoint=None):
        'translate(self, Union[QPointF, QPoint])\ntranslate(self, float, float)\ntranslate(self, QPoint)'
        pass
    
    @classmethod
    def viewTransformEnabled(cls, self):
        'viewTransformEnabled(self) -> bool'
        return True
    
    @classmethod
    def viewport(cls, self):
        'viewport(self) -> QRect'
        pass
    
    @classmethod
    def window(cls, self):
        'window(self) -> QRect'
        pass
    
    @classmethod
    def worldMatrixEnabled(cls, self):
        'worldMatrixEnabled(self) -> bool'
        return True
    
    @classmethod
    def worldTransform(cls, self):
        'worldTransform(self) -> QTransform'
        pass
    

class QPainterPath(_mod_sip.simplewrapper):
    'QPainterPath()\nQPainterPath(Union[QPointF, QPoint])\nQPainterPath(QPainterPath)'
    CurveToDataElement = ElementType()
    CurveToElement = ElementType()
    Element = Element()
    ElementType = ElementType()
    LineToElement = ElementType()
    MoveToElement = ElementType()
    def __add__(self, value):
        'Return self+value.'
        return QPainterPath()
    
    def __and__(self, value):
        'Return self&value.'
        return QPainterPath()
    
    __class__ = QPainterPath
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __iand__(self, value):
        'Return self&=value.'
        return None
    
    def __init__(self, UnionQPointF=None, QPoint=None):
        'QPainterPath()\nQPainterPath(Union[QPointF, QPoint])\nQPainterPath(QPainterPath)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __ior__(self, value):
        'Return self|=value.'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QPainterPath()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __or__(self, value):
        'Return self|value.'
        return QPainterPath()
    
    def __radd__(self, value):
        'Return value+self.'
        return QPainterPath()
    
    def __rand__(self, value):
        'Return value&self.'
        return QPainterPath()
    
    def __rmul__(self, value):
        'Return value*self.'
        return QPainterPath()
    
    def __ror__(self, value):
        'Return value|self.'
        return QPainterPath()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QPainterPath()
    
    def __sub__(self, value):
        'Return self-value.'
        return QPainterPath()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def addEllipse(cls, self, UnionQPointF=None, QPoint=None, float=None, float_=None):
        'addEllipse(self, QRectF)\naddEllipse(self, float, float, float, float)\naddEllipse(self, Union[QPointF, QPoint], float, float)'
        pass
    
    @classmethod
    def addPath(cls, self, QPainterPath):
        'addPath(self, QPainterPath)'
        pass
    
    @classmethod
    def addPolygon(cls, self, QPolygonF):
        'addPolygon(self, QPolygonF)'
        pass
    
    @classmethod
    def addRect(cls, self, float, float_, float_1, float_2):
        'addRect(self, QRectF)\naddRect(self, float, float, float, float)'
        pass
    
    @classmethod
    def addRegion(cls, self, QRegion):
        'addRegion(self, QRegion)'
        pass
    
    @classmethod
    def addRoundedRect(cls, self, float, float_, float_1, float_2, float_3, float_4, mode: Qt.SizeMode=Qt.AbsoluteSize):
        'addRoundedRect(self, QRectF, float, float, mode: Qt.SizeMode = Qt.AbsoluteSize)\naddRoundedRect(self, float, float, float, float, float, float, mode: Qt.SizeMode = Qt.AbsoluteSize)'
        pass
    
    @classmethod
    def addText(cls, self, UnionQPointF=None, QPoint=None, QFont=None, str=None):
        'addText(self, Union[QPointF, QPoint], QFont, str)\naddText(self, float, float, QFont, str)'
        pass
    
    @classmethod
    def angleAtPercent(cls, self, float):
        'angleAtPercent(self, float) -> float'
        return 1.0
    
    @classmethod
    def arcMoveTo(cls, self, float, float_, float_1, float_2, float_3):
        'arcMoveTo(self, QRectF, float)\narcMoveTo(self, float, float, float, float, float)'
        pass
    
    @classmethod
    def arcTo(cls, self, float, float_, float_1, float_2, float_3, float_4):
        'arcTo(self, QRectF, float, float)\narcTo(self, float, float, float, float, float, float)'
        pass
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRectF'
        pass
    
    @classmethod
    def closeSubpath(cls, self):
        'closeSubpath(self)'
        pass
    
    @classmethod
    def connectPath(cls, self, QPainterPath):
        'connectPath(self, QPainterPath)'
        pass
    
    @classmethod
    def contains(cls, self, UnionQPointF=None, QPoint=None):
        'contains(self, Union[QPointF, QPoint]) -> bool\ncontains(self, QRectF) -> bool\ncontains(self, QPainterPath) -> bool'
        return True
    
    @classmethod
    def controlPointRect(cls, self):
        'controlPointRect(self) -> QRectF'
        pass
    
    @classmethod
    def cubicTo(cls, self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, UnionQPointF_1=None, QPoint_1=None):
        'cubicTo(self, Union[QPointF, QPoint], Union[QPointF, QPoint], Union[QPointF, QPoint])\ncubicTo(self, float, float, float, float, float, float)'
        pass
    
    @classmethod
    def currentPosition(cls, self):
        'currentPosition(self) -> QPointF'
        pass
    
    @classmethod
    def elementAt(cls, self, int):
        'elementAt(self, int) -> QPainterPath.Element'
        pass
    
    @classmethod
    def elementCount(cls, self):
        'elementCount(self) -> int'
        return 1
    
    @classmethod
    def fillRule(cls, self):
        'fillRule(self) -> Qt.FillRule'
        pass
    
    @classmethod
    def intersected(cls, self, QPainterPath):
        'intersected(self, QPainterPath) -> QPainterPath'
        pass
    
    @classmethod
    def intersects(cls, self, QPainterPath):
        'intersects(self, QRectF) -> bool\nintersects(self, QPainterPath) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> float'
        return 1.0
    
    @classmethod
    def lineTo(cls, self, UnionQPointF=None, QPoint=None):
        'lineTo(self, Union[QPointF, QPoint])\nlineTo(self, float, float)'
        pass
    
    @classmethod
    def moveTo(cls, self, UnionQPointF=None, QPoint=None):
        'moveTo(self, Union[QPointF, QPoint])\nmoveTo(self, float, float)'
        pass
    
    @classmethod
    def percentAtLength(cls, self, float):
        'percentAtLength(self, float) -> float'
        return 1.0
    
    @classmethod
    def pointAtPercent(cls, self, float):
        'pointAtPercent(self, float) -> QPointF'
        pass
    
    @classmethod
    def quadTo(cls, self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None):
        'quadTo(self, Union[QPointF, QPoint], Union[QPointF, QPoint])\nquadTo(self, float, float, float, float)'
        pass
    
    @classmethod
    def setElementPositionAt(cls, self, int, float, float_):
        'setElementPositionAt(self, int, float, float)'
        pass
    
    @classmethod
    def setFillRule(cls, self, QtFillRule):
        'setFillRule(self, Qt.FillRule)'
        pass
    
    @classmethod
    def simplified(cls, self):
        'simplified(self) -> QPainterPath'
        pass
    
    @classmethod
    def slopeAtPercent(cls, self, float):
        'slopeAtPercent(self, float) -> float'
        return 1.0
    
    @classmethod
    def subtracted(cls, self, QPainterPath):
        'subtracted(self, QPainterPath) -> QPainterPath'
        pass
    
    @classmethod
    def swap(cls, self, QPainterPath):
        'swap(self, QPainterPath)'
        pass
    
    @classmethod
    def toFillPolygon(cls, self, QTransform):
        'toFillPolygon(self) -> QPolygonF\ntoFillPolygon(self, QTransform) -> QPolygonF'
        pass
    
    @classmethod
    def toFillPolygons(cls, self, QTransform):
        'toFillPolygons(self) -> List[QPolygonF]\ntoFillPolygons(self, QTransform) -> List[QPolygonF]'
        pass
    
    @classmethod
    def toReversed(cls, self):
        'toReversed(self) -> QPainterPath'
        pass
    
    @classmethod
    def toSubpathPolygons(cls, self, QTransform):
        'toSubpathPolygons(self) -> object\ntoSubpathPolygons(self, QTransform) -> List[QPolygonF]'
        pass
    
    @classmethod
    def translate(cls, self, UnionQPointF=None, QPoint=None):
        'translate(self, float, float)\ntranslate(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def translated(cls, self, UnionQPointF=None, QPoint=None):
        'translated(self, float, float) -> QPainterPath\ntranslated(self, Union[QPointF, QPoint]) -> QPainterPath'
        pass
    
    @classmethod
    def united(cls, self, QPainterPath):
        'united(self, QPainterPath) -> QPainterPath'
        pass
    

class QPainterPathStroker(_mod_sip.simplewrapper):
    'QPainterPathStroker()\nQPainterPathStroker(Union[QPen, QColor, Qt.GlobalColor, QGradient])'
    __class__ = QPainterPathStroker
    __dict__ = {}
    def __init__(self, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'QPainterPathStroker()\nQPainterPathStroker(Union[QPen, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def capStyle(cls, self):
        'capStyle(self) -> Qt.PenCapStyle'
        pass
    
    @classmethod
    def createStroke(cls, self, QPainterPath):
        'createStroke(self, QPainterPath) -> QPainterPath'
        pass
    
    @classmethod
    def curveThreshold(cls, self):
        'curveThreshold(self) -> float'
        return 1.0
    
    @classmethod
    def dashOffset(cls, self):
        'dashOffset(self) -> float'
        return 1.0
    
    @classmethod
    def dashPattern(cls, self):
        'dashPattern(self) -> List[float]'
        pass
    
    @classmethod
    def joinStyle(cls, self):
        'joinStyle(self) -> Qt.PenJoinStyle'
        pass
    
    @classmethod
    def miterLimit(cls, self):
        'miterLimit(self) -> float'
        return 1.0
    
    @classmethod
    def setCapStyle(cls, self, QtPenCapStyle):
        'setCapStyle(self, Qt.PenCapStyle)'
        pass
    
    @classmethod
    def setCurveThreshold(cls, self, float):
        'setCurveThreshold(self, float)'
        pass
    
    @classmethod
    def setDashOffset(cls, self, float):
        'setDashOffset(self, float)'
        pass
    
    @classmethod
    def setDashPattern(cls, self, Iterablefloat=None):
        'setDashPattern(self, Qt.PenStyle)\nsetDashPattern(self, Iterable[float])'
        pass
    
    @classmethod
    def setJoinStyle(cls, self, QtPenJoinStyle):
        'setJoinStyle(self, Qt.PenJoinStyle)'
        pass
    
    @classmethod
    def setMiterLimit(cls, self, float):
        'setMiterLimit(self, float)'
        pass
    
    @classmethod
    def setWidth(cls, self, float):
        'setWidth(self, float)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> float'
        return 1.0
    

class QPalette(_mod_sip.simplewrapper):
    'QPalette()\nQPalette(Union[QColor, Qt.GlobalColor, QGradient])\nQPalette(Qt.GlobalColor)\nQPalette(Union[QColor, Qt.GlobalColor, QGradient], Union[QColor, Qt.GlobalColor, QGradient])\nQPalette(Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nQPalette(QPalette)\nQPalette(Any)'
    Active = ColorGroup()
    All = ColorGroup()
    AlternateBase = ColorRole()
    Background = ColorRole()
    Base = ColorRole()
    BrightText = ColorRole()
    Button = ColorRole()
    ButtonText = ColorRole()
    ColorGroup = ColorGroup()
    ColorRole = ColorRole()
    Current = ColorGroup()
    Dark = ColorRole()
    Disabled = ColorGroup()
    Foreground = ColorRole()
    Highlight = ColorRole()
    HighlightedText = ColorRole()
    Inactive = ColorGroup()
    Light = ColorRole()
    Link = ColorRole()
    LinkVisited = ColorRole()
    Mid = ColorRole()
    Midlight = ColorRole()
    NColorGroups = ColorGroup()
    NColorRoles = ColorRole()
    NoRole = ColorRole()
    Normal = ColorGroup()
    Shadow = ColorRole()
    Text = ColorRole()
    ToolTipBase = ColorRole()
    ToolTipText = ColorRole()
    Window = ColorRole()
    WindowText = ColorRole()
    __class__ = QPalette
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None, UnionQBrush_=None, QColor_=None, QtGlobalColor_=None, QGradient_=None, UnionQBrush_1=None, QColor_1=None, QtGlobalColor_1=None, QGradient_1=None, UnionQBrush_2=None, QColor_2=None, QtGlobalColor_2=None, QGradient_2=None, UnionQBrush_3=None, QColor_3=None, QtGlobalColor_3=None, QGradient_3=None, UnionQBrush_4=None, QColor_4=None, QtGlobalColor_4=None, QGradient_4=None, UnionQBrush_5=None, QColor_5=None, QtGlobalColor_5=None, QGradient_5=None, UnionQBrush_6=None, QColor_6=None, QtGlobalColor_6=None, QGradient_6=None, UnionQBrush_7=None, QColor_7=None, QtGlobalColor_7=None, QGradient_7=None):
        'QPalette()\nQPalette(Union[QColor, Qt.GlobalColor, QGradient])\nQPalette(Qt.GlobalColor)\nQPalette(Union[QColor, Qt.GlobalColor, QGradient], Union[QColor, Qt.GlobalColor, QGradient])\nQPalette(Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nQPalette(QPalette)\nQPalette(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alternateBase(cls, self):
        'alternateBase(self) -> QBrush'
        pass
    
    @classmethod
    def base(cls, self):
        'base(self) -> QBrush'
        pass
    
    @classmethod
    def brightText(cls, self):
        'brightText(self) -> QBrush'
        pass
    
    @classmethod
    def brush(cls, self, QPaletteColorGroup, QPaletteColorRole):
        'brush(self, QPalette.ColorGroup, QPalette.ColorRole) -> QBrush\nbrush(self, QPalette.ColorRole) -> QBrush'
        pass
    
    @classmethod
    def button(cls, self):
        'button(self) -> QBrush'
        pass
    
    @classmethod
    def buttonText(cls, self):
        'buttonText(self) -> QBrush'
        pass
    
    @classmethod
    def cacheKey(cls, self):
        'cacheKey(self) -> int'
        return 1
    
    @classmethod
    def color(cls, self, QPaletteColorGroup, QPaletteColorRole):
        'color(self, QPalette.ColorGroup, QPalette.ColorRole) -> QColor\ncolor(self, QPalette.ColorRole) -> QColor'
        pass
    
    @classmethod
    def currentColorGroup(cls, self):
        'currentColorGroup(self) -> QPalette.ColorGroup'
        pass
    
    @classmethod
    def dark(cls, self):
        'dark(self) -> QBrush'
        pass
    
    @classmethod
    def highlight(cls, self):
        'highlight(self) -> QBrush'
        pass
    
    @classmethod
    def highlightedText(cls, self):
        'highlightedText(self) -> QBrush'
        pass
    
    @classmethod
    def isBrushSet(cls, self, QPaletteColorGroup, QPaletteColorRole):
        'isBrushSet(self, QPalette.ColorGroup, QPalette.ColorRole) -> bool'
        return True
    
    @classmethod
    def isCopyOf(cls, self, QPalette):
        'isCopyOf(self, QPalette) -> bool'
        return True
    
    @classmethod
    def isEqual(cls, self, QPaletteColorGroup, QPaletteColorGroup_):
        'isEqual(self, QPalette.ColorGroup, QPalette.ColorGroup) -> bool'
        return True
    
    @classmethod
    def light(cls, self):
        'light(self) -> QBrush'
        pass
    
    @classmethod
    def link(cls, self):
        'link(self) -> QBrush'
        pass
    
    @classmethod
    def linkVisited(cls, self):
        'linkVisited(self) -> QBrush'
        pass
    
    @classmethod
    def mid(cls, self):
        'mid(self) -> QBrush'
        pass
    
    @classmethod
    def midlight(cls, self):
        'midlight(self) -> QBrush'
        pass
    
    @classmethod
    def resolve(cls, self, QPalette):
        'resolve(self, QPalette) -> QPalette\nresolve(self) -> int\nresolve(self, int)'
        pass
    
    @classmethod
    def setBrush(cls, self, QPaletteColorGroup, QPaletteColorRole, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBrush(self, QPalette.ColorGroup, QPalette.ColorRole, Union[QBrush, QColor, Qt.GlobalColor, QGradient])\nsetBrush(self, QPalette.ColorRole, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setColor(cls, self, QPaletteColorGroup, QPaletteColorRole, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColor(self, QPalette.ColorGroup, QPalette.ColorRole, Union[QColor, Qt.GlobalColor, QGradient])\nsetColor(self, QPalette.ColorRole, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setColorGroup(cls, self, QPaletteColorGroup, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None, UnionQBrush_=None, QColor_=None, QtGlobalColor_=None, QGradient_=None, UnionQBrush_1=None, QColor_1=None, QtGlobalColor_1=None, QGradient_1=None, UnionQBrush_2=None, QColor_2=None, QtGlobalColor_2=None, QGradient_2=None, UnionQBrush_3=None, QColor_3=None, QtGlobalColor_3=None, QGradient_3=None, UnionQBrush_4=None, QColor_4=None, QtGlobalColor_4=None, QGradient_4=None, UnionQBrush_5=None, QColor_5=None, QtGlobalColor_5=None, QGradient_5=None, UnionQBrush_6=None, QColor_6=None, QtGlobalColor_6=None, QGradient_6=None, UnionQBrush_7=None, QColor_7=None, QtGlobalColor_7=None, QGradient_7=None):
        'setColorGroup(self, QPalette.ColorGroup, Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient], Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCurrentColorGroup(cls, self, QPaletteColorGroup):
        'setCurrentColorGroup(self, QPalette.ColorGroup)'
        pass
    
    @classmethod
    def shadow(cls, self):
        'shadow(self) -> QBrush'
        pass
    
    @classmethod
    def swap(cls, self, QPalette):
        'swap(self, QPalette)'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> QBrush'
        pass
    
    @classmethod
    def toolTipBase(cls, self):
        'toolTipBase(self) -> QBrush'
        pass
    
    @classmethod
    def toolTipText(cls, self):
        'toolTipText(self) -> QBrush'
        pass
    
    @classmethod
    def window(cls, self):
        'window(self) -> QBrush'
        pass
    
    @classmethod
    def windowText(cls, self):
        'windowText(self) -> QBrush'
        pass
    

class QPdfWriter(_mod_PyQt5_QtCore.QObject,QPagedPaintDevice):
    'QPdfWriter(str)\nQPdfWriter(QIODevice)'
    __class__ = QPdfWriter
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QIODevice):
        'QPdfWriter(str)\nQPdfWriter(QIODevice)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def creator(cls, self):
        'creator(self) -> str'
        return ''
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def margins(cls, self):
        'margins(self) -> QPagedPaintDevice.Margins'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def newPage(cls, self):
        'newPage(self) -> bool'
        return True
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def pageLayout(cls, self):
        'pageLayout(self) -> QPageLayout'
        pass
    
    @classmethod
    def pageSize(cls, self):
        'pageSize(self) -> QPagedPaintDevice.PageSize'
        pass
    
    @classmethod
    def pageSizeMM(cls, self):
        'pageSizeMM(self) -> QSizeF'
        pass
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def resolution(cls, self):
        'resolution(self) -> int'
        return 1
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setCreator(cls, self, str):
        'setCreator(self, str)'
        pass
    
    @classmethod
    def setMargins(cls, self, QPagedPaintDeviceMargins):
        'setMargins(self, QPagedPaintDevice.Margins)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setPageLayout(cls, self, QPageLayout):
        'setPageLayout(self, QPageLayout) -> bool'
        return True
    
    @classmethod
    def setPageMargins(cls, self, QMarginsF, QPageLayoutUnit):
        'setPageMargins(self, QMarginsF) -> bool\nsetPageMargins(self, QMarginsF, QPageLayout.Unit) -> bool'
        return True
    
    @classmethod
    def setPageOrientation(cls, self, QPageLayoutOrientation):
        'setPageOrientation(self, QPageLayout.Orientation) -> bool'
        return True
    
    @classmethod
    def setPageSize(cls, self, QPagedPaintDevicePageSize):
        'setPageSize(self, QPagedPaintDevice.PageSize)'
        pass
    
    @classmethod
    def setPageSizeMM(cls, self, QSizeF):
        'setPageSizeMM(self, QSizeF)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setResolution(cls, self, int):
        'setResolution(self, int)'
        pass
    
    @classmethod
    def setTitle(cls, self, str):
        'setTitle(self, str)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def title(cls, self):
        'title(self) -> str'
        return ''
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QPen(_mod_sip.simplewrapper):
    'QPen()\nQPen(Qt.PenStyle)\nQPen(Union[QBrush, QColor, Qt.GlobalColor, QGradient], float, style: Qt.PenStyle = Qt.SolidLine, cap: Qt.PenCapStyle = Qt.SquareCap, join: Qt.PenJoinStyle = Qt.BevelJoin)\nQPen(Union[QPen, QColor, Qt.GlobalColor, QGradient])\nQPen(Any)'
    __class__ = QPen
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None, float=None, style: Qt.PenStyle=Qt.SolidLine, cap: Qt.PenCapStyle=Qt.SquareCap, join: Qt.PenJoinStyle=Qt.BevelJoin):
        'QPen()\nQPen(Qt.PenStyle)\nQPen(Union[QBrush, QColor, Qt.GlobalColor, QGradient], float, style: Qt.PenStyle = Qt.SolidLine, cap: Qt.PenCapStyle = Qt.SquareCap, join: Qt.PenJoinStyle = Qt.BevelJoin)\nQPen(Union[QPen, QColor, Qt.GlobalColor, QGradient])\nQPen(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def brush(cls, self):
        'brush(self) -> QBrush'
        pass
    
    @classmethod
    def capStyle(cls, self):
        'capStyle(self) -> Qt.PenCapStyle'
        pass
    
    @classmethod
    def color(cls, self):
        'color(self) -> QColor'
        pass
    
    @classmethod
    def dashOffset(cls, self):
        'dashOffset(self) -> float'
        return 1.0
    
    @classmethod
    def dashPattern(cls, self):
        'dashPattern(self) -> List[float]'
        pass
    
    @classmethod
    def isCosmetic(cls, self):
        'isCosmetic(self) -> bool'
        return True
    
    @classmethod
    def isSolid(cls, self):
        'isSolid(self) -> bool'
        return True
    
    @classmethod
    def joinStyle(cls, self):
        'joinStyle(self) -> Qt.PenJoinStyle'
        pass
    
    @classmethod
    def miterLimit(cls, self):
        'miterLimit(self) -> float'
        return 1.0
    
    @classmethod
    def setBrush(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBrush(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCapStyle(cls, self, QtPenCapStyle):
        'setCapStyle(self, Qt.PenCapStyle)'
        pass
    
    @classmethod
    def setColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCosmetic(cls, self, bool):
        'setCosmetic(self, bool)'
        pass
    
    @classmethod
    def setDashOffset(cls, self, float):
        'setDashOffset(self, float)'
        pass
    
    @classmethod
    def setDashPattern(cls, self, Iterablefloat=None):
        'setDashPattern(self, Iterable[float])'
        pass
    
    @classmethod
    def setJoinStyle(cls, self, QtPenJoinStyle):
        'setJoinStyle(self, Qt.PenJoinStyle)'
        pass
    
    @classmethod
    def setMiterLimit(cls, self, float):
        'setMiterLimit(self, float)'
        pass
    
    @classmethod
    def setStyle(cls, self, QtPenStyle):
        'setStyle(self, Qt.PenStyle)'
        pass
    
    @classmethod
    def setWidth(cls, self, int):
        'setWidth(self, int)'
        pass
    
    @classmethod
    def setWidthF(cls, self, float):
        'setWidthF(self, float)'
        pass
    
    @classmethod
    def style(cls, self):
        'style(self) -> Qt.PenStyle'
        pass
    
    @classmethod
    def swap(cls, self, QPen):
        'swap(self, QPen)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthF(cls, self):
        'widthF(self) -> float'
        return 1.0
    

class QPicture(QPaintDevice):
    'QPicture(formatVersion: int = -1)\nQPicture(QPicture)'
    __class__ = QPicture
    __dict__ = {}
    def __init__(self, formatVersion: int=-1):
        'QPicture(formatVersion: int = -1)\nQPicture(QPicture)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRect'
        pass
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def data(cls, self):
        'data(self) -> str'
        return ''
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def detach(cls, self):
        'detach(self)'
        pass
    
    @classmethod
    def devType(cls, self):
        'devType(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def isDetached(cls, self):
        'isDetached(self) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def load(cls, self, QIODevice, format: str=None):
        'load(self, QIODevice, format: str = None) -> bool\nload(self, str, format: str = None) -> bool'
        return True
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def play(cls, self, QPainter):
        'play(self, QPainter) -> bool'
        return True
    
    @classmethod
    def save(cls, self, QIODevice, format: str=None):
        'save(self, QIODevice, format: str = None) -> bool\nsave(self, str, format: str = None) -> bool'
        return True
    
    @classmethod
    def setBoundingRect(cls, self, QRect):
        'setBoundingRect(self, QRect)'
        pass
    
    @classmethod
    def setData(cls, self, bytes):
        'setData(self, bytes)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> int'
        return 1
    
    @classmethod
    def swap(cls, self, QPicture):
        'swap(self, QPicture)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QPictureIO(_mod_sip.simplewrapper):
    'QPictureIO()\nQPictureIO(QIODevice, str)\nQPictureIO(str, str)'
    __class__ = QPictureIO
    __dict__ = {}
    def __init__(self, QIODevice, str):
        'QPictureIO()\nQPictureIO(QIODevice, str)\nQPictureIO(str, str)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def defineIOHandler(cls, str, str_, str_1, OptionalCallable=None, None_=None, OptionalCallable_=None, None_1=None):
        'defineIOHandler(str, str, str, Optional[Callable[[], None]], Optional[Callable[[], None]])'
        pass
    
    @classmethod
    def description(cls, self):
        'description(self) -> str'
        return ''
    
    @classmethod
    def fileName(cls, self):
        'fileName(self) -> str'
        return ''
    
    @classmethod
    def format(cls, self):
        'format(self) -> str'
        return ''
    
    @classmethod
    def gamma(cls, self):
        'gamma(self) -> float'
        return 1.0
    
    @classmethod
    def inputFormats(cls):
        'inputFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def ioDevice(cls, self):
        'ioDevice(self) -> QIODevice'
        pass
    
    @classmethod
    def outputFormats(cls):
        'outputFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def parameters(cls, self):
        'parameters(self) -> str'
        return ''
    
    @classmethod
    def picture(cls, self):
        'picture(self) -> QPicture'
        pass
    
    @classmethod
    def pictureFormat(cls, QIODevice):
        'pictureFormat(str) -> QByteArray\npictureFormat(QIODevice) -> QByteArray'
        pass
    
    @classmethod
    def quality(cls, self):
        'quality(self) -> int'
        return 1
    
    @classmethod
    def read(cls, self):
        'read(self) -> bool'
        return True
    
    @classmethod
    def setDescription(cls, self, str):
        'setDescription(self, str)'
        pass
    
    @classmethod
    def setFileName(cls, self, str):
        'setFileName(self, str)'
        pass
    
    @classmethod
    def setFormat(cls, self, str):
        'setFormat(self, str)'
        pass
    
    @classmethod
    def setGamma(cls, self, float):
        'setGamma(self, float)'
        pass
    
    @classmethod
    def setIODevice(cls, self, QIODevice):
        'setIODevice(self, QIODevice)'
        pass
    
    @classmethod
    def setParameters(cls, self, str):
        'setParameters(self, str)'
        pass
    
    @classmethod
    def setPicture(cls, self, QPicture):
        'setPicture(self, QPicture)'
        pass
    
    @classmethod
    def setQuality(cls, self, int):
        'setQuality(self, int)'
        pass
    
    @classmethod
    def setStatus(cls, self, int):
        'setStatus(self, int)'
        pass
    
    @classmethod
    def status(cls, self):
        'status(self) -> int'
        return 1
    
    @classmethod
    def write(cls, self):
        'write(self) -> bool'
        return True
    

class QPixelFormat(_mod_sip.simplewrapper):
    'QPixelFormat()\nQPixelFormat(QPixelFormat.ColorModel, int, int, int, int, int, int, QPixelFormat.AlphaUsage, QPixelFormat.AlphaPosition, QPixelFormat.AlphaPremultiplied, QPixelFormat.TypeInterpretation, byteOrder: QPixelFormat.ByteOrder = QPixelFormat.CurrentSystemEndian, subEnum: int = 0)\nQPixelFormat(QPixelFormat)'
    Alpha = ColorModel()
    AlphaPosition = AlphaPosition()
    AlphaPremultiplied = AlphaPremultiplied()
    AlphaUsage = AlphaUsage()
    AtBeginning = AlphaPosition()
    AtEnd = AlphaPosition()
    BGR = ColorModel()
    BigEndian = ByteOrder()
    ByteOrder = ByteOrder()
    CMYK = ColorModel()
    ColorModel = ColorModel()
    CurrentSystemEndian = ByteOrder()
    FloatingPoint = TypeInterpretation()
    Grayscale = ColorModel()
    HSL = ColorModel()
    HSV = ColorModel()
    IMC1 = YUVLayout()
    IMC2 = YUVLayout()
    IMC3 = YUVLayout()
    IMC4 = YUVLayout()
    IgnoresAlpha = AlphaUsage()
    Indexed = ColorModel()
    LittleEndian = ByteOrder()
    NV12 = YUVLayout()
    NV21 = YUVLayout()
    NotPremultiplied = AlphaPremultiplied()
    Premultiplied = AlphaPremultiplied()
    RGB = ColorModel()
    TypeInterpretation = TypeInterpretation()
    UYVY = YUVLayout()
    UnsignedByte = TypeInterpretation()
    UnsignedInteger = TypeInterpretation()
    UnsignedShort = TypeInterpretation()
    UsesAlpha = AlphaUsage()
    Y16 = YUVLayout()
    Y8 = YUVLayout()
    YUV = ColorModel()
    YUV411 = YUVLayout()
    YUV420P = YUVLayout()
    YUV420SP = YUVLayout()
    YUV422 = YUVLayout()
    YUV444 = YUVLayout()
    YUVLayout = YUVLayout()
    YUYV = YUVLayout()
    YV12 = YUVLayout()
    __class__ = QPixelFormat
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QPixelFormatColorModel, int, int_, int_1, int_2, int_3, int_4, QPixelFormatAlphaUsage, QPixelFormatAlphaPosition, QPixelFormatAlphaPremultiplied, QPixelFormatTypeInterpretation, byteOrder: QPixelFormat.ByteOrder=QPixelFormat.CurrentSystemEndian, subEnum: int=0):
        'QPixelFormat()\nQPixelFormat(QPixelFormat.ColorModel, int, int, int, int, int, int, QPixelFormat.AlphaUsage, QPixelFormat.AlphaPosition, QPixelFormat.AlphaPremultiplied, QPixelFormat.TypeInterpretation, byteOrder: QPixelFormat.ByteOrder = QPixelFormat.CurrentSystemEndian, subEnum: int = 0)\nQPixelFormat(QPixelFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alphaPosition(cls, self):
        'alphaPosition(self) -> QPixelFormat.AlphaPosition'
        pass
    
    @classmethod
    def alphaSize(cls, self):
        'alphaSize(self) -> int'
        return 1
    
    @classmethod
    def alphaUsage(cls, self):
        'alphaUsage(self) -> QPixelFormat.AlphaUsage'
        pass
    
    @classmethod
    def bitsPerPixel(cls, self):
        'bitsPerPixel(self) -> int'
        return 1
    
    @classmethod
    def blackSize(cls, self):
        'blackSize(self) -> int'
        return 1
    
    @classmethod
    def blueSize(cls, self):
        'blueSize(self) -> int'
        return 1
    
    @classmethod
    def brightnessSize(cls, self):
        'brightnessSize(self) -> int'
        return 1
    
    @classmethod
    def byteOrder(cls, self):
        'byteOrder(self) -> QPixelFormat.ByteOrder'
        pass
    
    @classmethod
    def channelCount(cls, self):
        'channelCount(self) -> int'
        return 1
    
    @classmethod
    def colorModel(cls, self):
        'colorModel(self) -> QPixelFormat.ColorModel'
        pass
    
    @classmethod
    def cyanSize(cls, self):
        'cyanSize(self) -> int'
        return 1
    
    @classmethod
    def greenSize(cls, self):
        'greenSize(self) -> int'
        return 1
    
    @classmethod
    def hueSize(cls, self):
        'hueSize(self) -> int'
        return 1
    
    @classmethod
    def lightnessSize(cls, self):
        'lightnessSize(self) -> int'
        return 1
    
    @classmethod
    def magentaSize(cls, self):
        'magentaSize(self) -> int'
        return 1
    
    @classmethod
    def premultiplied(cls, self):
        'premultiplied(self) -> QPixelFormat.AlphaPremultiplied'
        pass
    
    @classmethod
    def redSize(cls, self):
        'redSize(self) -> int'
        return 1
    
    @classmethod
    def saturationSize(cls, self):
        'saturationSize(self) -> int'
        return 1
    
    @classmethod
    def subEnum(cls, self):
        'subEnum(self) -> int'
        return 1
    
    @classmethod
    def typeInterpretation(cls, self):
        'typeInterpretation(self) -> QPixelFormat.TypeInterpretation'
        pass
    
    @classmethod
    def yellowSize(cls, self):
        'yellowSize(self) -> int'
        return 1
    
    @classmethod
    def yuvLayout(cls, self):
        'yuvLayout(self) -> QPixelFormat.YUVLayout'
        pass
    

class QPixmap(QPaintDevice):
    'QPixmap()\nQPixmap(int, int)\nQPixmap(QSize)\nQPixmap(str, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\nQPixmap(List[str])\nQPixmap(QPixmap)\nQPixmap(Any)'
    __class__ = QPixmap
    __dict__ = {}
    def __init__(self, str, format: str=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'QPixmap()\nQPixmap(int, int)\nQPixmap(QSize)\nQPixmap(str, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor)\nQPixmap(List[str])\nQPixmap(QPixmap)\nQPixmap(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def cacheKey(cls, self):
        'cacheKey(self) -> int'
        return 1
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def convertFromImage(cls, self, QImage, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'convertFromImage(self, QImage, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def copy(cls, self, rect: QRect=QRect()):
        'copy(self, rect: QRect = QRect()) -> QPixmap\ncopy(self, int, int, int, int) -> QPixmap'
        pass
    
    @classmethod
    def createHeuristicMask(cls, self, clipTight: bool=True):
        'createHeuristicMask(self, clipTight: bool = True) -> QBitmap'
        pass
    
    @classmethod
    def createMaskFromColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None, mode: Qt.MaskMode=Qt.MaskInColor):
        'createMaskFromColor(self, Union[QColor, Qt.GlobalColor, QGradient], mode: Qt.MaskMode = Qt.MaskInColor) -> QBitmap'
        pass
    
    @classmethod
    def defaultDepth(cls):
        'defaultDepth() -> int'
        return 1
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def detach(cls, self):
        'detach(self)'
        pass
    
    @classmethod
    def devType(cls, self):
        'devType(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def fill(cls, self, color: Union[QColor,Qt.GlobalColor,QGradient]=Qt.white):
        'fill(self, color: Union[QColor, Qt.GlobalColor, QGradient] = Qt.white)'
        pass
    
    @classmethod
    def fromImage(cls, QImage, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'fromImage(QImage, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QPixmap'
        pass
    
    @classmethod
    def fromImageReader(cls, QImageReader, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'fromImageReader(QImageReader, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> QPixmap'
        pass
    
    @classmethod
    def hasAlpha(cls, self):
        'hasAlpha(self) -> bool'
        return True
    
    @classmethod
    def hasAlphaChannel(cls, self):
        'hasAlphaChannel(self) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def isQBitmap(cls, self):
        'isQBitmap(self) -> bool'
        return True
    
    @classmethod
    def load(cls, self, str, format: str=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'load(self, str, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def loadFromData(cls, self, UnionQByteArray=None, bytes=None, bytearray=None, format: str=None, flags: Union[Qt.ImageConversionFlags,Qt.ImageConversionFlag]=Qt.AutoColor):
        'loadFromData(self, bytes, format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool\nloadFromData(self, Union[QByteArray, bytes, bytearray], format: str = None, flags: Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag] = Qt.AutoColor) -> bool'
        return True
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QBitmap'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRect'
        pass
    
    @classmethod
    def save(cls, self, QIODevice, format: str=None, quality: int=-1):
        'save(self, str, format: str = None, quality: int = -1) -> bool\nsave(self, QIODevice, format: str = None, quality: int = -1) -> bool'
        return True
    
    @classmethod
    def scaled(cls, self, int, int_, aspectRatioMode: Qt.AspectRatioMode=Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode=Qt.FastTransformation):
        'scaled(self, int, int, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap\nscaled(self, QSize, aspectRatioMode: Qt.AspectRatioMode = Qt.IgnoreAspectRatio, transformMode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scaledToHeight(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToHeight(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scaledToWidth(cls, self, int, mode: Qt.TransformationMode=Qt.FastTransformation):
        'scaledToWidth(self, int, mode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def scroll(cls, self, int, int_, int_1, int_2, int_3, int_4):
        'scroll(self, int, int, QRect) -> QRegion\nscroll(self, int, int, int, int, int, int) -> QRegion'
        pass
    
    @classmethod
    def setDevicePixelRatio(cls, self, float):
        'setDevicePixelRatio(self, float)'
        pass
    
    @classmethod
    def setMask(cls, self, QBitmap):
        'setMask(self, QBitmap)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def swap(cls, self, QPixmap):
        'swap(self, QPixmap)'
        pass
    
    @classmethod
    def toImage(cls, self):
        'toImage(self) -> QImage'
        pass
    
    @classmethod
    def transformed(cls, self, QTransform, mode: Qt.TransformationMode=Qt.FastTransformation):
        'transformed(self, QTransform, mode: Qt.TransformationMode = Qt.FastTransformation) -> QPixmap'
        pass
    
    @classmethod
    def trueMatrix(cls, QTransform, int, int_):
        'trueMatrix(QTransform, int, int) -> QTransform'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    

class QPixmapCache(_mod_sip.simplewrapper):
    'QPixmapCache()\nQPixmapCache(QPixmapCache)'
    Key = Key()
    __class__ = QPixmapCache
    __dict__ = {}
    def __init__(self, QPixmapCache):
        'QPixmapCache()\nQPixmapCache(QPixmapCache)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def cacheLimit(cls):
        'cacheLimit() -> int'
        return 1
    
    @classmethod
    def clear(cls):
        'clear()'
        pass
    
    @classmethod
    def find(cls, QPixmapCacheKey):
        'find(str) -> QPixmap\nfind(QPixmapCache.Key) -> QPixmap'
        pass
    
    @classmethod
    def insert(cls, str, QPixmap):
        'insert(str, QPixmap) -> bool\ninsert(QPixmap) -> QPixmapCache.Key'
        return True
    
    @classmethod
    def remove(cls, QPixmapCacheKey):
        'remove(str)\nremove(QPixmapCache.Key)'
        pass
    
    @classmethod
    def replace(cls, QPixmapCacheKey, QPixmap):
        'replace(QPixmapCache.Key, QPixmap) -> bool'
        return True
    
    @classmethod
    def setCacheLimit(cls, int):
        'setCacheLimit(int)'
        pass
    

class QPlatformSurfaceEvent(_mod_PyQt5_QtCore.QEvent):
    'QPlatformSurfaceEvent(QPlatformSurfaceEvent.SurfaceEventType)\nQPlatformSurfaceEvent(QPlatformSurfaceEvent)'
    SurfaceAboutToBeDestroyed = SurfaceEventType()
    SurfaceCreated = SurfaceEventType()
    SurfaceEventType = SurfaceEventType()
    __class__ = QPlatformSurfaceEvent
    __dict__ = {}
    def __init__(self, QPlatformSurfaceEventSurfaceEventType):
        'QPlatformSurfaceEvent(QPlatformSurfaceEvent.SurfaceEventType)\nQPlatformSurfaceEvent(QPlatformSurfaceEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def surfaceEventType(cls, self):
        'surfaceEventType(self) -> QPlatformSurfaceEvent.SurfaceEventType'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QPointingDeviceUniqueId(_mod_sip.simplewrapper):
    'QPointingDeviceUniqueId()\nQPointingDeviceUniqueId(QPointingDeviceUniqueId)'
    __class__ = QPointingDeviceUniqueId
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    def __hash__(self):
        'Return hash(self).'
        return 0
    
    def __init__(self, QPointingDeviceUniqueId):
        'QPointingDeviceUniqueId()\nQPointingDeviceUniqueId(QPointingDeviceUniqueId)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def fromNumericId(cls, int):
        'fromNumericId(int) -> QPointingDeviceUniqueId'
        pass
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def numericId(cls, self):
        'numericId(self) -> int'
        return 1
    

class QPolygon(_mod_sip.simplewrapper):
    'QPolygon()\nQPolygon(QPolygon)\nQPolygon(Iterable[QPoint])\nQPolygon(QRect, closed: bool = False)\nQPolygon(int)\nQPolygon(List[int])\nQPolygon(Any)'
    def __add__(self, value):
        'Return self+value.'
        return QPolygon()
    
    __class__ = QPolygon
    def __contains__(self, key):
        'Return key in self.'
        return False
    
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Implement self+=value.'
        return None
    
    def __init__(self, QRect, closed: bool=False):
        'QPolygon()\nQPolygon(QPolygon)\nQPolygon(Iterable[QPoint])\nQPolygon(QRect, closed: bool = False)\nQPolygon(int)\nQPolygon(List[int])\nQPolygon(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    def __lshift__(self, value):
        'Return self<<value.'
        return QPolygon()
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QPolygon()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __reduce__(self):
        return ''; return ()
    
    def __rlshift__(self, value):
        'Return value<<self.'
        return QPolygon()
    
    def __rmul__(self, value):
        'Return value*self.'
        return QPolygon()
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def append(cls, self, QPoint):
        'append(self, QPoint)'
        pass
    
    @classmethod
    def at(cls, self, int):
        'at(self, int) -> QPoint'
        pass
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRect'
        pass
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def contains(cls, self, QPoint):
        'contains(self, QPoint) -> bool'
        return True
    
    @classmethod
    def containsPoint(cls, self, QPoint, QtFillRule):
        'containsPoint(self, QPoint, Qt.FillRule) -> bool'
        return True
    
    @classmethod
    def count(cls, self, QPoint):
        'count(self, QPoint) -> int\ncount(self) -> int'
        return 1
    
    @classmethod
    def data(cls, self):
        'data(self) -> sip.voidptr'
        pass
    
    @classmethod
    def fill(cls, self, QPoint, size: int=-1):
        'fill(self, QPoint, size: int = -1)'
        pass
    
    @classmethod
    def first(cls, self):
        'first(self) -> QPoint'
        pass
    
    @classmethod
    def indexOf(cls, self, QPoint, from_: int=0):
        'indexOf(self, QPoint, from_: int = 0) -> int'
        return 1
    
    @classmethod
    def insert(cls, self, int, QPoint):
        'insert(self, int, QPoint)'
        pass
    
    @classmethod
    def intersected(cls, self, QPolygon):
        'intersected(self, QPolygon) -> QPolygon'
        pass
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def last(cls, self):
        'last(self) -> QPoint'
        pass
    
    @classmethod
    def lastIndexOf(cls, self, QPoint, from_: int=-1):
        'lastIndexOf(self, QPoint, from_: int = -1) -> int'
        return 1
    
    @classmethod
    def mid(cls, self, int, length: int=-1):
        'mid(self, int, length: int = -1) -> QPolygon'
        pass
    
    @classmethod
    def point(cls, self, int):
        'point(self, int) -> QPoint'
        pass
    
    @classmethod
    def prepend(cls, self, QPoint):
        'prepend(self, QPoint)'
        pass
    
    @classmethod
    def putPoints(cls, self, int, int_, QPolygon, from_: int=0):
        'putPoints(self, int, int, int, *)\nputPoints(self, int, int, QPolygon, from_: int = 0)'
        pass
    
    @classmethod
    def remove(cls, self, int, int_):
        'remove(self, int)\nremove(self, int, int)'
        pass
    
    @classmethod
    def replace(cls, self, int, QPoint):
        'replace(self, int, QPoint)'
        pass
    
    @classmethod
    def setPoint(cls, self, int, int_, int_1):
        'setPoint(self, int, QPoint)\nsetPoint(self, int, int, int)'
        pass
    
    @classmethod
    def setPoints(cls, self, int, int_, *_):
        'setPoints(self, List[int])\nsetPoints(self, int, int, *)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> int'
        return 1
    
    @classmethod
    def subtracted(cls, self, QPolygon):
        'subtracted(self, QPolygon) -> QPolygon'
        pass
    
    @classmethod
    def swap(cls, self, QPolygon):
        'swap(self, QPolygon)'
        pass
    
    @classmethod
    def translate(cls, self, int, int_):
        'translate(self, int, int)\ntranslate(self, QPoint)'
        pass
    
    @classmethod
    def translated(cls, self, int, int_):
        'translated(self, int, int) -> QPolygon\ntranslated(self, QPoint) -> QPolygon'
        pass
    
    @classmethod
    def united(cls, self, QPolygon):
        'united(self, QPolygon) -> QPolygon'
        pass
    
    @classmethod
    def value(cls, self, int, QPoint):
        'value(self, int) -> QPoint\nvalue(self, int, QPoint) -> QPoint'
        pass
    

class QPolygonF(_mod_sip.simplewrapper):
    'QPolygonF()\nQPolygonF(QPolygonF)\nQPolygonF(Iterable[Union[QPointF, QPoint]])\nQPolygonF(QRectF)\nQPolygonF(QPolygon)\nQPolygonF(int)'
    def __add__(self, value):
        'Return self+value.'
        return QPolygonF()
    
    __class__ = QPolygonF
    def __contains__(self, key):
        'Return key in self.'
        return False
    
    def __delitem__(self, key):
        'Delete self[key].'
        return None
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Implement self+=value.'
        return None
    
    def __init__(self, IterableUnionQPointF=None, QPoint=None):
        'QPolygonF()\nQPolygonF(QPolygonF)\nQPolygonF(Iterable[Union[QPointF, QPoint]])\nQPolygonF(QRectF)\nQPolygonF(QPolygon)\nQPolygonF(int)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    def __lshift__(self, value):
        'Return self<<value.'
        return QPolygonF()
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QPolygonF()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __rlshift__(self, value):
        'Return value<<self.'
        return QPolygonF()
    
    def __rmul__(self, value):
        'Return value*self.'
        return QPolygonF()
    
    def __setitem__(self, key, value):
        'Set self[key] to value.'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def append(cls, self, UnionQPointF=None, QPoint=None):
        'append(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def at(cls, self, int):
        'at(self, int) -> QPointF'
        pass
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRectF'
        pass
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def contains(cls, self, UnionQPointF=None, QPoint=None):
        'contains(self, Union[QPointF, QPoint]) -> bool'
        return True
    
    @classmethod
    def containsPoint(cls, self, UnionQPointF=None, QPoint=None, QtFillRule=None):
        'containsPoint(self, Union[QPointF, QPoint], Qt.FillRule) -> bool'
        return True
    
    @classmethod
    def count(cls, self, UnionQPointF=None, QPoint=None):
        'count(self, Union[QPointF, QPoint]) -> int\ncount(self) -> int'
        return 1
    
    @classmethod
    def data(cls, self):
        'data(self) -> sip.voidptr'
        pass
    
    @classmethod
    def fill(cls, self, UnionQPointF=None, QPoint=None, size: int=-1):
        'fill(self, Union[QPointF, QPoint], size: int = -1)'
        pass
    
    @classmethod
    def first(cls, self):
        'first(self) -> QPointF'
        pass
    
    @classmethod
    def indexOf(cls, self, UnionQPointF=None, QPoint=None, from_: int=0):
        'indexOf(self, Union[QPointF, QPoint], from_: int = 0) -> int'
        return 1
    
    @classmethod
    def insert(cls, self, int, UnionQPointF=None, QPoint=None):
        'insert(self, int, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def intersected(cls, self, QPolygonF):
        'intersected(self, QPolygonF) -> QPolygonF'
        pass
    
    @classmethod
    def isClosed(cls, self):
        'isClosed(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def last(cls, self):
        'last(self) -> QPointF'
        pass
    
    @classmethod
    def lastIndexOf(cls, self, UnionQPointF=None, QPoint=None, from_: int=-1):
        'lastIndexOf(self, Union[QPointF, QPoint], from_: int = -1) -> int'
        return 1
    
    @classmethod
    def mid(cls, self, int, length: int=-1):
        'mid(self, int, length: int = -1) -> QPolygonF'
        pass
    
    @classmethod
    def prepend(cls, self, UnionQPointF=None, QPoint=None):
        'prepend(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def remove(cls, self, int, int_):
        'remove(self, int)\nremove(self, int, int)'
        pass
    
    @classmethod
    def replace(cls, self, int, UnionQPointF=None, QPoint=None):
        'replace(self, int, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> int'
        return 1
    
    @classmethod
    def subtracted(cls, self, QPolygonF):
        'subtracted(self, QPolygonF) -> QPolygonF'
        pass
    
    @classmethod
    def swap(cls, self, QPolygonF):
        'swap(self, QPolygonF)'
        pass
    
    @classmethod
    def toPolygon(cls, self):
        'toPolygon(self) -> QPolygon'
        pass
    
    @classmethod
    def translate(cls, self, UnionQPointF=None, QPoint=None):
        'translate(self, Union[QPointF, QPoint])\ntranslate(self, float, float)'
        pass
    
    @classmethod
    def translated(cls, self, UnionQPointF=None, QPoint=None):
        'translated(self, Union[QPointF, QPoint]) -> QPolygonF\ntranslated(self, float, float) -> QPolygonF'
        pass
    
    @classmethod
    def united(cls, self, QPolygonF):
        'united(self, QPolygonF) -> QPolygonF'
        pass
    
    @classmethod
    def value(cls, self, int, UnionQPointF=None, QPoint=None):
        'value(self, int) -> QPointF\nvalue(self, int, Union[QPointF, QPoint]) -> QPointF'
        pass
    

class QQuaternion(_mod_sip.simplewrapper):
    'QQuaternion()\nQQuaternion(float, float, float, float)\nQQuaternion(float, QVector3D)\nQQuaternion(QVector4D)\nQQuaternion(QQuaternion)'
    def __add__(self, value):
        'Return self+value.'
        return QQuaternion()
    
    __class__ = QQuaternion
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, float, float_, float_1, float_2):
        'QQuaternion()\nQQuaternion(float, float, float, float)\nQQuaternion(float, QVector3D)\nQQuaternion(QVector4D)\nQQuaternion(QQuaternion)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QQuaternion()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __neg__(self):
        '-self'
        return QQuaternion()
    
    def __radd__(self, value):
        'Return value+self.'
        return QQuaternion()
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __rmul__(self, value):
        'Return value*self.'
        return QQuaternion()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QQuaternion()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QQuaternion()
    
    def __sub__(self, value):
        'Return self-value.'
        return QQuaternion()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def conjugate(cls, self):
        'conjugate(self) -> QQuaternion'
        pass
    
    @classmethod
    def conjugated(cls, self):
        'conjugated(self) -> QQuaternion'
        pass
    
    @classmethod
    def dotProduct(cls, QQuaternion, QQuaternion_):
        'dotProduct(QQuaternion, QQuaternion) -> float'
        return 1.0
    
    @classmethod
    def fromAxes(cls, QVector3D, QVector3D_, QVector3D_1):
        'fromAxes(QVector3D, QVector3D, QVector3D) -> QQuaternion'
        pass
    
    @classmethod
    def fromAxisAndAngle(cls, float, float_, float_1, float_2):
        'fromAxisAndAngle(QVector3D, float) -> QQuaternion\nfromAxisAndAngle(float, float, float, float) -> QQuaternion'
        pass
    
    @classmethod
    def fromDirection(cls, QVector3D, QVector3D_):
        'fromDirection(QVector3D, QVector3D) -> QQuaternion'
        pass
    
    @classmethod
    def fromEulerAngles(cls, float, float_, float_1):
        'fromEulerAngles(float, float, float) -> QQuaternion\nfromEulerAngles(QVector3D) -> QQuaternion'
        pass
    
    @classmethod
    def fromRotationMatrix(cls, QMatrix3x3):
        'fromRotationMatrix(QMatrix3x3) -> QQuaternion'
        pass
    
    @classmethod
    def getAxes(cls, self):
        'getAxes(self) -> Tuple[QVector3D, QVector3D, QVector3D]'
        pass
    
    @classmethod
    def getAxisAndAngle(cls, self):
        'getAxisAndAngle(self) -> Tuple[QVector3D, float]'
        pass
    
    @classmethod
    def getEulerAngles(cls, self):
        'getEulerAngles(self) -> Tuple[float, float, float]'
        pass
    
    @classmethod
    def inverted(cls, self):
        'inverted(self) -> QQuaternion'
        pass
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> float'
        return 1.0
    
    @classmethod
    def lengthSquared(cls, self):
        'lengthSquared(self) -> float'
        return 1.0
    
    @classmethod
    def nlerp(cls, QQuaternion, QQuaternion_, float):
        'nlerp(QQuaternion, QQuaternion, float) -> QQuaternion'
        pass
    
    @classmethod
    def normalize(cls, self):
        'normalize(self)'
        pass
    
    @classmethod
    def normalized(cls, self):
        'normalized(self) -> QQuaternion'
        pass
    
    @classmethod
    def rotatedVector(cls, self, QVector3D):
        'rotatedVector(self, QVector3D) -> QVector3D'
        pass
    
    @classmethod
    def rotationTo(cls, QVector3D, QVector3D_):
        'rotationTo(QVector3D, QVector3D) -> QQuaternion'
        pass
    
    @classmethod
    def scalar(cls, self):
        'scalar(self) -> float'
        return 1.0
    
    @classmethod
    def setScalar(cls, self, float):
        'setScalar(self, float)'
        pass
    
    @classmethod
    def setVector(cls, self, float, float_, float_1):
        'setVector(self, QVector3D)\nsetVector(self, float, float, float)'
        pass
    
    @classmethod
    def setX(cls, self, float):
        'setX(self, float)'
        pass
    
    @classmethod
    def setY(cls, self, float):
        'setY(self, float)'
        pass
    
    @classmethod
    def setZ(cls, self, float):
        'setZ(self, float)'
        pass
    
    @classmethod
    def slerp(cls, QQuaternion, QQuaternion_, float):
        'slerp(QQuaternion, QQuaternion, float) -> QQuaternion'
        pass
    
    @classmethod
    def toEulerAngles(cls, self):
        'toEulerAngles(self) -> QVector3D'
        pass
    
    @classmethod
    def toRotationMatrix(cls, self):
        'toRotationMatrix(self) -> QMatrix3x3'
        pass
    
    @classmethod
    def toVector4D(cls, self):
        'toVector4D(self) -> QVector4D'
        pass
    
    @classmethod
    def vector(cls, self):
        'vector(self) -> QVector3D'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> float'
        return 1.0
    
    @classmethod
    def y(cls, self):
        'y(self) -> float'
        return 1.0
    
    @classmethod
    def z(cls, self):
        'z(self) -> float'
        return 1.0
    

class QRadialGradient(QGradient):
    'QRadialGradient()\nQRadialGradient(Union[QPointF, QPoint], float, Union[QPointF, QPoint])\nQRadialGradient(Union[QPointF, QPoint], float, Union[QPointF, QPoint], float)\nQRadialGradient(Union[QPointF, QPoint], float)\nQRadialGradient(float, float, float, float, float)\nQRadialGradient(float, float, float, float, float, float)\nQRadialGradient(float, float, float)\nQRadialGradient(QRadialGradient)'
    __class__ = QRadialGradient
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, float=None, UnionQPointF_=None, QPoint_=None, float_=None):
        'QRadialGradient()\nQRadialGradient(Union[QPointF, QPoint], float, Union[QPointF, QPoint])\nQRadialGradient(Union[QPointF, QPoint], float, Union[QPointF, QPoint], float)\nQRadialGradient(Union[QPointF, QPoint], float)\nQRadialGradient(float, float, float, float, float)\nQRadialGradient(float, float, float, float, float, float)\nQRadialGradient(float, float, float)\nQRadialGradient(QRadialGradient)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def center(cls, self):
        'center(self) -> QPointF'
        pass
    
    @classmethod
    def centerRadius(cls, self):
        'centerRadius(self) -> float'
        return 1.0
    
    @classmethod
    def coordinateMode(cls, self):
        'coordinateMode(self) -> QGradient.CoordinateMode'
        pass
    
    @classmethod
    def focalPoint(cls, self):
        'focalPoint(self) -> QPointF'
        pass
    
    @classmethod
    def focalRadius(cls, self):
        'focalRadius(self) -> float'
        return 1.0
    
    @classmethod
    def radius(cls, self):
        'radius(self) -> float'
        return 1.0
    
    @classmethod
    def setCenter(cls, self, UnionQPointF=None, QPoint=None):
        'setCenter(self, Union[QPointF, QPoint])\nsetCenter(self, float, float)'
        pass
    
    @classmethod
    def setCenterRadius(cls, self, float):
        'setCenterRadius(self, float)'
        pass
    
    @classmethod
    def setColorAt(cls, self, float, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setColorAt(self, float, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCoordinateMode(cls, self, QGradientCoordinateMode):
        'setCoordinateMode(self, QGradient.CoordinateMode)'
        pass
    
    @classmethod
    def setFocalPoint(cls, self, UnionQPointF=None, QPoint=None):
        'setFocalPoint(self, Union[QPointF, QPoint])\nsetFocalPoint(self, float, float)'
        pass
    
    @classmethod
    def setFocalRadius(cls, self, float):
        'setFocalRadius(self, float)'
        pass
    
    @classmethod
    def setRadius(cls, self, float):
        'setRadius(self, float)'
        pass
    
    @classmethod
    def setSpread(cls, self, QGradientSpread):
        'setSpread(self, QGradient.Spread)'
        pass
    
    @classmethod
    def setStops(cls, self, object):
        'setStops(self, object)'
        pass
    
    @classmethod
    def spread(cls, self):
        'spread(self) -> QGradient.Spread'
        pass
    
    @classmethod
    def stops(cls, self):
        'stops(self) -> object'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QGradient.Type'
        pass
    

class QRasterWindow(QPaintDeviceWindow):
    'QRasterWindow(parent: QWindow = None)'
    __class__ = QRasterWindow
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QWindow=None):
        'QRasterWindow(parent: QWindow = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def alert(cls, self, int):
        'alert(self, int)'
        pass
    
    @classmethod
    def baseSize(cls, self):
        'baseSize(self) -> QSize'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def close(cls, self):
        'close(self) -> bool'
        return True
    
    @classmethod
    def colorCount(cls, self):
        'colorCount(self) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def contentOrientation(cls, self):
        'contentOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self)'
        pass
    
    @classmethod
    def cursor(cls, self):
        'cursor(self) -> QCursor'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioF(cls, self):
        'devicePixelRatioF(self) -> float'
        return 1.0
    
    @classmethod
    def devicePixelRatioFScale(cls):
        'devicePixelRatioFScale() -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exposeEvent(cls, self, QExposeEvent):
        'exposeEvent(self, QExposeEvent)'
        pass
    
    @classmethod
    def filePath(cls, self):
        'filePath(self) -> str'
        return ''
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.WindowFlags'
        pass
    
    @classmethod
    def focusInEvent(cls, self, QFocusEvent):
        'focusInEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def focusObject(cls, self):
        'focusObject(self) -> QObject'
        pass
    
    @classmethod
    def focusOutEvent(cls, self, QFocusEvent):
        'focusOutEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def frameGeometry(cls, self):
        'frameGeometry(self) -> QRect'
        pass
    
    @classmethod
    def frameMargins(cls, self):
        'frameMargins(self) -> QMargins'
        pass
    
    @classmethod
    def framePosition(cls, self):
        'framePosition(self) -> QPoint'
        pass
    
    @classmethod
    def fromWinId(cls, sipvoidptr):
        'fromWinId(sip.voidptr) -> QWindow'
        pass
    
    @classmethod
    def geometry(cls, self):
        'geometry(self) -> QRect'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    @classmethod
    def heightMM(cls, self):
        'heightMM(self) -> int'
        return 1
    
    @classmethod
    def hide(cls, self):
        'hide(self)'
        pass
    
    @classmethod
    def hideEvent(cls, self, QHideEvent):
        'hideEvent(self, QHideEvent)'
        pass
    
    @classmethod
    def icon(cls, self):
        'icon(self) -> QIcon'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def isAncestorOf(cls, self, QWindow, mode: QWindow.AncestorMode=QWindow.IncludeTransients):
        'isAncestorOf(self, QWindow, mode: QWindow.AncestorMode = QWindow.IncludeTransients) -> bool'
        return True
    
    @classmethod
    def isExposed(cls, self):
        'isExposed(self) -> bool'
        return True
    
    @classmethod
    def isModal(cls, self):
        'isModal(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isTopLevel(cls, self):
        'isTopLevel(self) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyPressEvent(cls, self, QKeyEvent):
        'keyPressEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def keyReleaseEvent(cls, self, QKeyEvent):
        'keyReleaseEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logicalDpiX(cls, self):
        'logicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def logicalDpiY(cls, self):
        'logicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def lower(cls, self):
        'lower(self)'
        pass
    
    @classmethod
    def mapFromGlobal(cls, self, QPoint):
        'mapFromGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mapToGlobal(cls, self, QPoint):
        'mapToGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QRegion'
        pass
    
    @classmethod
    def maximumHeight(cls, self):
        'maximumHeight(self) -> int'
        return 1
    
    @classmethod
    def maximumSize(cls, self):
        'maximumSize(self) -> QSize'
        pass
    
    @classmethod
    def maximumWidth(cls, self):
        'maximumWidth(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def metric(cls, self, QPaintDevicePaintDeviceMetric):
        'metric(self, QPaintDevice.PaintDeviceMetric) -> int'
        return 1
    
    @classmethod
    def minimumHeight(cls, self):
        'minimumHeight(self) -> int'
        return 1
    
    @classmethod
    def minimumSize(cls, self):
        'minimumSize(self) -> QSize'
        pass
    
    @classmethod
    def minimumWidth(cls, self):
        'minimumWidth(self) -> int'
        return 1
    
    @classmethod
    def modality(cls, self):
        'modality(self) -> Qt.WindowModality'
        pass
    
    @classmethod
    def mouseDoubleClickEvent(cls, self, QMouseEvent):
        'mouseDoubleClickEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseMoveEvent(cls, self, QMouseEvent):
        'mouseMoveEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mousePressEvent(cls, self, QMouseEvent):
        'mousePressEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseReleaseEvent(cls, self, QMouseEvent):
        'mouseReleaseEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def moveEvent(cls, self, QMoveEvent):
        'moveEvent(self, QMoveEvent)'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    @classmethod
    def paintEngine(cls, self):
        'paintEngine(self) -> QPaintEngine'
        pass
    
    @classmethod
    def paintEvent(cls, self, QPaintEvent):
        'paintEvent(self, QPaintEvent)'
        pass
    
    @classmethod
    def paintingActive(cls, self):
        'paintingActive(self) -> bool'
        return True
    
    @classmethod
    def parent(cls, self, QWindowAncestorMode):
        'parent(self) -> QWindow\nparent(self, QWindow.AncestorMode) -> QWindow'
        pass
    
    @classmethod
    def physicalDpiX(cls, self):
        'physicalDpiX(self) -> int'
        return 1
    
    @classmethod
    def physicalDpiY(cls, self):
        'physicalDpiY(self) -> int'
        return 1
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPoint'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def raise_(cls, self):
        'raise_(self)'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reportContentOrientationChange(cls, self, QtScreenOrientation):
        'reportContentOrientationChange(self, Qt.ScreenOrientation)'
        pass
    
    @classmethod
    def requestActivate(cls, self):
        'requestActivate(self)'
        pass
    
    @classmethod
    def requestUpdate(cls, self):
        'requestUpdate(self)'
        pass
    
    @classmethod
    def requestedFormat(cls, self):
        'requestedFormat(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def resize(cls, self, int, int_):
        'resize(self, QSize)\nresize(self, int, int)'
        pass
    
    @classmethod
    def resizeEvent(cls, self, QResizeEvent):
        'resizeEvent(self, QResizeEvent)'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBaseSize(cls, self, QSize):
        'setBaseSize(self, QSize)'
        pass
    
    @classmethod
    def setCursor(cls, self, UnionQCursor=None, QtCursorShape=None):
        'setCursor(self, Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def setFilePath(cls, self, str):
        'setFilePath(self, str)'
        pass
    
    @classmethod
    def setFlag(cls, self, QtWindowType, on: bool=True):
        'setFlag(self, Qt.WindowType, on: bool = True)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQtWindowFlags=None, QtWindowType=None):
        'setFlags(self, Union[Qt.WindowFlags, Qt.WindowType])'
        pass
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setFramePosition(cls, self, QPoint):
        'setFramePosition(self, QPoint)'
        pass
    
    @classmethod
    def setGeometry(cls, self, int, int_, int_1, int_2):
        'setGeometry(self, int, int, int, int)\nsetGeometry(self, QRect)'
        pass
    
    @classmethod
    def setHeight(cls, self, int):
        'setHeight(self, int)'
        pass
    
    @classmethod
    def setIcon(cls, self, QIcon):
        'setIcon(self, QIcon)'
        pass
    
    @classmethod
    def setKeyboardGrabEnabled(cls, self, bool):
        'setKeyboardGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setMask(cls, self, QRegion):
        'setMask(self, QRegion)'
        pass
    
    @classmethod
    def setMaximumHeight(cls, self, int):
        'setMaximumHeight(self, int)'
        pass
    
    @classmethod
    def setMaximumSize(cls, self, QSize):
        'setMaximumSize(self, QSize)'
        pass
    
    @classmethod
    def setMaximumWidth(cls, self, int):
        'setMaximumWidth(self, int)'
        pass
    
    @classmethod
    def setMinimumHeight(cls, self, int):
        'setMinimumHeight(self, int)'
        pass
    
    @classmethod
    def setMinimumSize(cls, self, QSize):
        'setMinimumSize(self, QSize)'
        pass
    
    @classmethod
    def setMinimumWidth(cls, self, int):
        'setMinimumWidth(self, int)'
        pass
    
    @classmethod
    def setModality(cls, self, QtWindowModality):
        'setModality(self, Qt.WindowModality)'
        pass
    
    @classmethod
    def setMouseGrabEnabled(cls, self, bool):
        'setMouseGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setParent(cls, self, QWindow):
        'setParent(self, QWindow)'
        pass
    
    @classmethod
    def setPosition(cls, self, int, int_):
        'setPosition(self, QPoint)\nsetPosition(self, int, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def setSizeIncrement(cls, self, QSize):
        'setSizeIncrement(self, QSize)'
        pass
    
    @classmethod
    def setSurfaceType(cls, self, QSurfaceSurfaceType):
        'setSurfaceType(self, QSurface.SurfaceType)'
        pass
    
    @classmethod
    def setTitle(cls, self, str):
        'setTitle(self, str)'
        pass
    
    @classmethod
    def setTransientParent(cls, self, QWindow):
        'setTransientParent(self, QWindow)'
        pass
    
    @classmethod
    def setVisibility(cls, self, QWindowVisibility):
        'setVisibility(self, QWindow.Visibility)'
        pass
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def setWidth(cls, self, int):
        'setWidth(self, int)'
        pass
    
    @classmethod
    def setWindowState(cls, self, QtWindowState):
        'setWindowState(self, Qt.WindowState)'
        pass
    
    @classmethod
    def setX(cls, self, int):
        'setX(self, int)'
        pass
    
    @classmethod
    def setY(cls, self, int):
        'setY(self, int)'
        pass
    
    @classmethod
    def show(cls, self):
        'show(self)'
        pass
    
    @classmethod
    def showEvent(cls, self, QShowEvent):
        'showEvent(self, QShowEvent)'
        pass
    
    @classmethod
    def showFullScreen(cls, self):
        'showFullScreen(self)'
        pass
    
    @classmethod
    def showMaximized(cls, self):
        'showMaximized(self)'
        pass
    
    @classmethod
    def showMinimized(cls, self):
        'showMinimized(self)'
        pass
    
    @classmethod
    def showNormal(cls, self):
        'showNormal(self)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def sizeIncrement(cls, self):
        'sizeIncrement(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    
    @classmethod
    def tabletEvent(cls, self, QTabletEvent):
        'tabletEvent(self, QTabletEvent)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def title(cls, self):
        'title(self) -> str'
        return ''
    
    @classmethod
    def touchEvent(cls, self, QTouchEvent):
        'touchEvent(self, QTouchEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def transientParent(cls, self):
        'transientParent(self) -> QWindow'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> Qt.WindowType'
        pass
    
    @classmethod
    def unsetCursor(cls, self):
        'unsetCursor(self)'
        pass
    
    @classmethod
    def update(cls, self, QRegion):
        'update(self, QRect)\nupdate(self, QRegion)\nupdate(self)'
        pass
    
    @classmethod
    def visibility(cls, self):
        'visibility(self) -> QWindow.Visibility'
        pass
    
    @classmethod
    def wheelEvent(cls, self, QWheelEvent):
        'wheelEvent(self, QWheelEvent)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    @classmethod
    def widthMM(cls, self):
        'widthMM(self) -> int'
        return 1
    
    @classmethod
    def winId(cls, self):
        'winId(self) -> sip.voidptr'
        pass
    
    @classmethod
    def windowState(cls, self):
        'windowState(self) -> Qt.WindowState'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QRawFont(_mod_sip.simplewrapper):
    'QRawFont()\nQRawFont(str, float, hintingPreference: QFont.HintingPreference = QFont.PreferDefaultHinting)\nQRawFont(Union[QByteArray, bytes, bytearray], float, hintingPreference: QFont.HintingPreference = QFont.PreferDefaultHinting)\nQRawFont(QRawFont)'
    AntialiasingType = AntialiasingType()
    KernedAdvances = LayoutFlag()
    LayoutFlag = LayoutFlag()
    LayoutFlags = LayoutFlags()
    PixelAntialiasing = AntialiasingType()
    SeparateAdvances = LayoutFlag()
    SubPixelAntialiasing = AntialiasingType()
    UseDesignMetrics = LayoutFlag()
    __class__ = QRawFont
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    def __hash__(self):
        'Return hash(self).'
        return 0
    
    def __init__(self, UnionQByteArray=None, bytes=None, bytearray=None, float=None, hintingPreference: QFont.HintingPreference=QFont.PreferDefaultHinting):
        'QRawFont()\nQRawFont(str, float, hintingPreference: QFont.HintingPreference = QFont.PreferDefaultHinting)\nQRawFont(Union[QByteArray, bytes, bytearray], float, hintingPreference: QFont.HintingPreference = QFont.PreferDefaultHinting)\nQRawFont(QRawFont)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def advancesForGlyphIndexes(cls, self, Iterableint=None, UnionQRawFontLayoutFlags=None, QRawFontLayoutFlag=None):
        'advancesForGlyphIndexes(self, Iterable[int]) -> List[QPointF]\nadvancesForGlyphIndexes(self, Iterable[int], Union[QRawFont.LayoutFlags, QRawFont.LayoutFlag]) -> List[QPointF]'
        pass
    
    @classmethod
    def alphaMapForGlyph(cls, self, int, antialiasingType: QRawFont.AntialiasingType=QRawFont.SubPixelAntialiasing, transform: QTransform=QTransform()):
        'alphaMapForGlyph(self, int, antialiasingType: QRawFont.AntialiasingType = QRawFont.SubPixelAntialiasing, transform: QTransform = QTransform()) -> QImage'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> float'
        return 1.0
    
    @classmethod
    def averageCharWidth(cls, self):
        'averageCharWidth(self) -> float'
        return 1.0
    
    @classmethod
    def boundingRect(cls, self, int):
        'boundingRect(self, int) -> QRectF'
        pass
    
    @classmethod
    def capHeight(cls, self):
        'capHeight(self) -> float'
        return 1.0
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> float'
        return 1.0
    
    @classmethod
    def familyName(cls, self):
        'familyName(self) -> str'
        return ''
    
    @classmethod
    def fontTable(cls, self, str):
        'fontTable(self, str) -> QByteArray'
        pass
    
    @classmethod
    def fromFont(cls, QFont, writingSystem: QFontDatabase.WritingSystem=QFontDatabase.Any):
        'fromFont(QFont, writingSystem: QFontDatabase.WritingSystem = QFontDatabase.Any) -> QRawFont'
        pass
    
    @classmethod
    def glyphIndexesForString(cls, self, str):
        'glyphIndexesForString(self, str) -> List[int]'
        pass
    
    @classmethod
    def hintingPreference(cls, self):
        'hintingPreference(self) -> QFont.HintingPreference'
        pass
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def leading(cls, self):
        'leading(self) -> float'
        return 1.0
    
    @classmethod
    def lineThickness(cls, self):
        'lineThickness(self) -> float'
        return 1.0
    
    @classmethod
    def loadFromData(cls, self, UnionQByteArray=None, bytes=None, bytearray=None, float=None, QFontHintingPreference=None):
        'loadFromData(self, Union[QByteArray, bytes, bytearray], float, QFont.HintingPreference)'
        pass
    
    @classmethod
    def loadFromFile(cls, self, str, float, QFontHintingPreference):
        'loadFromFile(self, str, float, QFont.HintingPreference)'
        pass
    
    @classmethod
    def maxCharWidth(cls, self):
        'maxCharWidth(self) -> float'
        return 1.0
    
    @classmethod
    def pathForGlyph(cls, self, int):
        'pathForGlyph(self, int) -> QPainterPath'
        pass
    
    @classmethod
    def pixelSize(cls, self):
        'pixelSize(self) -> float'
        return 1.0
    
    @classmethod
    def setPixelSize(cls, self, float):
        'setPixelSize(self, float)'
        pass
    
    @classmethod
    def style(cls, self):
        'style(self) -> QFont.Style'
        pass
    
    @classmethod
    def styleName(cls, self):
        'styleName(self) -> str'
        return ''
    
    @classmethod
    def supportedWritingSystems(cls, self):
        'supportedWritingSystems(self) -> List[QFontDatabase.WritingSystem]'
        pass
    
    @classmethod
    def supportsCharacter(cls, self, str):
        'supportsCharacter(self, int) -> bool\nsupportsCharacter(self, str) -> bool'
        return True
    
    @classmethod
    def swap(cls, self, QRawFont):
        'swap(self, QRawFont)'
        pass
    
    @classmethod
    def underlinePosition(cls, self):
        'underlinePosition(self) -> float'
        return 1.0
    
    @classmethod
    def unitsPerEm(cls, self):
        'unitsPerEm(self) -> float'
        return 1.0
    
    @classmethod
    def weight(cls, self):
        'weight(self) -> int'
        return 1
    
    @classmethod
    def xHeight(cls, self):
        'xHeight(self) -> float'
        return 1.0
    

class QRegExpValidator(QValidator):
    'QRegExpValidator(parent: QObject = None)\nQRegExpValidator(QRegExp, parent: QObject = None)'
    __class__ = QRegExpValidator
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QRegExp, parent: QObject=None):
        'QRegExpValidator(parent: QObject = None)\nQRegExpValidator(QRegExp, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fixup(cls, self, str):
        'fixup(self, str) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def regExp(cls, self):
        'regExp(self) -> QRegExp'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setLocale(cls, self, QLocale):
        'setLocale(self, QLocale)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRegExp(cls, self, QRegExp):
        'setRegExp(self, QRegExp)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def validate(cls, self, str, int):
        'validate(self, str, int) -> Tuple[QValidator.State, str, int]'
        pass
    

class QRegion(_mod_sip.simplewrapper):
    'QRegion()\nQRegion(int, int, int, int, type: QRegion.RegionType = QRegion.Rectangle)\nQRegion(QRect, type: QRegion.RegionType = QRegion.Rectangle)\nQRegion(QPolygon, fillRule: Qt.FillRule = Qt.OddEvenFill)\nQRegion(QBitmap)\nQRegion(QRegion)\nQRegion(Any)'
    Ellipse = RegionType()
    Rectangle = RegionType()
    RegionType = RegionType()
    def __add__(self, value):
        'Return self+value.'
        return QRegion()
    
    def __and__(self, value):
        'Return self&value.'
        return QRegion()
    
    def __bool__(self):
        'self != 0'
        return False
    
    __class__ = QRegion
    def __contains__(self, key):
        'Return key in self.'
        return False
    
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __iand__(self, value):
        'Return self&=value.'
        return None
    
    def __init__(self, int, int_, int_1, int_2, type: QRegion.RegionType=QRegion.Rectangle):
        'QRegion()\nQRegion(int, int, int, int, type: QRegion.RegionType = QRegion.Rectangle)\nQRegion(QRect, type: QRegion.RegionType = QRegion.Rectangle)\nQRegion(QPolygon, fillRule: Qt.FillRule = Qt.OddEvenFill)\nQRegion(QBitmap)\nQRegion(QRegion)\nQRegion(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __ior__(self, value):
        'Return self|=value.'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __ixor__(self, value):
        'Return self^=value.'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QRegion()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __or__(self, value):
        'Return self|value.'
        return QRegion()
    
    def __radd__(self, value):
        'Return value+self.'
        return QRegion()
    
    def __rand__(self, value):
        'Return value&self.'
        return QRegion()
    
    def __rmul__(self, value):
        'Return value*self.'
        return QRegion()
    
    def __ror__(self, value):
        'Return value|self.'
        return QRegion()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QRegion()
    
    def __rxor__(self, value):
        'Return value^self.'
        return QRegion()
    
    def __sub__(self, value):
        'Return self-value.'
        return QRegion()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    def __xor__(self, value):
        'Return self^value.'
        return QRegion()
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRect'
        pass
    
    @classmethod
    def contains(cls, self, QPoint):
        'contains(self, QPoint) -> bool\ncontains(self, QRect) -> bool'
        return True
    
    @classmethod
    def intersected(cls, self, QRegion):
        'intersected(self, QRegion) -> QRegion\nintersected(self, QRect) -> QRegion'
        pass
    
    @classmethod
    def intersects(cls, self, QRegion):
        'intersects(self, QRegion) -> bool\nintersects(self, QRect) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def rectCount(cls, self):
        'rectCount(self) -> int'
        return 1
    
    @classmethod
    def rects(cls, self):
        'rects(self) -> List[QRect]'
        pass
    
    @classmethod
    def setRects(cls, self, IterableQRect=None):
        'setRects(self, Iterable[QRect])'
        pass
    
    @classmethod
    def subtracted(cls, self, QRegion):
        'subtracted(self, QRegion) -> QRegion'
        pass
    
    @classmethod
    def swap(cls, self, QRegion):
        'swap(self, QRegion)'
        pass
    
    @classmethod
    def translate(cls, self, int, int_):
        'translate(self, int, int)\ntranslate(self, QPoint)'
        pass
    
    @classmethod
    def translated(cls, self, int, int_):
        'translated(self, int, int) -> QRegion\ntranslated(self, QPoint) -> QRegion'
        pass
    
    @classmethod
    def united(cls, self, QRegion):
        'united(self, QRegion) -> QRegion\nunited(self, QRect) -> QRegion'
        pass
    
    @classmethod
    def xored(cls, self, QRegion):
        'xored(self, QRegion) -> QRegion'
        pass
    

class QRegularExpressionValidator(QValidator):
    'QRegularExpressionValidator(parent: QObject = None)\nQRegularExpressionValidator(QRegularExpression, parent: QObject = None)'
    __class__ = QRegularExpressionValidator
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QRegularExpression, parent: QObject=None):
        'QRegularExpressionValidator(parent: QObject = None)\nQRegularExpressionValidator(QRegularExpression, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fixup(cls, self, str):
        'fixup(self, str) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def regularExpression(cls, self):
        'regularExpression(self) -> QRegularExpression'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setLocale(cls, self, QLocale):
        'setLocale(self, QLocale)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRegularExpression(cls, self, QRegularExpression):
        'setRegularExpression(self, QRegularExpression)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def validate(cls, self, str, int):
        'validate(self, str, int) -> Tuple[QValidator.State, str, int]'
        pass
    

class QResizeEvent(_mod_PyQt5_QtCore.QEvent):
    'QResizeEvent(QSize, QSize)\nQResizeEvent(QResizeEvent)'
    __class__ = QResizeEvent
    __dict__ = {}
    def __init__(self, QResizeEvent):
        'QResizeEvent(QSize, QSize)\nQResizeEvent(QResizeEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def oldSize(cls, self):
        'oldSize(self) -> QSize'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QRgba64(_mod_sip.simplewrapper):
    'QRgba64()\nQRgba64(QRgba64)'
    __class__ = QRgba64
    __dict__ = {}
    def __init__(self, QRgba64):
        'QRgba64()\nQRgba64(QRgba64)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __int__(self):
        'int(self)'
        return 0
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alpha(cls, self):
        'alpha(self) -> int'
        return 1
    
    @classmethod
    def alpha8(cls, self):
        'alpha8(self) -> int'
        return 1
    
    @classmethod
    def blue(cls, self):
        'blue(self) -> int'
        return 1
    
    @classmethod
    def blue8(cls, self):
        'blue8(self) -> int'
        return 1
    
    @classmethod
    def fromArgb32(cls, int):
        'fromArgb32(int) -> QRgba64'
        pass
    
    @classmethod
    def fromRgba(cls, int, int_, int_1, int_2):
        'fromRgba(int, int, int, int) -> QRgba64'
        pass
    
    @classmethod
    def fromRgba64(cls, int, int_, int_1, int_2):
        'fromRgba64(int) -> QRgba64\nfromRgba64(int, int, int, int) -> QRgba64'
        pass
    
    @classmethod
    def green(cls, self):
        'green(self) -> int'
        return 1
    
    @classmethod
    def green8(cls, self):
        'green8(self) -> int'
        return 1
    
    @classmethod
    def isOpaque(cls, self):
        'isOpaque(self) -> bool'
        return True
    
    @classmethod
    def isTransparent(cls, self):
        'isTransparent(self) -> bool'
        return True
    
    @classmethod
    def premultiplied(cls, self):
        'premultiplied(self) -> QRgba64'
        pass
    
    @classmethod
    def red(cls, self):
        'red(self) -> int'
        return 1
    
    @classmethod
    def red8(cls, self):
        'red8(self) -> int'
        return 1
    
    @classmethod
    def setAlpha(cls, self, int):
        'setAlpha(self, int)'
        pass
    
    @classmethod
    def setBlue(cls, self, int):
        'setBlue(self, int)'
        pass
    
    @classmethod
    def setGreen(cls, self, int):
        'setGreen(self, int)'
        pass
    
    @classmethod
    def setRed(cls, self, int):
        'setRed(self, int)'
        pass
    
    @classmethod
    def toArgb32(cls, self):
        'toArgb32(self) -> int'
        return 1
    
    @classmethod
    def toRgb16(cls, self):
        'toRgb16(self) -> int'
        return 1
    
    @classmethod
    def unpremultiplied(cls, self):
        'unpremultiplied(self) -> QRgba64'
        pass
    

class QScreen(_mod_PyQt5_QtCore.QObject):
    __class__ = QScreen
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def angleBetween(cls, self, QtScreenOrientation, QtScreenOrientation_):
        'angleBetween(self, Qt.ScreenOrientation, Qt.ScreenOrientation) -> int'
        return 1
    
    @classmethod
    def availableGeometry(cls, self):
        'availableGeometry(self) -> QRect'
        pass
    
    def availableGeometryChanged(self, QRect):
        'availableGeometryChanged(self, QRect) [signal]'
        pass
    
    @classmethod
    def availableSize(cls, self):
        'availableSize(self) -> QSize'
        pass
    
    @classmethod
    def availableVirtualGeometry(cls, self):
        'availableVirtualGeometry(self) -> QRect'
        pass
    
    @classmethod
    def availableVirtualSize(cls, self):
        'availableVirtualSize(self) -> QSize'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def depth(cls, self):
        'depth(self) -> int'
        return 1
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def geometry(cls, self):
        'geometry(self) -> QRect'
        pass
    
    def geometryChanged(self, QRect):
        'geometryChanged(self, QRect) [signal]'
        pass
    
    @classmethod
    def grabWindow(cls, self, sipvoidptr, x: int=0, y: int=0, width: int=-1, height: int=-1):
        'grabWindow(self, sip.voidptr, x: int = 0, y: int = 0, width: int = -1, height: int = -1) -> QPixmap'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isLandscape(cls, self, QtScreenOrientation):
        'isLandscape(self, Qt.ScreenOrientation) -> bool'
        return True
    
    @classmethod
    def isPortrait(cls, self, QtScreenOrientation):
        'isPortrait(self, Qt.ScreenOrientation) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def logicalDotsPerInch(cls, self):
        'logicalDotsPerInch(self) -> float'
        return 1.0
    
    def logicalDotsPerInchChanged(self, float):
        'logicalDotsPerInchChanged(self, float) [signal]'
        pass
    
    @classmethod
    def logicalDotsPerInchX(cls, self):
        'logicalDotsPerInchX(self) -> float'
        return 1.0
    
    @classmethod
    def logicalDotsPerInchY(cls, self):
        'logicalDotsPerInchY(self) -> float'
        return 1.0
    
    @classmethod
    def manufacturer(cls, self):
        'manufacturer(self) -> str'
        return ''
    
    @classmethod
    def mapBetween(cls, self, QtScreenOrientation, QtScreenOrientation_, QRect):
        'mapBetween(self, Qt.ScreenOrientation, Qt.ScreenOrientation, QRect) -> QRect'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def model(cls, self):
        'model(self) -> str'
        return ''
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def name(cls, self):
        'name(self) -> str'
        return ''
    
    @classmethod
    def nativeOrientation(cls, self):
        'nativeOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def orientation(cls, self):
        'orientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def orientationUpdateMask(cls, self):
        'orientationUpdateMask(self) -> Qt.ScreenOrientations'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def physicalDotsPerInch(cls, self):
        'physicalDotsPerInch(self) -> float'
        return 1.0
    
    def physicalDotsPerInchChanged(self, float):
        'physicalDotsPerInchChanged(self, float) [signal]'
        pass
    
    @classmethod
    def physicalDotsPerInchX(cls, self):
        'physicalDotsPerInchX(self) -> float'
        return 1.0
    
    @classmethod
    def physicalDotsPerInchY(cls, self):
        'physicalDotsPerInchY(self) -> float'
        return 1.0
    
    @classmethod
    def physicalSize(cls, self):
        'physicalSize(self) -> QSizeF'
        pass
    
    def physicalSizeChanged(self, QSizeF):
        'physicalSizeChanged(self, QSizeF) [signal]'
        pass
    
    @classmethod
    def primaryOrientation(cls, self):
        'primaryOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def refreshRate(cls, self):
        'refreshRate(self) -> float'
        return 1.0
    
    def refreshRateChanged(self, float):
        'refreshRateChanged(self, float) [signal]'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def serialNumber(cls, self):
        'serialNumber(self) -> str'
        return ''
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOrientationUpdateMask(cls, self, UnionQtScreenOrientations=None, QtScreenOrientation=None):
        'setOrientationUpdateMask(self, Union[Qt.ScreenOrientations, Qt.ScreenOrientation])'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def transformBetween(cls, self, QtScreenOrientation, QtScreenOrientation_, QRect):
        'transformBetween(self, Qt.ScreenOrientation, Qt.ScreenOrientation, QRect) -> QTransform'
        pass
    
    @classmethod
    def virtualGeometry(cls, self):
        'virtualGeometry(self) -> QRect'
        pass
    
    def virtualGeometryChanged(self, QRect):
        'virtualGeometryChanged(self, QRect) [signal]'
        pass
    
    @classmethod
    def virtualSiblings(cls, self):
        'virtualSiblings(self) -> List[QScreen]'
        pass
    
    @classmethod
    def virtualSize(cls, self):
        'virtualSize(self) -> QSize'
        pass
    

class QScrollEvent(_mod_PyQt5_QtCore.QEvent):
    'QScrollEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QScrollEvent.ScrollState)\nQScrollEvent(QScrollEvent)'
    ScrollFinished = ScrollState()
    ScrollStarted = ScrollState()
    ScrollState = ScrollState()
    ScrollUpdated = ScrollState()
    __class__ = QScrollEvent
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, QScrollEventScrollState=None):
        'QScrollEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QScrollEvent.ScrollState)\nQScrollEvent(QScrollEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def contentPos(cls, self):
        'contentPos(self) -> QPointF'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def overshootDistance(cls, self):
        'overshootDistance(self) -> QPointF'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def scrollState(cls, self):
        'scrollState(self) -> QScrollEvent.ScrollState'
        pass
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QScrollPrepareEvent(_mod_PyQt5_QtCore.QEvent):
    'QScrollPrepareEvent(Union[QPointF, QPoint])\nQScrollPrepareEvent(QScrollPrepareEvent)'
    __class__ = QScrollPrepareEvent
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None):
        'QScrollPrepareEvent(Union[QPointF, QPoint])\nQScrollPrepareEvent(QScrollPrepareEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def contentPos(cls, self):
        'contentPos(self) -> QPointF'
        pass
    
    @classmethod
    def contentPosRange(cls, self):
        'contentPosRange(self) -> QRectF'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setContentPos(cls, self, UnionQPointF=None, QPoint=None):
        'setContentPos(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def setContentPosRange(cls, self, QRectF):
        'setContentPosRange(self, QRectF)'
        pass
    
    @classmethod
    def setViewportSize(cls, self, QSizeF):
        'setViewportSize(self, QSizeF)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def startPos(cls, self):
        'startPos(self) -> QPointF'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def viewportSize(cls, self):
        'viewportSize(self) -> QSizeF'
        pass
    

class QSessionManager(_mod_PyQt5_QtCore.QObject):
    RestartAnyway = RestartHint()
    RestartHint = RestartHint()
    RestartIfRunning = RestartHint()
    RestartImmediately = RestartHint()
    RestartNever = RestartHint()
    __class__ = QSessionManager
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def allowsErrorInteraction(cls, self):
        'allowsErrorInteraction(self) -> bool'
        return True
    
    @classmethod
    def allowsInteraction(cls, self):
        'allowsInteraction(self) -> bool'
        return True
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def cancel(cls, self):
        'cancel(self)'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def discardCommand(cls, self):
        'discardCommand(self) -> List[str]'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isPhase2(cls, self):
        'isPhase2(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def release(cls, self):
        'release(self)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def requestPhase2(cls, self):
        'requestPhase2(self)'
        pass
    
    @classmethod
    def restartCommand(cls, self):
        'restartCommand(self) -> List[str]'
        pass
    
    @classmethod
    def restartHint(cls, self):
        'restartHint(self) -> QSessionManager.RestartHint'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def sessionId(cls, self):
        'sessionId(self) -> str'
        return ''
    
    @classmethod
    def sessionKey(cls, self):
        'sessionKey(self) -> str'
        return ''
    
    @classmethod
    def setDiscardCommand(cls, self, Iterablestr=None):
        'setDiscardCommand(self, Iterable[str])'
        pass
    
    @classmethod
    def setManagerProperty(cls, self, str, Iterablestr=None):
        'setManagerProperty(self, str, str)\nsetManagerProperty(self, str, Iterable[str])'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRestartCommand(cls, self, Iterablestr=None):
        'setRestartCommand(self, Iterable[str])'
        pass
    
    @classmethod
    def setRestartHint(cls, self, QSessionManagerRestartHint):
        'setRestartHint(self, QSessionManager.RestartHint)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QShortcutEvent(_mod_PyQt5_QtCore.QEvent):
    'QShortcutEvent(Union[QKeySequence, QKeySequence.StandardKey, str, int], int, ambiguous: bool = False)\nQShortcutEvent(QShortcutEvent)'
    __class__ = QShortcutEvent
    __dict__ = {}
    def __init__(self, UnionQKeySequence=None, QKeySequenceStandardKey=None, str=None, int=None, int_=None, ambiguous: bool=False):
        'QShortcutEvent(Union[QKeySequence, QKeySequence.StandardKey, str, int], int, ambiguous: bool = False)\nQShortcutEvent(QShortcutEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def isAmbiguous(cls, self):
        'isAmbiguous(self) -> bool'
        return True
    
    @classmethod
    def key(cls, self):
        'key(self) -> QKeySequence'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def shortcutId(cls, self):
        'shortcutId(self) -> int'
        return 1
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QShowEvent(_mod_PyQt5_QtCore.QEvent):
    'QShowEvent()\nQShowEvent(QShowEvent)'
    __class__ = QShowEvent
    __dict__ = {}
    def __init__(self, QShowEvent):
        'QShowEvent()\nQShowEvent(QShowEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QStandardItem(_mod_sip.wrapper):
    'QStandardItem()\nQStandardItem(str)\nQStandardItem(QIcon, str)\nQStandardItem(int, columns: int = 1)\nQStandardItem(QStandardItem)'
    ItemType = ItemType()
    Type = ItemType()
    UserType = ItemType()
    __class__ = QStandardItem
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, int, columns: int=1):
        'QStandardItem()\nQStandardItem(str)\nQStandardItem(QIcon, str)\nQStandardItem(int, columns: int = 1)\nQStandardItem(QStandardItem)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def accessibleDescription(cls, self):
        'accessibleDescription(self) -> str'
        return ''
    
    @classmethod
    def accessibleText(cls, self):
        'accessibleText(self) -> str'
        return ''
    
    @classmethod
    def appendColumn(cls, self, IterableQStandardItem=None):
        'appendColumn(self, Iterable[QStandardItem])'
        pass
    
    @classmethod
    def appendRow(cls, self, IterableQStandardItem=None):
        'appendRow(self, Iterable[QStandardItem])\nappendRow(self, QStandardItem)'
        pass
    
    @classmethod
    def appendRows(cls, self, IterableQStandardItem=None):
        'appendRows(self, Iterable[QStandardItem])'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def checkState(cls, self):
        'checkState(self) -> Qt.CheckState'
        pass
    
    @classmethod
    def child(cls, self, int, column: int=0):
        'child(self, int, column: int = 0) -> QStandardItem'
        pass
    
    @classmethod
    def clone(cls, self):
        'clone(self) -> QStandardItem'
        pass
    
    @classmethod
    def column(cls, self):
        'column(self) -> int'
        return 1
    
    @classmethod
    def columnCount(cls, self):
        'columnCount(self) -> int'
        return 1
    
    @classmethod
    def data(cls, self, role: int=Qt.UserRole+1):
        'data(self, role: int = Qt.UserRole+1) -> Any'
        pass
    
    @classmethod
    def emitDataChanged(cls, self):
        'emitDataChanged(self)'
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.ItemFlags'
        pass
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasChildren(cls, self):
        'hasChildren(self) -> bool'
        return True
    
    @classmethod
    def icon(cls, self):
        'icon(self) -> QIcon'
        pass
    
    @classmethod
    def index(cls, self):
        'index(self) -> QModelIndex'
        pass
    
    @classmethod
    def insertColumn(cls, self, int, IterableQStandardItem=None):
        'insertColumn(self, int, Iterable[QStandardItem])'
        pass
    
    @classmethod
    def insertColumns(cls, self, int, int_):
        'insertColumns(self, int, int)'
        pass
    
    @classmethod
    def insertRow(cls, self, int, IterableQStandardItem=None):
        'insertRow(self, int, Iterable[QStandardItem])\ninsertRow(self, int, QStandardItem)'
        pass
    
    @classmethod
    def insertRows(cls, self, int, IterableQStandardItem=None):
        'insertRows(self, int, int)\ninsertRows(self, int, Iterable[QStandardItem])'
        pass
    
    @classmethod
    def isAutoTristate(cls, self):
        'isAutoTristate(self) -> bool'
        return True
    
    @classmethod
    def isCheckable(cls, self):
        'isCheckable(self) -> bool'
        return True
    
    @classmethod
    def isDragEnabled(cls, self):
        'isDragEnabled(self) -> bool'
        return True
    
    @classmethod
    def isDropEnabled(cls, self):
        'isDropEnabled(self) -> bool'
        return True
    
    @classmethod
    def isEditable(cls, self):
        'isEditable(self) -> bool'
        return True
    
    @classmethod
    def isEnabled(cls, self):
        'isEnabled(self) -> bool'
        return True
    
    @classmethod
    def isSelectable(cls, self):
        'isSelectable(self) -> bool'
        return True
    
    @classmethod
    def isTristate(cls, self):
        'isTristate(self) -> bool'
        return True
    
    @classmethod
    def isUserTristate(cls, self):
        'isUserTristate(self) -> bool'
        return True
    
    @classmethod
    def model(cls, self):
        'model(self) -> QStandardItemModel'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QStandardItem'
        pass
    
    @classmethod
    def read(cls, self, QDataStream):
        'read(self, QDataStream)'
        pass
    
    @classmethod
    def removeColumn(cls, self, int):
        'removeColumn(self, int)'
        pass
    
    @classmethod
    def removeColumns(cls, self, int, int_):
        'removeColumns(self, int, int)'
        pass
    
    @classmethod
    def removeRow(cls, self, int):
        'removeRow(self, int)'
        pass
    
    @classmethod
    def removeRows(cls, self, int, int_):
        'removeRows(self, int, int)'
        pass
    
    @classmethod
    def row(cls, self):
        'row(self) -> int'
        return 1
    
    @classmethod
    def rowCount(cls, self):
        'rowCount(self) -> int'
        return 1
    
    @classmethod
    def setAccessibleDescription(cls, self, str):
        'setAccessibleDescription(self, str)'
        pass
    
    @classmethod
    def setAccessibleText(cls, self, str):
        'setAccessibleText(self, str)'
        pass
    
    @classmethod
    def setAutoTristate(cls, self, bool):
        'setAutoTristate(self, bool)'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setCheckState(cls, self, QtCheckState):
        'setCheckState(self, Qt.CheckState)'
        pass
    
    @classmethod
    def setCheckable(cls, self, bool):
        'setCheckable(self, bool)'
        pass
    
    @classmethod
    def setChild(cls, self, int, int_, QStandardItem):
        'setChild(self, int, int, QStandardItem)\nsetChild(self, int, QStandardItem)'
        pass
    
    @classmethod
    def setColumnCount(cls, self, int):
        'setColumnCount(self, int)'
        pass
    
    @classmethod
    def setData(cls, self, Any, role: int=Qt.UserRole+1):
        'setData(self, Any, role: int = Qt.UserRole+1)'
        pass
    
    @classmethod
    def setDragEnabled(cls, self, bool):
        'setDragEnabled(self, bool)'
        pass
    
    @classmethod
    def setDropEnabled(cls, self, bool):
        'setDropEnabled(self, bool)'
        pass
    
    @classmethod
    def setEditable(cls, self, bool):
        'setEditable(self, bool)'
        pass
    
    @classmethod
    def setEnabled(cls, self, bool):
        'setEnabled(self, bool)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQtItemFlags=None, QtItemFlag=None):
        'setFlags(self, Union[Qt.ItemFlags, Qt.ItemFlag])'
        pass
    
    @classmethod
    def setFont(cls, self, QFont):
        'setFont(self, QFont)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setIcon(cls, self, QIcon):
        'setIcon(self, QIcon)'
        pass
    
    @classmethod
    def setRowCount(cls, self, int):
        'setRowCount(self, int)'
        pass
    
    @classmethod
    def setSelectable(cls, self, bool):
        'setSelectable(self, bool)'
        pass
    
    @classmethod
    def setSizeHint(cls, self, QSize):
        'setSizeHint(self, QSize)'
        pass
    
    @classmethod
    def setStatusTip(cls, self, str):
        'setStatusTip(self, str)'
        pass
    
    @classmethod
    def setText(cls, self, str):
        'setText(self, str)'
        pass
    
    @classmethod
    def setTextAlignment(cls, self, UnionQtAlignment=None, QtAlignmentFlag=None):
        'setTextAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag])'
        pass
    
    @classmethod
    def setToolTip(cls, self, str):
        'setToolTip(self, str)'
        pass
    
    @classmethod
    def setTristate(cls, self, bool):
        'setTristate(self, bool)'
        pass
    
    @classmethod
    def setUserTristate(cls, self, bool):
        'setUserTristate(self, bool)'
        pass
    
    @classmethod
    def setWhatsThis(cls, self, str):
        'setWhatsThis(self, str)'
        pass
    
    @classmethod
    def sizeHint(cls, self):
        'sizeHint(self) -> QSize'
        pass
    
    @classmethod
    def sortChildren(cls, self, int, order: Qt.SortOrder=Qt.AscendingOrder):
        'sortChildren(self, int, order: Qt.SortOrder = Qt.AscendingOrder)'
        pass
    
    @classmethod
    def statusTip(cls, self):
        'statusTip(self) -> str'
        return ''
    
    @classmethod
    def takeChild(cls, self, int, column: int=0):
        'takeChild(self, int, column: int = 0) -> QStandardItem'
        pass
    
    @classmethod
    def takeColumn(cls, self, int):
        'takeColumn(self, int) -> List[QStandardItem]'
        pass
    
    @classmethod
    def takeRow(cls, self, int):
        'takeRow(self, int) -> List[QStandardItem]'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def textAlignment(cls, self):
        'textAlignment(self) -> Qt.Alignment'
        pass
    
    @classmethod
    def toolTip(cls, self):
        'toolTip(self) -> str'
        return ''
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def whatsThis(cls, self):
        'whatsThis(self) -> str'
        return ''
    
    @classmethod
    def write(cls, self, QDataStream):
        'write(self, QDataStream)'
        pass
    

class QStandardItemModel(_mod_PyQt5_QtCore.QAbstractItemModel):
    'QStandardItemModel(parent: QObject = None)\nQStandardItemModel(int, int, parent: QObject = None)'
    __class__ = QStandardItemModel
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, int, int_, parent: QObject=None):
        'QStandardItemModel(parent: QObject = None)\nQStandardItemModel(int, int, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def appendColumn(cls, self, IterableQStandardItem=None):
        'appendColumn(self, Iterable[QStandardItem])'
        pass
    
    @classmethod
    def appendRow(cls, self, QStandardItem):
        'appendRow(self, object)\nappendRow(self, QStandardItem)'
        pass
    
    @classmethod
    def beginInsertColumns(cls, self, QModelIndex, int, int_):
        'beginInsertColumns(self, QModelIndex, int, int)'
        pass
    
    @classmethod
    def beginInsertRows(cls, self, QModelIndex, int, int_):
        'beginInsertRows(self, QModelIndex, int, int)'
        pass
    
    @classmethod
    def beginMoveColumns(cls, self, QModelIndex, int, int_, QModelIndex_, int_1):
        'beginMoveColumns(self, QModelIndex, int, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def beginMoveRows(cls, self, QModelIndex, int, int_, QModelIndex_, int_1):
        'beginMoveRows(self, QModelIndex, int, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def beginRemoveColumns(cls, self, QModelIndex, int, int_):
        'beginRemoveColumns(self, QModelIndex, int, int)'
        pass
    
    @classmethod
    def beginRemoveRows(cls, self, QModelIndex, int, int_):
        'beginRemoveRows(self, QModelIndex, int, int)'
        pass
    
    @classmethod
    def beginResetModel(cls, self):
        'beginResetModel(self)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def buddy(cls, self, QModelIndex):
        'buddy(self, QModelIndex) -> QModelIndex'
        pass
    
    @classmethod
    def canDropMimeData(cls, self, QMimeData, QtDropAction, int, int_, QModelIndex):
        'canDropMimeData(self, QMimeData, Qt.DropAction, int, int, QModelIndex) -> bool'
        return True
    
    @classmethod
    def canFetchMore(cls, self, QModelIndex):
        'canFetchMore(self, QModelIndex) -> bool'
        return True
    
    @classmethod
    def changePersistentIndex(cls, self, QModelIndex, QModelIndex_):
        'changePersistentIndex(self, QModelIndex, QModelIndex)'
        pass
    
    @classmethod
    def changePersistentIndexList(cls, self, object, object_):
        'changePersistentIndexList(self, object, object)'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def columnCount(cls, self, parent: QModelIndex=QModelIndex()):
        'columnCount(self, parent: QModelIndex = QModelIndex()) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def createIndex(cls, self, int, int_, object: object=0):
        'createIndex(self, int, int, object: object = 0) -> QModelIndex'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def data(cls, self, QModelIndex, role: int=Qt.DisplayRole):
        'data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any'
        pass
    
    @classmethod
    def decodeData(cls, self, int, int_, QModelIndex, QDataStream):
        'decodeData(self, int, int, QModelIndex, QDataStream) -> bool'
        return True
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dropMimeData(cls, self, QMimeData, QtDropAction, int, int_, QModelIndex):
        'dropMimeData(self, QMimeData, Qt.DropAction, int, int, QModelIndex) -> bool'
        return True
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def encodeData(cls, self, object, QDataStream):
        'encodeData(self, object, QDataStream)'
        pass
    
    @classmethod
    def endInsertColumns(cls, self):
        'endInsertColumns(self)'
        pass
    
    @classmethod
    def endInsertRows(cls, self):
        'endInsertRows(self)'
        pass
    
    @classmethod
    def endMoveColumns(cls, self):
        'endMoveColumns(self)'
        pass
    
    @classmethod
    def endMoveRows(cls, self):
        'endMoveRows(self)'
        pass
    
    @classmethod
    def endRemoveColumns(cls, self):
        'endRemoveColumns(self)'
        pass
    
    @classmethod
    def endRemoveRows(cls, self):
        'endRemoveRows(self)'
        pass
    
    @classmethod
    def endResetModel(cls, self):
        'endResetModel(self)'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def fetchMore(cls, self, QModelIndex):
        'fetchMore(self, QModelIndex)'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def findItems(cls, self, str, flags: Union[Qt.MatchFlags,Qt.MatchFlag]=Qt.MatchExactly, column: int=0):
        'findItems(self, str, flags: Union[Qt.MatchFlags, Qt.MatchFlag] = Qt.MatchExactly, column: int = 0) -> List[QStandardItem]'
        pass
    
    @classmethod
    def flags(cls, self, QModelIndex):
        'flags(self, QModelIndex) -> Qt.ItemFlags'
        pass
    
    @classmethod
    def hasChildren(cls, self, parent: QModelIndex=QModelIndex()):
        'hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def hasIndex(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'hasIndex(self, int, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def headerData(cls, self, int, QtOrientation, role: int=Qt.DisplayRole):
        'headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any'
        pass
    
    @classmethod
    def horizontalHeaderItem(cls, self, int):
        'horizontalHeaderItem(self, int) -> QStandardItem'
        pass
    
    @classmethod
    def index(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex'
        pass
    
    @classmethod
    def indexFromItem(cls, self, QStandardItem):
        'indexFromItem(self, QStandardItem) -> QModelIndex'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def insertColumn(cls, self, int, parent: QModelIndex=QModelIndex()):
        'insertColumn(self, int, Iterable[QStandardItem])\ninsertColumn(self, int, parent: QModelIndex = QModelIndex()) -> bool'
        pass
    
    @classmethod
    def insertColumns(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'insertColumns(self, int, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def insertRow(cls, self, int, parent: QModelIndex=QModelIndex()):
        'insertRow(self, int, Iterable[QStandardItem])\ninsertRow(self, int, QStandardItem)\ninsertRow(self, int, parent: QModelIndex = QModelIndex()) -> bool'
        pass
    
    @classmethod
    def insertRows(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'insertRows(self, int, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def invisibleRootItem(cls, self):
        'invisibleRootItem(self) -> QStandardItem'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def item(cls, self, int, column: int=0):
        'item(self, int, column: int = 0) -> QStandardItem'
        pass
    
    def itemChanged(self, QStandardItem):
        'itemChanged(self, QStandardItem) [signal]'
        pass
    
    @classmethod
    def itemData(cls, self, QModelIndex):
        'itemData(self, QModelIndex) -> Dict[int, Any]'
        pass
    
    @classmethod
    def itemFromIndex(cls, self, QModelIndex):
        'itemFromIndex(self, QModelIndex) -> QStandardItem'
        pass
    
    @classmethod
    def itemPrototype(cls, self):
        'itemPrototype(self) -> QStandardItem'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def match(cls, self, QModelIndex, int, Any, hits: int=1, flags: Union[Qt.MatchFlags,Qt.MatchFlag]=Qt.MatchStartsWith|Qt.MatchWrap):
        'match(self, QModelIndex, int, Any, hits: int = 1, flags: Union[Qt.MatchFlags, Qt.MatchFlag] = Qt.MatchStartsWith|Qt.MatchWrap) -> object'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def mimeData(cls, self, object):
        'mimeData(self, object) -> QMimeData'
        pass
    
    @classmethod
    def mimeTypes(cls, self):
        'mimeTypes(self) -> List[str]'
        pass
    
    @classmethod
    def moveColumn(cls, self, QModelIndex, int, QModelIndex_, int_):
        'moveColumn(self, QModelIndex, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def moveColumns(cls, self, QModelIndex, int, int_, QModelIndex_, int_1):
        'moveColumns(self, QModelIndex, int, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def moveRow(cls, self, QModelIndex, int, QModelIndex_, int_):
        'moveRow(self, QModelIndex, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def moveRows(cls, self, QModelIndex, int, int_, QModelIndex_, int_1):
        'moveRows(self, QModelIndex, int, int, QModelIndex, int) -> bool'
        return True
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self, QModelIndex):
        'parent(self, QModelIndex) -> QModelIndex\nparent(self) -> QObject'
        pass
    
    @classmethod
    def persistentIndexList(cls, self):
        'persistentIndexList(self) -> object'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeColumn(cls, self, int, parent: QModelIndex=QModelIndex()):
        'removeColumn(self, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def removeColumns(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'removeColumns(self, int, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def removeRow(cls, self, int, parent: QModelIndex=QModelIndex()):
        'removeRow(self, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def removeRows(cls, self, int, int_, parent: QModelIndex=QModelIndex()):
        'removeRows(self, int, int, parent: QModelIndex = QModelIndex()) -> bool'
        return True
    
    @classmethod
    def resetInternalData(cls, self):
        'resetInternalData(self)'
        pass
    
    @classmethod
    def revert(cls, self):
        'revert(self)'
        pass
    
    @classmethod
    def roleNames(cls, self):
        'roleNames(self) -> object'
        pass
    
    @classmethod
    def rowCount(cls, self, parent: QModelIndex=QModelIndex()):
        'rowCount(self, parent: QModelIndex = QModelIndex()) -> int'
        return 1
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setColumnCount(cls, self, int):
        'setColumnCount(self, int)'
        pass
    
    @classmethod
    def setData(cls, self, QModelIndex, Any, role: int=Qt.EditRole):
        'setData(self, QModelIndex, Any, role: int = Qt.EditRole) -> bool'
        return True
    
    @classmethod
    def setHeaderData(cls, self, int, QtOrientation, Any, role: int=Qt.EditRole):
        'setHeaderData(self, int, Qt.Orientation, Any, role: int = Qt.EditRole) -> bool'
        return True
    
    @classmethod
    def setHorizontalHeaderItem(cls, self, int, QStandardItem):
        'setHorizontalHeaderItem(self, int, QStandardItem)'
        pass
    
    @classmethod
    def setHorizontalHeaderLabels(cls, self, Iterablestr=None):
        'setHorizontalHeaderLabels(self, Iterable[str])'
        pass
    
    @classmethod
    def setItem(cls, self, int, int_, QStandardItem):
        'setItem(self, int, int, QStandardItem)\nsetItem(self, int, QStandardItem)'
        pass
    
    @classmethod
    def setItemData(cls, self, QModelIndex, Dictint=None, Any=None):
        'setItemData(self, QModelIndex, Dict[int, Any]) -> bool'
        return True
    
    @classmethod
    def setItemPrototype(cls, self, QStandardItem):
        'setItemPrototype(self, QStandardItem)'
        pass
    
    @classmethod
    def setItemRoleNames(cls, self, Dictint=None, UnionQByteArray=None, bytes=None, bytearray=None):
        'setItemRoleNames(self, Dict[int, Union[QByteArray, bytes, bytearray]])'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setRowCount(cls, self, int):
        'setRowCount(self, int)'
        pass
    
    @classmethod
    def setSortRole(cls, self, int):
        'setSortRole(self, int)'
        pass
    
    @classmethod
    def setVerticalHeaderItem(cls, self, int, QStandardItem):
        'setVerticalHeaderItem(self, int, QStandardItem)'
        pass
    
    @classmethod
    def setVerticalHeaderLabels(cls, self, Iterablestr=None):
        'setVerticalHeaderLabels(self, Iterable[str])'
        pass
    
    @classmethod
    def sibling(cls, self, int, int_, QModelIndex):
        'sibling(self, int, int, QModelIndex) -> QModelIndex'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def sort(cls, self, int, order: Qt.SortOrder=Qt.AscendingOrder):
        'sort(self, int, order: Qt.SortOrder = Qt.AscendingOrder)'
        pass
    
    @classmethod
    def sortRole(cls, self):
        'sortRole(self) -> int'
        return 1
    
    @classmethod
    def span(cls, self, QModelIndex):
        'span(self, QModelIndex) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def submit(cls, self):
        'submit(self) -> bool'
        return True
    
    @classmethod
    def supportedDragActions(cls, self):
        'supportedDragActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def supportedDropActions(cls, self):
        'supportedDropActions(self) -> Qt.DropActions'
        pass
    
    @classmethod
    def takeColumn(cls, self, int):
        'takeColumn(self, int) -> List[QStandardItem]'
        pass
    
    @classmethod
    def takeHorizontalHeaderItem(cls, self, int):
        'takeHorizontalHeaderItem(self, int) -> QStandardItem'
        pass
    
    @classmethod
    def takeItem(cls, self, int, column: int=0):
        'takeItem(self, int, column: int = 0) -> QStandardItem'
        pass
    
    @classmethod
    def takeRow(cls, self, int):
        'takeRow(self, int) -> List[QStandardItem]'
        pass
    
    @classmethod
    def takeVerticalHeaderItem(cls, self, int):
        'takeVerticalHeaderItem(self, int) -> QStandardItem'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def verticalHeaderItem(cls, self, int):
        'verticalHeaderItem(self, int) -> QStandardItem'
        pass
    

class QStaticText(_mod_sip.simplewrapper):
    'QStaticText()\nQStaticText(str)\nQStaticText(QStaticText)'
    AggressiveCaching = PerformanceHint()
    ModerateCaching = PerformanceHint()
    PerformanceHint = PerformanceHint()
    __class__ = QStaticText
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QStaticText):
        'QStaticText()\nQStaticText(str)\nQStaticText(QStaticText)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def performanceHint(cls, self):
        'performanceHint(self) -> QStaticText.PerformanceHint'
        pass
    
    @classmethod
    def prepare(cls, self, matrix: QTransform=QTransform(), font: QFont=QFont()):
        'prepare(self, matrix: QTransform = QTransform(), font: QFont = QFont())'
        pass
    
    @classmethod
    def setPerformanceHint(cls, self, QStaticTextPerformanceHint):
        'setPerformanceHint(self, QStaticText.PerformanceHint)'
        pass
    
    @classmethod
    def setText(cls, self, str):
        'setText(self, str)'
        pass
    
    @classmethod
    def setTextFormat(cls, self, QtTextFormat):
        'setTextFormat(self, Qt.TextFormat)'
        pass
    
    @classmethod
    def setTextOption(cls, self, QTextOption):
        'setTextOption(self, QTextOption)'
        pass
    
    @classmethod
    def setTextWidth(cls, self, float):
        'setTextWidth(self, float)'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSizeF'
        pass
    
    @classmethod
    def swap(cls, self, QStaticText):
        'swap(self, QStaticText)'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def textFormat(cls, self):
        'textFormat(self) -> Qt.TextFormat'
        pass
    
    @classmethod
    def textOption(cls, self):
        'textOption(self) -> QTextOption'
        pass
    
    @classmethod
    def textWidth(cls, self):
        'textWidth(self) -> float'
        return 1.0
    

class QStatusTipEvent(_mod_PyQt5_QtCore.QEvent):
    'QStatusTipEvent(str)\nQStatusTipEvent(QStatusTipEvent)'
    __class__ = QStatusTipEvent
    __dict__ = {}
    def __init__(self, QStatusTipEvent):
        'QStatusTipEvent(str)\nQStatusTipEvent(QStatusTipEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def tip(cls, self):
        'tip(self) -> str'
        return ''
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QStyleHints(_mod_PyQt5_QtCore.QObject):
    __class__ = QStyleHints
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def cursorFlashTime(cls, self):
        'cursorFlashTime(self) -> int'
        return 1
    
    def cursorFlashTimeChanged(self, int):
        'cursorFlashTimeChanged(self, int) [signal]'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fontSmoothingGamma(cls, self):
        'fontSmoothingGamma(self) -> float'
        return 1.0
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyboardAutoRepeatRate(cls, self):
        'keyboardAutoRepeatRate(self) -> int'
        return 1
    
    @classmethod
    def keyboardInputInterval(cls, self):
        'keyboardInputInterval(self) -> int'
        return 1
    
    def keyboardInputIntervalChanged(self, int):
        'keyboardInputIntervalChanged(self, int) [signal]'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def mouseDoubleClickInterval(cls, self):
        'mouseDoubleClickInterval(self) -> int'
        return 1
    
    def mouseDoubleClickIntervalChanged(self, int):
        'mouseDoubleClickIntervalChanged(self, int) [signal]'
        pass
    
    @classmethod
    def mousePressAndHoldInterval(cls, self):
        'mousePressAndHoldInterval(self) -> int'
        return 1
    
    def mousePressAndHoldIntervalChanged(self, int):
        'mousePressAndHoldIntervalChanged(self, int) [signal]'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def passwordMaskCharacter(cls, self):
        'passwordMaskCharacter(self) -> str'
        return ''
    
    @classmethod
    def passwordMaskDelay(cls, self):
        'passwordMaskDelay(self) -> int'
        return 1
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFocusOnTouchRelease(cls, self):
        'setFocusOnTouchRelease(self) -> bool'
        return True
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setUseHoverEffects(cls, self, bool):
        'setUseHoverEffects(self, bool)'
        pass
    
    @classmethod
    def showIsFullScreen(cls, self):
        'showIsFullScreen(self) -> bool'
        return True
    
    @classmethod
    def showIsMaximized(cls, self):
        'showIsMaximized(self) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def singleClickActivation(cls, self):
        'singleClickActivation(self) -> bool'
        return True
    
    @classmethod
    def startDragDistance(cls, self):
        'startDragDistance(self) -> int'
        return 1
    
    def startDragDistanceChanged(self, int):
        'startDragDistanceChanged(self, int) [signal]'
        pass
    
    @classmethod
    def startDragTime(cls, self):
        'startDragTime(self) -> int'
        return 1
    
    def startDragTimeChanged(self, int):
        'startDragTimeChanged(self, int) [signal]'
        pass
    
    @classmethod
    def startDragVelocity(cls, self):
        'startDragVelocity(self) -> int'
        return 1
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def tabFocusBehavior(cls, self):
        'tabFocusBehavior(self) -> Qt.TabFocusBehavior'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def useHoverEffects(cls, self):
        'useHoverEffects(self) -> bool'
        return True
    
    def useHoverEffectsChanged(self, bool):
        'useHoverEffectsChanged(self, bool) [signal]'
        pass
    
    @classmethod
    def useRtlExtensions(cls, self):
        'useRtlExtensions(self) -> bool'
        return True
    
    @classmethod
    def wheelScrollLines(cls, self):
        'wheelScrollLines(self) -> int'
        return 1
    
    def wheelScrollLinesChanged(self, int):
        'wheelScrollLinesChanged(self, int) [signal]'
        pass
    

class QSurface(_mod_sip.simplewrapper):
    Offscreen = SurfaceClass()
    OpenGLSurface = SurfaceType()
    OpenVGSurface = SurfaceType()
    RasterGLSurface = SurfaceType()
    RasterSurface = SurfaceType()
    SurfaceClass = SurfaceClass()
    SurfaceType = SurfaceType()
    Window = SurfaceClass()
    __class__ = QSurface
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    

class QSurfaceFormat(_mod_sip.simplewrapper):
    'QSurfaceFormat()\nQSurfaceFormat(Union[QSurfaceFormat.FormatOptions, QSurfaceFormat.FormatOption])\nQSurfaceFormat(QSurfaceFormat)'
    CompatibilityProfile = OpenGLContextProfile()
    CoreProfile = OpenGLContextProfile()
    DebugContext = FormatOption()
    DefaultRenderableType = RenderableType()
    DefaultSwapBehavior = SwapBehavior()
    DeprecatedFunctions = FormatOption()
    DoubleBuffer = SwapBehavior()
    FormatOption = FormatOption()
    FormatOptions = FormatOptions()
    NoProfile = OpenGLContextProfile()
    OpenGL = RenderableType()
    OpenGLContextProfile = OpenGLContextProfile()
    OpenGLES = RenderableType()
    OpenVG = RenderableType()
    RenderableType = RenderableType()
    ResetNotification = FormatOption()
    SingleBuffer = SwapBehavior()
    StereoBuffers = FormatOption()
    SwapBehavior = SwapBehavior()
    TripleBuffer = SwapBehavior()
    __class__ = QSurfaceFormat
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, UnionQSurfaceFormatFormatOptions=None, QSurfaceFormatFormatOption=None):
        'QSurfaceFormat()\nQSurfaceFormat(Union[QSurfaceFormat.FormatOptions, QSurfaceFormat.FormatOption])\nQSurfaceFormat(QSurfaceFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alphaBufferSize(cls, self):
        'alphaBufferSize(self) -> int'
        return 1
    
    @classmethod
    def blueBufferSize(cls, self):
        'blueBufferSize(self) -> int'
        return 1
    
    @classmethod
    def defaultFormat(cls):
        'defaultFormat() -> QSurfaceFormat'
        pass
    
    @classmethod
    def depthBufferSize(cls, self):
        'depthBufferSize(self) -> int'
        return 1
    
    @classmethod
    def greenBufferSize(cls, self):
        'greenBufferSize(self) -> int'
        return 1
    
    @classmethod
    def hasAlpha(cls, self):
        'hasAlpha(self) -> bool'
        return True
    
    @classmethod
    def majorVersion(cls, self):
        'majorVersion(self) -> int'
        return 1
    
    @classmethod
    def minorVersion(cls, self):
        'minorVersion(self) -> int'
        return 1
    
    @classmethod
    def options(cls, self):
        'options(self) -> QSurfaceFormat.FormatOptions'
        pass
    
    @classmethod
    def profile(cls, self):
        'profile(self) -> QSurfaceFormat.OpenGLContextProfile'
        pass
    
    @classmethod
    def redBufferSize(cls, self):
        'redBufferSize(self) -> int'
        return 1
    
    @classmethod
    def renderableType(cls, self):
        'renderableType(self) -> QSurfaceFormat.RenderableType'
        pass
    
    @classmethod
    def samples(cls, self):
        'samples(self) -> int'
        return 1
    
    @classmethod
    def setAlphaBufferSize(cls, self, int):
        'setAlphaBufferSize(self, int)'
        pass
    
    @classmethod
    def setBlueBufferSize(cls, self, int):
        'setBlueBufferSize(self, int)'
        pass
    
    @classmethod
    def setDefaultFormat(cls, QSurfaceFormat):
        'setDefaultFormat(QSurfaceFormat)'
        pass
    
    @classmethod
    def setDepthBufferSize(cls, self, int):
        'setDepthBufferSize(self, int)'
        pass
    
    @classmethod
    def setGreenBufferSize(cls, self, int):
        'setGreenBufferSize(self, int)'
        pass
    
    @classmethod
    def setMajorVersion(cls, self, int):
        'setMajorVersion(self, int)'
        pass
    
    @classmethod
    def setMinorVersion(cls, self, int):
        'setMinorVersion(self, int)'
        pass
    
    @classmethod
    def setOption(cls, self, UnionQSurfaceFormatFormatOptions=None, QSurfaceFormatFormatOption=None):
        'setOption(self, Union[QSurfaceFormat.FormatOptions, QSurfaceFormat.FormatOption])\nsetOption(self, QSurfaceFormat.FormatOption, on: bool = True)'
        pass
    
    @classmethod
    def setOptions(cls, self, UnionQSurfaceFormatFormatOptions=None, QSurfaceFormatFormatOption=None):
        'setOptions(self, Union[QSurfaceFormat.FormatOptions, QSurfaceFormat.FormatOption])'
        pass
    
    @classmethod
    def setProfile(cls, self, QSurfaceFormatOpenGLContextProfile):
        'setProfile(self, QSurfaceFormat.OpenGLContextProfile)'
        pass
    
    @classmethod
    def setRedBufferSize(cls, self, int):
        'setRedBufferSize(self, int)'
        pass
    
    @classmethod
    def setRenderableType(cls, self, QSurfaceFormatRenderableType):
        'setRenderableType(self, QSurfaceFormat.RenderableType)'
        pass
    
    @classmethod
    def setSamples(cls, self, int):
        'setSamples(self, int)'
        pass
    
    @classmethod
    def setStencilBufferSize(cls, self, int):
        'setStencilBufferSize(self, int)'
        pass
    
    @classmethod
    def setStereo(cls, self, bool):
        'setStereo(self, bool)'
        pass
    
    @classmethod
    def setSwapBehavior(cls, self, QSurfaceFormatSwapBehavior):
        'setSwapBehavior(self, QSurfaceFormat.SwapBehavior)'
        pass
    
    @classmethod
    def setSwapInterval(cls, self, int):
        'setSwapInterval(self, int)'
        pass
    
    @classmethod
    def setVersion(cls, self, int, int_):
        'setVersion(self, int, int)'
        pass
    
    @classmethod
    def stencilBufferSize(cls, self):
        'stencilBufferSize(self) -> int'
        return 1
    
    @classmethod
    def stereo(cls, self):
        'stereo(self) -> bool'
        return True
    
    @classmethod
    def swapBehavior(cls, self):
        'swapBehavior(self) -> QSurfaceFormat.SwapBehavior'
        pass
    
    @classmethod
    def swapInterval(cls, self):
        'swapInterval(self) -> int'
        return 1
    
    @classmethod
    def testOption(cls, self, UnionQSurfaceFormatFormatOptions=None, QSurfaceFormatFormatOption=None):
        'testOption(self, Union[QSurfaceFormat.FormatOptions, QSurfaceFormat.FormatOption]) -> bool\ntestOption(self, QSurfaceFormat.FormatOption) -> bool'
        return True
    
    @classmethod
    def version(cls, self):
        'version(self) -> Tuple[int, int]'
        pass
    

class QSyntaxHighlighter(_mod_PyQt5_QtCore.QObject):
    'QSyntaxHighlighter(QTextDocument)\nQSyntaxHighlighter(QObject)'
    __class__ = QSyntaxHighlighter
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QSyntaxHighlighter(QTextDocument)\nQSyntaxHighlighter(QObject)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def currentBlock(cls, self):
        'currentBlock(self) -> QTextBlock'
        pass
    
    @classmethod
    def currentBlockState(cls, self):
        'currentBlockState(self) -> int'
        return 1
    
    @classmethod
    def currentBlockUserData(cls, self):
        'currentBlockUserData(self) -> QTextBlockUserData'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self, int):
        'format(self, int) -> QTextCharFormat'
        pass
    
    @classmethod
    def highlightBlock(cls, self, str):
        'highlightBlock(self, str)'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def previousBlockState(cls, self):
        'previousBlockState(self) -> int'
        return 1
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def rehighlight(cls, self):
        'rehighlight(self)'
        pass
    
    @classmethod
    def rehighlightBlock(cls, self, QTextBlock):
        'rehighlightBlock(self, QTextBlock)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setCurrentBlockState(cls, self, int):
        'setCurrentBlockState(self, int)'
        pass
    
    @classmethod
    def setCurrentBlockUserData(cls, self, QTextBlockUserData):
        'setCurrentBlockUserData(self, QTextBlockUserData)'
        pass
    
    @classmethod
    def setDocument(cls, self, QTextDocument):
        'setDocument(self, QTextDocument)'
        pass
    
    @classmethod
    def setFormat(cls, self, int, int_, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setFormat(self, int, int, QTextCharFormat)\nsetFormat(self, int, int, Union[QColor, Qt.GlobalColor, QGradient])\nsetFormat(self, int, int, QFont)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTabletEvent(QInputEvent):
    'QTabletEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], int, int, float, int, int, float, float, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int, Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton])\nQTabletEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], int, int, float, int, int, float, float, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int)\nQTabletEvent(QTabletEvent)'
    Airbrush = TabletDevice()
    Cursor = PointerType()
    Eraser = PointerType()
    FourDMouse = TabletDevice()
    NoDevice = TabletDevice()
    Pen = PointerType()
    PointerType = PointerType()
    Puck = TabletDevice()
    RotationStylus = TabletDevice()
    Stylus = TabletDevice()
    TabletDevice = TabletDevice()
    UnknownPointer = PointerType()
    XFreeEraser = TabletDevice()
    __class__ = QTabletEvent
    __dict__ = {}
    def __init__(self, QEventType, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, int=None, int_=None, float=None, int_1=None, int_2=None, float_=None, float_1=None, int_3=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, int_4=None, QtMouseButton=None, UnionQtMouseButtons=None, QtMouseButton_=None):
        'QTabletEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], int, int, float, int, int, float, float, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int, Qt.MouseButton, Union[Qt.MouseButtons, Qt.MouseButton])\nQTabletEvent(QEvent.Type, Union[QPointF, QPoint], Union[QPointF, QPoint], int, int, float, int, int, float, float, int, Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], int)\nQTabletEvent(QTabletEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def button(cls, self):
        'button(self) -> Qt.MouseButton'
        pass
    
    @classmethod
    def buttons(cls, self):
        'buttons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QTabletEvent.TabletDevice'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalPosF(cls, self):
        'globalPosF(self) -> QPointF'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def hiResGlobalX(cls, self):
        'hiResGlobalX(self) -> float'
        return 1.0
    
    @classmethod
    def hiResGlobalY(cls, self):
        'hiResGlobalY(self) -> float'
        return 1.0
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def pointerType(cls, self):
        'pointerType(self) -> QTabletEvent.PointerType'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def pressure(cls, self):
        'pressure(self) -> float'
        return 1.0
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def rotation(cls, self):
        'rotation(self) -> float'
        return 1.0
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def tangentialPressure(cls, self):
        'tangentialPressure(self) -> float'
        return 1.0
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def uniqueId(cls, self):
        'uniqueId(self) -> int'
        return 1
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def xTilt(cls, self):
        'xTilt(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    
    @classmethod
    def yTilt(cls, self):
        'yTilt(self) -> int'
        return 1
    
    @classmethod
    def z(cls, self):
        'z(self) -> int'
        return 1
    

class QTextBlock(_mod_sip.wrapper):
    'QTextBlock()\nQTextBlock(QTextBlock)'
    __class__ = QTextBlock
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextBlock):
        'QTextBlock()\nQTextBlock(QTextBlock)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def begin(cls, self):
        'begin(self) -> QTextBlock.iterator'
        pass
    
    @classmethod
    def blockFormat(cls, self):
        'blockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def blockFormatIndex(cls, self):
        'blockFormatIndex(self) -> int'
        return 1
    
    @classmethod
    def blockNumber(cls, self):
        'blockNumber(self) -> int'
        return 1
    
    @classmethod
    def charFormat(cls, self):
        'charFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def charFormatIndex(cls, self):
        'charFormatIndex(self) -> int'
        return 1
    
    @classmethod
    def clearLayout(cls, self):
        'clearLayout(self)'
        pass
    
    @classmethod
    def contains(cls, self, int):
        'contains(self, int) -> bool'
        return True
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> QTextBlock.iterator'
        pass
    
    @classmethod
    def firstLineNumber(cls, self):
        'firstLineNumber(self) -> int'
        return 1
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    iterator = iterator()
    @classmethod
    def layout(cls, self):
        'layout(self) -> QTextLayout'
        pass
    
    @classmethod
    def length(cls, self):
        'length(self) -> int'
        return 1
    
    @classmethod
    def lineCount(cls, self):
        'lineCount(self) -> int'
        return 1
    
    @classmethod
    def next(cls, self):
        'next(self) -> QTextBlock'
        pass
    
    @classmethod
    def position(cls, self):
        'position(self) -> int'
        return 1
    
    @classmethod
    def previous(cls, self):
        'previous(self) -> QTextBlock'
        pass
    
    @classmethod
    def revision(cls, self):
        'revision(self) -> int'
        return 1
    
    @classmethod
    def setLineCount(cls, self, int):
        'setLineCount(self, int)'
        pass
    
    @classmethod
    def setRevision(cls, self, int):
        'setRevision(self, int)'
        pass
    
    @classmethod
    def setUserData(cls, self, QTextBlockUserData):
        'setUserData(self, QTextBlockUserData)'
        pass
    
    @classmethod
    def setUserState(cls, self, int):
        'setUserState(self, int)'
        pass
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def textDirection(cls, self):
        'textDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def textFormats(cls, self):
        'textFormats(self) -> List[QTextLayout.FormatRange]'
        pass
    
    @classmethod
    def textList(cls, self):
        'textList(self) -> QTextList'
        pass
    
    @classmethod
    def userData(cls, self):
        'userData(self) -> QTextBlockUserData'
        pass
    
    @classmethod
    def userState(cls, self):
        'userState(self) -> int'
        return 1
    

class QTextBlockFormat(QTextFormat):
    'QTextBlockFormat()\nQTextBlockFormat(QTextBlockFormat)'
    FixedHeight = LineHeightTypes()
    LineDistanceHeight = LineHeightTypes()
    LineHeightTypes = LineHeightTypes()
    MinimumHeight = LineHeightTypes()
    ProportionalHeight = LineHeightTypes()
    SingleHeight = LineHeightTypes()
    __class__ = QTextBlockFormat
    __dict__ = {}
    def __init__(self, QTextBlockFormat):
        'QTextBlockFormat()\nQTextBlockFormat(QTextBlockFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def alignment(cls, self):
        'alignment(self) -> Qt.Alignment'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def bottomMargin(cls, self):
        'bottomMargin(self) -> float'
        return 1.0
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def indent(cls, self):
        'indent(self) -> int'
        return 1
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def leftMargin(cls, self):
        'leftMargin(self) -> float'
        return 1.0
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def lineHeight(cls, self, float, float_):
        'lineHeight(self, float, float) -> float\nlineHeight(self) -> float'
        return 1.0
    
    @classmethod
    def lineHeightType(cls, self):
        'lineHeightType(self) -> int'
        return 1
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def nonBreakableLines(cls, self):
        'nonBreakableLines(self) -> bool'
        return True
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def pageBreakPolicy(cls, self):
        'pageBreakPolicy(self) -> QTextFormat.PageBreakFlags'
        pass
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def rightMargin(cls, self):
        'rightMargin(self) -> float'
        return 1.0
    
    @classmethod
    def setAlignment(cls, self, UnionQtAlignment=None, QtAlignmentFlag=None):
        'setAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag])'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBottomMargin(cls, self, float):
        'setBottomMargin(self, float)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setIndent(cls, self, int):
        'setIndent(self, int)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setLeftMargin(cls, self, float):
        'setLeftMargin(self, float)'
        pass
    
    @classmethod
    def setLineHeight(cls, self, float, int):
        'setLineHeight(self, float, int)'
        pass
    
    @classmethod
    def setNonBreakableLines(cls, self, bool):
        'setNonBreakableLines(self, bool)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setPageBreakPolicy(cls, self, UnionQTextFormatPageBreakFlags=None, QTextFormatPageBreakFlag=None):
        'setPageBreakPolicy(self, Union[QTextFormat.PageBreakFlags, QTextFormat.PageBreakFlag])'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setRightMargin(cls, self, float):
        'setRightMargin(self, float)'
        pass
    
    @classmethod
    def setTabPositions(cls, self, object):
        'setTabPositions(self, object)'
        pass
    
    @classmethod
    def setTextIndent(cls, self, float):
        'setTextIndent(self, float)'
        pass
    
    @classmethod
    def setTopMargin(cls, self, float):
        'setTopMargin(self, float)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def tabPositions(cls, self):
        'tabPositions(self) -> List[QTextOption.Tab]'
        pass
    
    @classmethod
    def textIndent(cls, self):
        'textIndent(self) -> float'
        return 1.0
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def topMargin(cls, self):
        'topMargin(self) -> float'
        return 1.0
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    

class QTextBlockGroup(QTextObject):
    'QTextBlockGroup(QTextDocument)'
    __class__ = QTextBlockGroup
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QTextBlockGroup(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockFormatChanged(cls, self, QTextBlock):
        'blockFormatChanged(self, QTextBlock)'
        pass
    
    @classmethod
    def blockInserted(cls, self, QTextBlock):
        'blockInserted(self, QTextBlock)'
        pass
    
    @classmethod
    def blockList(cls, self):
        'blockList(self) -> object'
        pass
    
    @classmethod
    def blockRemoved(cls, self, QTextBlock):
        'blockRemoved(self, QTextBlock)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextFormat):
        'setFormat(self, QTextFormat)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTextBlockUserData(_mod_sip.wrapper):
    'QTextBlockUserData()\nQTextBlockUserData(QTextBlockUserData)'
    __class__ = QTextBlockUserData
    __dict__ = {}
    def __init__(self, QTextBlockUserData):
        'QTextBlockUserData()\nQTextBlockUserData(QTextBlockUserData)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    

class QTextCharFormat(QTextFormat):
    'QTextCharFormat()\nQTextCharFormat(QTextCharFormat)'
    AlignBaseline = VerticalAlignment()
    AlignBottom = VerticalAlignment()
    AlignMiddle = VerticalAlignment()
    AlignNormal = VerticalAlignment()
    AlignSubScript = VerticalAlignment()
    AlignSuperScript = VerticalAlignment()
    AlignTop = VerticalAlignment()
    DashDotDotLine = UnderlineStyle()
    DashDotLine = UnderlineStyle()
    DashUnderline = UnderlineStyle()
    DotLine = UnderlineStyle()
    FontPropertiesAll = FontPropertiesInheritanceBehavior()
    FontPropertiesInheritanceBehavior = FontPropertiesInheritanceBehavior()
    FontPropertiesSpecifiedOnly = FontPropertiesInheritanceBehavior()
    NoUnderline = UnderlineStyle()
    SingleUnderline = UnderlineStyle()
    SpellCheckUnderline = UnderlineStyle()
    UnderlineStyle = UnderlineStyle()
    VerticalAlignment = VerticalAlignment()
    WaveUnderline = UnderlineStyle()
    __class__ = QTextCharFormat
    __dict__ = {}
    def __init__(self, QTextCharFormat):
        'QTextCharFormat()\nQTextCharFormat(QTextCharFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def anchorHref(cls, self):
        'anchorHref(self) -> str'
        return ''
    
    @classmethod
    def anchorNames(cls, self):
        'anchorNames(self) -> List[str]'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def fontCapitalization(cls, self):
        'fontCapitalization(self) -> QFont.Capitalization'
        pass
    
    @classmethod
    def fontFamily(cls, self):
        'fontFamily(self) -> str'
        return ''
    
    @classmethod
    def fontFixedPitch(cls, self):
        'fontFixedPitch(self) -> bool'
        return True
    
    @classmethod
    def fontHintingPreference(cls, self):
        'fontHintingPreference(self) -> QFont.HintingPreference'
        pass
    
    @classmethod
    def fontItalic(cls, self):
        'fontItalic(self) -> bool'
        return True
    
    @classmethod
    def fontKerning(cls, self):
        'fontKerning(self) -> bool'
        return True
    
    @classmethod
    def fontLetterSpacing(cls, self):
        'fontLetterSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def fontLetterSpacingType(cls, self):
        'fontLetterSpacingType(self) -> QFont.SpacingType'
        pass
    
    @classmethod
    def fontOverline(cls, self):
        'fontOverline(self) -> bool'
        return True
    
    @classmethod
    def fontPointSize(cls, self):
        'fontPointSize(self) -> float'
        return 1.0
    
    @classmethod
    def fontStretch(cls, self):
        'fontStretch(self) -> int'
        return 1
    
    @classmethod
    def fontStrikeOut(cls, self):
        'fontStrikeOut(self) -> bool'
        return True
    
    @classmethod
    def fontStyleHint(cls, self):
        'fontStyleHint(self) -> QFont.StyleHint'
        pass
    
    @classmethod
    def fontStyleStrategy(cls, self):
        'fontStyleStrategy(self) -> QFont.StyleStrategy'
        pass
    
    @classmethod
    def fontUnderline(cls, self):
        'fontUnderline(self) -> bool'
        return True
    
    @classmethod
    def fontWeight(cls, self):
        'fontWeight(self) -> int'
        return 1
    
    @classmethod
    def fontWordSpacing(cls, self):
        'fontWordSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isAnchor(cls, self):
        'isAnchor(self) -> bool'
        return True
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def setAnchor(cls, self, bool):
        'setAnchor(self, bool)'
        pass
    
    @classmethod
    def setAnchorHref(cls, self, str):
        'setAnchorHref(self, str)'
        pass
    
    @classmethod
    def setAnchorNames(cls, self, Iterablestr=None):
        'setAnchorNames(self, Iterable[str])'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setFont(cls, self, QFont, QTextCharFormatFontPropertiesInheritanceBehavior):
        'setFont(self, QFont)\nsetFont(self, QFont, QTextCharFormat.FontPropertiesInheritanceBehavior)'
        pass
    
    @classmethod
    def setFontCapitalization(cls, self, QFontCapitalization):
        'setFontCapitalization(self, QFont.Capitalization)'
        pass
    
    @classmethod
    def setFontFamily(cls, self, str):
        'setFontFamily(self, str)'
        pass
    
    @classmethod
    def setFontFixedPitch(cls, self, bool):
        'setFontFixedPitch(self, bool)'
        pass
    
    @classmethod
    def setFontHintingPreference(cls, self, QFontHintingPreference):
        'setFontHintingPreference(self, QFont.HintingPreference)'
        pass
    
    @classmethod
    def setFontItalic(cls, self, bool):
        'setFontItalic(self, bool)'
        pass
    
    @classmethod
    def setFontKerning(cls, self, bool):
        'setFontKerning(self, bool)'
        pass
    
    @classmethod
    def setFontLetterSpacing(cls, self, float):
        'setFontLetterSpacing(self, float)'
        pass
    
    @classmethod
    def setFontLetterSpacingType(cls, self, QFontSpacingType):
        'setFontLetterSpacingType(self, QFont.SpacingType)'
        pass
    
    @classmethod
    def setFontOverline(cls, self, bool):
        'setFontOverline(self, bool)'
        pass
    
    @classmethod
    def setFontPointSize(cls, self, float):
        'setFontPointSize(self, float)'
        pass
    
    @classmethod
    def setFontStretch(cls, self, int):
        'setFontStretch(self, int)'
        pass
    
    @classmethod
    def setFontStrikeOut(cls, self, bool):
        'setFontStrikeOut(self, bool)'
        pass
    
    @classmethod
    def setFontStyleHint(cls, self, QFontStyleHint, strategy: QFont.StyleStrategy=QFont.PreferDefault):
        'setFontStyleHint(self, QFont.StyleHint, strategy: QFont.StyleStrategy = QFont.PreferDefault)'
        pass
    
    @classmethod
    def setFontStyleStrategy(cls, self, QFontStyleStrategy):
        'setFontStyleStrategy(self, QFont.StyleStrategy)'
        pass
    
    @classmethod
    def setFontUnderline(cls, self, bool):
        'setFontUnderline(self, bool)'
        pass
    
    @classmethod
    def setFontWeight(cls, self, int):
        'setFontWeight(self, int)'
        pass
    
    @classmethod
    def setFontWordSpacing(cls, self, float):
        'setFontWordSpacing(self, float)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setTableCellColumnSpan(cls, self, int):
        'setTableCellColumnSpan(self, int)'
        pass
    
    @classmethod
    def setTableCellRowSpan(cls, self, int):
        'setTableCellRowSpan(self, int)'
        pass
    
    @classmethod
    def setTextOutline(cls, self, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setTextOutline(self, Union[QPen, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setToolTip(cls, self, str):
        'setToolTip(self, str)'
        pass
    
    @classmethod
    def setUnderlineColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setUnderlineColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setUnderlineStyle(cls, self, QTextCharFormatUnderlineStyle):
        'setUnderlineStyle(self, QTextCharFormat.UnderlineStyle)'
        pass
    
    @classmethod
    def setVerticalAlignment(cls, self, QTextCharFormatVerticalAlignment):
        'setVerticalAlignment(self, QTextCharFormat.VerticalAlignment)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def tableCellColumnSpan(cls, self):
        'tableCellColumnSpan(self) -> int'
        return 1
    
    @classmethod
    def tableCellRowSpan(cls, self):
        'tableCellRowSpan(self) -> int'
        return 1
    
    @classmethod
    def textOutline(cls, self):
        'textOutline(self) -> QPen'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def toolTip(cls, self):
        'toolTip(self) -> str'
        return ''
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def underlineColor(cls, self):
        'underlineColor(self) -> QColor'
        pass
    
    @classmethod
    def underlineStyle(cls, self):
        'underlineStyle(self) -> QTextCharFormat.UnderlineStyle'
        pass
    
    @classmethod
    def verticalAlignment(cls, self):
        'verticalAlignment(self) -> QTextCharFormat.VerticalAlignment'
        pass
    

class QTextCursor(_mod_sip.simplewrapper):
    'QTextCursor()\nQTextCursor(QTextDocument)\nQTextCursor(QTextFrame)\nQTextCursor(QTextBlock)\nQTextCursor(QTextCursor)'
    BlockUnderCursor = SelectionType()
    Document = SelectionType()
    Down = MoveOperation()
    End = MoveOperation()
    EndOfBlock = MoveOperation()
    EndOfLine = MoveOperation()
    EndOfWord = MoveOperation()
    KeepAnchor = MoveMode()
    Left = MoveOperation()
    LineUnderCursor = SelectionType()
    MoveAnchor = MoveMode()
    MoveMode = MoveMode()
    MoveOperation = MoveOperation()
    NextBlock = MoveOperation()
    NextCell = MoveOperation()
    NextCharacter = MoveOperation()
    NextRow = MoveOperation()
    NextWord = MoveOperation()
    NoMove = MoveOperation()
    PreviousBlock = MoveOperation()
    PreviousCell = MoveOperation()
    PreviousCharacter = MoveOperation()
    PreviousRow = MoveOperation()
    PreviousWord = MoveOperation()
    Right = MoveOperation()
    SelectionType = SelectionType()
    Start = MoveOperation()
    StartOfBlock = MoveOperation()
    StartOfLine = MoveOperation()
    StartOfWord = MoveOperation()
    Up = MoveOperation()
    WordLeft = MoveOperation()
    WordRight = MoveOperation()
    WordUnderCursor = SelectionType()
    __class__ = QTextCursor
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextDocument):
        'QTextCursor()\nQTextCursor(QTextDocument)\nQTextCursor(QTextFrame)\nQTextCursor(QTextBlock)\nQTextCursor(QTextCursor)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def anchor(cls, self):
        'anchor(self) -> int'
        return 1
    
    @classmethod
    def atBlockEnd(cls, self):
        'atBlockEnd(self) -> bool'
        return True
    
    @classmethod
    def atBlockStart(cls, self):
        'atBlockStart(self) -> bool'
        return True
    
    @classmethod
    def atEnd(cls, self):
        'atEnd(self) -> bool'
        return True
    
    @classmethod
    def atStart(cls, self):
        'atStart(self) -> bool'
        return True
    
    @classmethod
    def beginEditBlock(cls, self):
        'beginEditBlock(self)'
        pass
    
    @classmethod
    def block(cls, self):
        'block(self) -> QTextBlock'
        pass
    
    @classmethod
    def blockCharFormat(cls, self):
        'blockCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def blockFormat(cls, self):
        'blockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def blockNumber(cls, self):
        'blockNumber(self) -> int'
        return 1
    
    @classmethod
    def charFormat(cls, self):
        'charFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def clearSelection(cls, self):
        'clearSelection(self)'
        pass
    
    @classmethod
    def columnNumber(cls, self):
        'columnNumber(self) -> int'
        return 1
    
    @classmethod
    def createList(cls, self, QTextListFormatStyle):
        'createList(self, QTextListFormat) -> QTextList\ncreateList(self, QTextListFormat.Style) -> QTextList'
        pass
    
    @classmethod
    def currentFrame(cls, self):
        'currentFrame(self) -> QTextFrame'
        pass
    
    @classmethod
    def currentList(cls, self):
        'currentList(self) -> QTextList'
        pass
    
    @classmethod
    def currentTable(cls, self):
        'currentTable(self) -> QTextTable'
        pass
    
    @classmethod
    def deleteChar(cls, self):
        'deleteChar(self)'
        pass
    
    @classmethod
    def deletePreviousChar(cls, self):
        'deletePreviousChar(self)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def endEditBlock(cls, self):
        'endEditBlock(self)'
        pass
    
    @classmethod
    def hasComplexSelection(cls, self):
        'hasComplexSelection(self) -> bool'
        return True
    
    @classmethod
    def hasSelection(cls, self):
        'hasSelection(self) -> bool'
        return True
    
    @classmethod
    def insertBlock(cls, self, QTextBlockFormat, QTextCharFormat):
        'insertBlock(self)\ninsertBlock(self, QTextBlockFormat)\ninsertBlock(self, QTextBlockFormat, QTextCharFormat)'
        pass
    
    @classmethod
    def insertFragment(cls, self, QTextDocumentFragment):
        'insertFragment(self, QTextDocumentFragment)'
        pass
    
    @classmethod
    def insertFrame(cls, self, QTextFrameFormat):
        'insertFrame(self, QTextFrameFormat) -> QTextFrame'
        pass
    
    @classmethod
    def insertHtml(cls, self, str):
        'insertHtml(self, str)'
        pass
    
    @classmethod
    def insertImage(cls, self, QTextImageFormat, QTextFrameFormatPosition):
        "insertImage(self, QTextImageFormat)\ninsertImage(self, QTextImageFormat, QTextFrameFormat.Position)\ninsertImage(self, str)\ninsertImage(self, QImage, name: str = '')"
        pass
    
    @classmethod
    def insertList(cls, self, QTextListFormatStyle):
        'insertList(self, QTextListFormat) -> QTextList\ninsertList(self, QTextListFormat.Style) -> QTextList'
        pass
    
    @classmethod
    def insertTable(cls, self, int, int_, QTextTableFormat):
        'insertTable(self, int, int, QTextTableFormat) -> QTextTable\ninsertTable(self, int, int) -> QTextTable'
        pass
    
    @classmethod
    def insertText(cls, self, str, QTextCharFormat):
        'insertText(self, str)\ninsertText(self, str, QTextCharFormat)'
        pass
    
    @classmethod
    def isCopyOf(cls, self, QTextCursor):
        'isCopyOf(self, QTextCursor) -> bool'
        return True
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def joinPreviousEditBlock(cls, self):
        'joinPreviousEditBlock(self)'
        pass
    
    @classmethod
    def keepPositionOnInsert(cls, self):
        'keepPositionOnInsert(self) -> bool'
        return True
    
    @classmethod
    def mergeBlockCharFormat(cls, self, QTextCharFormat):
        'mergeBlockCharFormat(self, QTextCharFormat)'
        pass
    
    @classmethod
    def mergeBlockFormat(cls, self, QTextBlockFormat):
        'mergeBlockFormat(self, QTextBlockFormat)'
        pass
    
    @classmethod
    def mergeCharFormat(cls, self, QTextCharFormat):
        'mergeCharFormat(self, QTextCharFormat)'
        pass
    
    @classmethod
    def movePosition(cls, self, QTextCursorMoveOperation, mode: QTextCursor.MoveMode=QTextCursor.MoveAnchor, n: int=1):
        'movePosition(self, QTextCursor.MoveOperation, mode: QTextCursor.MoveMode = QTextCursor.MoveAnchor, n: int = 1) -> bool'
        return True
    
    @classmethod
    def position(cls, self):
        'position(self) -> int'
        return 1
    
    @classmethod
    def positionInBlock(cls, self):
        'positionInBlock(self) -> int'
        return 1
    
    @classmethod
    def removeSelectedText(cls, self):
        'removeSelectedText(self)'
        pass
    
    @classmethod
    def select(cls, self, QTextCursorSelectionType):
        'select(self, QTextCursor.SelectionType)'
        pass
    
    @classmethod
    def selectedTableCells(cls, self):
        'selectedTableCells(self) -> Tuple[int, int, int, int]'
        pass
    
    @classmethod
    def selectedText(cls, self):
        'selectedText(self) -> str'
        return ''
    
    @classmethod
    def selection(cls, self):
        'selection(self) -> QTextDocumentFragment'
        pass
    
    @classmethod
    def selectionEnd(cls, self):
        'selectionEnd(self) -> int'
        return 1
    
    @classmethod
    def selectionStart(cls, self):
        'selectionStart(self) -> int'
        return 1
    
    @classmethod
    def setBlockCharFormat(cls, self, QTextCharFormat):
        'setBlockCharFormat(self, QTextCharFormat)'
        pass
    
    @classmethod
    def setBlockFormat(cls, self, QTextBlockFormat):
        'setBlockFormat(self, QTextBlockFormat)'
        pass
    
    @classmethod
    def setCharFormat(cls, self, QTextCharFormat):
        'setCharFormat(self, QTextCharFormat)'
        pass
    
    @classmethod
    def setKeepPositionOnInsert(cls, self, bool):
        'setKeepPositionOnInsert(self, bool)'
        pass
    
    @classmethod
    def setPosition(cls, self, int, mode: QTextCursor.MoveMode=QTextCursor.MoveAnchor):
        'setPosition(self, int, mode: QTextCursor.MoveMode = QTextCursor.MoveAnchor)'
        pass
    
    @classmethod
    def setVerticalMovementX(cls, self, int):
        'setVerticalMovementX(self, int)'
        pass
    
    @classmethod
    def setVisualNavigation(cls, self, bool):
        'setVisualNavigation(self, bool)'
        pass
    
    @classmethod
    def swap(cls, self, QTextCursor):
        'swap(self, QTextCursor)'
        pass
    
    @classmethod
    def verticalMovementX(cls, self):
        'verticalMovementX(self) -> int'
        return 1
    
    @classmethod
    def visualNavigation(cls, self):
        'visualNavigation(self) -> bool'
        return True
    

class QTextDocument(_mod_PyQt5_QtCore.QObject):
    'QTextDocument(parent: QObject = None)\nQTextDocument(str, parent: QObject = None)'
    DocumentTitle = MetaInformation()
    DocumentUrl = MetaInformation()
    FindBackward = FindFlag()
    FindCaseSensitively = FindFlag()
    FindFlag = FindFlag()
    FindFlags = FindFlags()
    FindWholeWords = FindFlag()
    HtmlResource = ResourceType()
    ImageResource = ResourceType()
    MetaInformation = MetaInformation()
    RedoStack = Stacks()
    ResourceType = ResourceType()
    Stacks = Stacks()
    StyleSheetResource = ResourceType()
    UndoAndRedoStacks = Stacks()
    UndoStack = Stacks()
    UserResource = ResourceType()
    __class__ = QTextDocument
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, str, parent: QObject=None):
        'QTextDocument(parent: QObject = None)\nQTextDocument(str, parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def addResource(cls, self, int, QUrl, Any):
        'addResource(self, int, QUrl, Any)'
        pass
    
    @classmethod
    def adjustSize(cls, self):
        'adjustSize(self)'
        pass
    
    @classmethod
    def allFormats(cls, self):
        'allFormats(self) -> object'
        pass
    
    @classmethod
    def availableRedoSteps(cls, self):
        'availableRedoSteps(self) -> int'
        return 1
    
    @classmethod
    def availableUndoSteps(cls, self):
        'availableUndoSteps(self) -> int'
        return 1
    
    @classmethod
    def baseUrl(cls, self):
        'baseUrl(self) -> QUrl'
        pass
    
    def baseUrlChanged(self, QUrl):
        'baseUrlChanged(self, QUrl) [signal]'
        pass
    
    @classmethod
    def begin(cls, self):
        'begin(self) -> QTextBlock'
        pass
    
    @classmethod
    def blockCount(cls, self):
        'blockCount(self) -> int'
        return 1
    
    def blockCountChanged(self, int):
        'blockCountChanged(self, int) [signal]'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def characterAt(cls, self, int):
        'characterAt(self, int) -> str'
        return ''
    
    @classmethod
    def characterCount(cls, self):
        'characterCount(self) -> int'
        return 1
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def clear(cls, self):
        'clear(self)'
        pass
    
    @classmethod
    def clearUndoRedoStacks(cls, self, stacks: QTextDocument.Stacks=QTextDocument.UndoAndRedoStacks):
        'clearUndoRedoStacks(self, stacks: QTextDocument.Stacks = QTextDocument.UndoAndRedoStacks)'
        pass
    
    @classmethod
    def clone(cls, self, parent: QObject=None):
        'clone(self, parent: QObject = None) -> QTextDocument'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    def contentsChange(self, int, int_, int_1):
        'contentsChange(self, int, int, int) [signal]'
        pass
    
    def contentsChanged(self):
        'contentsChanged(self) [signal]'
        pass
    
    @classmethod
    def createObject(cls, self, QTextFormat):
        'createObject(self, QTextFormat) -> QTextObject'
        pass
    
    def cursorPositionChanged(self, QTextCursor):
        'cursorPositionChanged(self, QTextCursor) [signal]'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def defaultCursorMoveStyle(cls, self):
        'defaultCursorMoveStyle(self) -> Qt.CursorMoveStyle'
        pass
    
    @classmethod
    def defaultFont(cls, self):
        'defaultFont(self) -> QFont'
        pass
    
    @classmethod
    def defaultStyleSheet(cls, self):
        'defaultStyleSheet(self) -> str'
        return ''
    
    @classmethod
    def defaultTextOption(cls, self):
        'defaultTextOption(self) -> QTextOption'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def documentLayout(cls, self):
        'documentLayout(self) -> QAbstractTextDocumentLayout'
        pass
    
    def documentLayoutChanged(self):
        'documentLayoutChanged(self) [signal]'
        pass
    
    @classmethod
    def documentMargin(cls, self):
        'documentMargin(self) -> float'
        return 1.0
    
    @classmethod
    def drawContents(cls, self, QPainter, rect: QRectF=QRectF()):
        'drawContents(self, QPainter, rect: QRectF = QRectF())'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> QTextBlock'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def find(cls, self, QRegularExpression, position: int=0, options: QTextDocument.FindFlags=0):
        'find(self, str, position: int = 0, options: QTextDocument.FindFlags = 0) -> QTextCursor\nfind(self, QRegExp, position: int = 0, options: QTextDocument.FindFlags = 0) -> QTextCursor\nfind(self, QRegularExpression, position: int = 0, options: QTextDocument.FindFlags = 0) -> QTextCursor\nfind(self, str, QTextCursor, options: QTextDocument.FindFlags = 0) -> QTextCursor\nfind(self, QRegExp, QTextCursor, options: QTextDocument.FindFlags = 0) -> QTextCursor\nfind(self, QRegularExpression, QTextCursor, options: QTextDocument.FindFlags = 0) -> QTextCursor'
        pass
    
    @classmethod
    def findBlock(cls, self, int):
        'findBlock(self, int) -> QTextBlock'
        pass
    
    @classmethod
    def findBlockByLineNumber(cls, self, int):
        'findBlockByLineNumber(self, int) -> QTextBlock'
        pass
    
    @classmethod
    def findBlockByNumber(cls, self, int):
        'findBlockByNumber(self, int) -> QTextBlock'
        pass
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def firstBlock(cls, self):
        'firstBlock(self) -> QTextBlock'
        pass
    
    @classmethod
    def idealWidth(cls, self):
        'idealWidth(self) -> float'
        return 1.0
    
    @classmethod
    def indentWidth(cls, self):
        'indentWidth(self) -> float'
        return 1.0
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isModified(cls, self):
        'isModified(self) -> bool'
        return True
    
    @classmethod
    def isRedoAvailable(cls, self):
        'isRedoAvailable(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isUndoAvailable(cls, self):
        'isUndoAvailable(self) -> bool'
        return True
    
    @classmethod
    def isUndoRedoEnabled(cls, self):
        'isUndoRedoEnabled(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def lastBlock(cls, self):
        'lastBlock(self) -> QTextBlock'
        pass
    
    @classmethod
    def lineCount(cls, self):
        'lineCount(self) -> int'
        return 1
    
    @classmethod
    def loadResource(cls, self, int, QUrl):
        'loadResource(self, int, QUrl) -> Any'
        pass
    
    @classmethod
    def markContentsDirty(cls, self, int, int_):
        'markContentsDirty(self, int, int)'
        pass
    
    @classmethod
    def maximumBlockCount(cls, self):
        'maximumBlockCount(self) -> int'
        return 1
    
    @classmethod
    def metaInformation(cls, self, QTextDocumentMetaInformation):
        'metaInformation(self, QTextDocument.MetaInformation) -> str'
        return ''
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    def modificationChanged(self, bool):
        'modificationChanged(self, bool) [signal]'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def object(cls, self, int):
        'object(self, int) -> QTextObject'
        pass
    
    @classmethod
    def objectForFormat(cls, self, QTextFormat):
        'objectForFormat(self, QTextFormat) -> QTextObject'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def pageCount(cls, self):
        'pageCount(self) -> int'
        return 1
    
    @classmethod
    def pageSize(cls, self):
        'pageSize(self) -> QSizeF'
        pass
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def print(cls, self, QPagedPaintDevice):
        'print(self, QPagedPaintDevice)'
        pass
    
    @classmethod
    def print_(cls, self, QPagedPaintDevice):
        'print_(self, QPagedPaintDevice)'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def redo(cls, self, QTextCursor):
        'redo(self)\nredo(self, QTextCursor)'
        pass
    
    def redoAvailable(self, bool):
        'redoAvailable(self, bool) [signal]'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def resource(cls, self, int, QUrl):
        'resource(self, int, QUrl) -> Any'
        pass
    
    @classmethod
    def revision(cls, self):
        'revision(self) -> int'
        return 1
    
    @classmethod
    def rootFrame(cls, self):
        'rootFrame(self) -> QTextFrame'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBaseUrl(cls, self, QUrl):
        'setBaseUrl(self, QUrl)'
        pass
    
    @classmethod
    def setDefaultCursorMoveStyle(cls, self, QtCursorMoveStyle):
        'setDefaultCursorMoveStyle(self, Qt.CursorMoveStyle)'
        pass
    
    @classmethod
    def setDefaultFont(cls, self, QFont):
        'setDefaultFont(self, QFont)'
        pass
    
    @classmethod
    def setDefaultStyleSheet(cls, self, str):
        'setDefaultStyleSheet(self, str)'
        pass
    
    @classmethod
    def setDefaultTextOption(cls, self, QTextOption):
        'setDefaultTextOption(self, QTextOption)'
        pass
    
    @classmethod
    def setDocumentLayout(cls, self, QAbstractTextDocumentLayout):
        'setDocumentLayout(self, QAbstractTextDocumentLayout)'
        pass
    
    @classmethod
    def setDocumentMargin(cls, self, float):
        'setDocumentMargin(self, float)'
        pass
    
    @classmethod
    def setHtml(cls, self, str):
        'setHtml(self, str)'
        pass
    
    @classmethod
    def setIndentWidth(cls, self, float):
        'setIndentWidth(self, float)'
        pass
    
    @classmethod
    def setMaximumBlockCount(cls, self, int):
        'setMaximumBlockCount(self, int)'
        pass
    
    @classmethod
    def setMetaInformation(cls, self, QTextDocumentMetaInformation, str):
        'setMetaInformation(self, QTextDocument.MetaInformation, str)'
        pass
    
    @classmethod
    def setModified(cls, self, on: bool=True):
        'setModified(self, on: bool = True)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setPageSize(cls, self, QSizeF):
        'setPageSize(self, QSizeF)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setPlainText(cls, self, str):
        'setPlainText(self, str)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setTextWidth(cls, self, float):
        'setTextWidth(self, float)'
        pass
    
    @classmethod
    def setUndoRedoEnabled(cls, self, bool):
        'setUndoRedoEnabled(self, bool)'
        pass
    
    @classmethod
    def setUseDesignMetrics(cls, self, bool):
        'setUseDesignMetrics(self, bool)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSizeF'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def textWidth(cls, self):
        'textWidth(self) -> float'
        return 1.0
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def toHtml(cls, self, encoding: Union[QByteArray,bytes,bytearray]=QByteArray()):
        'toHtml(self, encoding: Union[QByteArray, bytes, bytearray] = QByteArray()) -> str'
        return ''
    
    @classmethod
    def toPlainText(cls, self):
        'toPlainText(self) -> str'
        return ''
    
    @classmethod
    def toRawText(cls, self):
        'toRawText(self) -> str'
        return ''
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def undo(cls, self, QTextCursor):
        'undo(self)\nundo(self, QTextCursor)'
        pass
    
    def undoAvailable(self, bool):
        'undoAvailable(self, bool) [signal]'
        pass
    
    def undoCommandAdded(self):
        'undoCommandAdded(self) [signal]'
        pass
    
    @classmethod
    def useDesignMetrics(cls, self):
        'useDesignMetrics(self) -> bool'
        return True
    

class QTextDocumentFragment(_mod_sip.simplewrapper):
    'QTextDocumentFragment()\nQTextDocumentFragment(QTextDocument)\nQTextDocumentFragment(QTextCursor)\nQTextDocumentFragment(QTextDocumentFragment)'
    __class__ = QTextDocumentFragment
    __dict__ = {}
    def __init__(self, QTextDocumentFragment):
        'QTextDocumentFragment()\nQTextDocumentFragment(QTextDocument)\nQTextDocumentFragment(QTextCursor)\nQTextDocumentFragment(QTextDocumentFragment)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def fromHtml(cls, str, QTextDocument):
        'fromHtml(str) -> QTextDocumentFragment\nfromHtml(str, QTextDocument) -> QTextDocumentFragment'
        pass
    
    @classmethod
    def fromPlainText(cls, str):
        'fromPlainText(str) -> QTextDocumentFragment'
        pass
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def toHtml(cls, self, encoding: Union[QByteArray,bytes,bytearray]=QByteArray()):
        'toHtml(self, encoding: Union[QByteArray, bytes, bytearray] = QByteArray()) -> str'
        return ''
    
    @classmethod
    def toPlainText(cls, self):
        'toPlainText(self) -> str'
        return ''
    

class QTextDocumentWriter(_mod_sip.simplewrapper):
    'QTextDocumentWriter()\nQTextDocumentWriter(QIODevice, Union[QByteArray, bytes, bytearray])\nQTextDocumentWriter(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
    __class__ = QTextDocumentWriter
    __dict__ = {}
    def __init__(self, str, format: Union[QByteArray,bytes,bytearray]=QByteArray()):
        'QTextDocumentWriter()\nQTextDocumentWriter(QIODevice, Union[QByteArray, bytes, bytearray])\nQTextDocumentWriter(str, format: Union[QByteArray, bytes, bytearray] = QByteArray())'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def codec(cls, self):
        'codec(self) -> QTextCodec'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QIODevice'
        pass
    
    @classmethod
    def fileName(cls, self):
        'fileName(self) -> str'
        return ''
    
    @classmethod
    def format(cls, self):
        'format(self) -> QByteArray'
        pass
    
    @classmethod
    def setCodec(cls, self, QTextCodec):
        'setCodec(self, QTextCodec)'
        pass
    
    @classmethod
    def setDevice(cls, self, QIODevice):
        'setDevice(self, QIODevice)'
        pass
    
    @classmethod
    def setFileName(cls, self, str):
        'setFileName(self, str)'
        pass
    
    @classmethod
    def setFormat(cls, self, UnionQByteArray=None, bytes=None, bytearray=None):
        'setFormat(self, Union[QByteArray, bytes, bytearray])'
        pass
    
    @classmethod
    def supportedDocumentFormats(cls):
        'supportedDocumentFormats() -> List[QByteArray]'
        pass
    
    @classmethod
    def write(cls, self, QTextDocumentFragment):
        'write(self, QTextDocument) -> bool\nwrite(self, QTextDocumentFragment) -> bool'
        return True
    

class QTextFormat(_mod_sip.simplewrapper):
    'QTextFormat()\nQTextFormat(int)\nQTextFormat(QTextFormat)\nQTextFormat(Any)'
    AnchorHref = Property()
    AnchorName = Property()
    BackgroundBrush = Property()
    BackgroundImageUrl = Property()
    BlockAlignment = Property()
    BlockBottomMargin = Property()
    BlockFormat = FormatType()
    BlockIndent = Property()
    BlockLeftMargin = Property()
    BlockNonBreakableLines = Property()
    BlockRightMargin = Property()
    BlockTopMargin = Property()
    BlockTrailingHorizontalRulerWidth = Property()
    CharFormat = FormatType()
    CssFloat = Property()
    FirstFontProperty = Property()
    FontCapitalization = Property()
    FontFamily = Property()
    FontFixedPitch = Property()
    FontHintingPreference = Property()
    FontItalic = Property()
    FontKerning = Property()
    FontLetterSpacing = Property()
    FontLetterSpacingType = Property()
    FontOverline = Property()
    FontPixelSize = Property()
    FontPointSize = Property()
    FontSizeAdjustment = Property()
    FontSizeIncrement = Property()
    FontStretch = Property()
    FontStrikeOut = Property()
    FontStyleHint = Property()
    FontStyleStrategy = Property()
    FontUnderline = Property()
    FontWeight = Property()
    FontWordSpacing = Property()
    ForegroundBrush = Property()
    FormatType = FormatType()
    FrameBorder = Property()
    FrameBorderBrush = Property()
    FrameBorderStyle = Property()
    FrameBottomMargin = Property()
    FrameFormat = FormatType()
    FrameHeight = Property()
    FrameLeftMargin = Property()
    FrameMargin = Property()
    FramePadding = Property()
    FrameRightMargin = Property()
    FrameTopMargin = Property()
    FrameWidth = Property()
    FullWidthSelection = Property()
    ImageHeight = Property()
    ImageName = Property()
    ImageObject = ObjectTypes()
    ImageWidth = Property()
    InvalidFormat = FormatType()
    IsAnchor = Property()
    LastFontProperty = Property()
    LayoutDirection = Property()
    LineHeight = Property()
    LineHeightType = Property()
    ListFormat = FormatType()
    ListIndent = Property()
    ListNumberPrefix = Property()
    ListNumberSuffix = Property()
    ListStyle = Property()
    NoObject = ObjectTypes()
    ObjectIndex = Property()
    ObjectType = Property()
    ObjectTypes = ObjectTypes()
    OutlinePen = Property()
    PageBreakFlag = PageBreakFlag()
    PageBreakFlags = PageBreakFlags()
    PageBreakPolicy = Property()
    PageBreak_AlwaysAfter = PageBreakFlag()
    PageBreak_AlwaysBefore = PageBreakFlag()
    PageBreak_Auto = PageBreakFlag()
    Property = Property()
    TabPositions = Property()
    TableCellBottomPadding = Property()
    TableCellColumnSpan = Property()
    TableCellLeftPadding = Property()
    TableCellObject = ObjectTypes()
    TableCellPadding = Property()
    TableCellRightPadding = Property()
    TableCellRowSpan = Property()
    TableCellSpacing = Property()
    TableCellTopPadding = Property()
    TableColumnWidthConstraints = Property()
    TableColumns = Property()
    TableFormat = FormatType()
    TableHeaderRowCount = Property()
    TableObject = ObjectTypes()
    TextIndent = Property()
    TextOutline = Property()
    TextToolTip = Property()
    TextUnderlineColor = Property()
    TextUnderlineStyle = Property()
    TextVerticalAlignment = Property()
    UserFormat = FormatType()
    UserObject = ObjectTypes()
    UserProperty = Property()
    __class__ = QTextFormat
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextFormat):
        'QTextFormat()\nQTextFormat(int)\nQTextFormat(QTextFormat)\nQTextFormat(Any)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    

class QTextFragment(_mod_sip.simplewrapper):
    'QTextFragment()\nQTextFragment(QTextFragment)'
    __class__ = QTextFragment
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextFragment):
        'QTextFragment()\nQTextFragment(QTextFragment)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def charFormat(cls, self):
        'charFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def charFormatIndex(cls, self):
        'charFormatIndex(self) -> int'
        return 1
    
    @classmethod
    def contains(cls, self, int):
        'contains(self, int) -> bool'
        return True
    
    @classmethod
    def glyphRuns(cls, self, from_: int=-1, length: int=-1):
        'glyphRuns(self, from_: int = -1, length: int = -1) -> List[QGlyphRun]'
        pass
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> int'
        return 1
    
    @classmethod
    def position(cls, self):
        'position(self) -> int'
        return 1
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    

class QTextFrame(QTextObject):
    'QTextFrame(QTextDocument)'
    __class__ = QTextFrame
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QTextFrame(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def begin(cls, self):
        'begin(self) -> QTextFrame.iterator'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def childFrames(cls, self):
        'childFrames(self) -> object'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> QTextFrame.iterator'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def firstCursorPosition(cls, self):
        'firstCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def firstPosition(cls, self):
        'firstPosition(self) -> int'
        return 1
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def frameFormat(cls, self):
        'frameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    iterator = iterator()
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def lastCursorPosition(cls, self):
        'lastCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def lastPosition(cls, self):
        'lastPosition(self) -> int'
        return 1
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def parentFrame(cls, self):
        'parentFrame(self) -> QTextFrame'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextFormat):
        'setFormat(self, QTextFormat)'
        pass
    
    @classmethod
    def setFrameFormat(cls, self, QTextFrameFormat):
        'setFrameFormat(self, QTextFrameFormat)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTextFrameFormat(QTextFormat):
    'QTextFrameFormat()\nQTextFrameFormat(QTextFrameFormat)'
    BorderStyle = BorderStyle()
    BorderStyle_Dashed = BorderStyle()
    BorderStyle_DotDash = BorderStyle()
    BorderStyle_DotDotDash = BorderStyle()
    BorderStyle_Dotted = BorderStyle()
    BorderStyle_Double = BorderStyle()
    BorderStyle_Groove = BorderStyle()
    BorderStyle_Inset = BorderStyle()
    BorderStyle_None = BorderStyle()
    BorderStyle_Outset = BorderStyle()
    BorderStyle_Ridge = BorderStyle()
    BorderStyle_Solid = BorderStyle()
    FloatLeft = Position()
    FloatRight = Position()
    InFlow = Position()
    Position = Position()
    __class__ = QTextFrameFormat
    __dict__ = {}
    def __init__(self, QTextFrameFormat):
        'QTextFrameFormat()\nQTextFrameFormat(QTextFrameFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def border(cls, self):
        'border(self) -> float'
        return 1.0
    
    @classmethod
    def borderBrush(cls, self):
        'borderBrush(self) -> QBrush'
        pass
    
    @classmethod
    def borderStyle(cls, self):
        'borderStyle(self) -> QTextFrameFormat.BorderStyle'
        pass
    
    @classmethod
    def bottomMargin(cls, self):
        'bottomMargin(self) -> float'
        return 1.0
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> QTextLength'
        pass
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def leftMargin(cls, self):
        'leftMargin(self) -> float'
        return 1.0
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def margin(cls, self):
        'margin(self) -> float'
        return 1.0
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def padding(cls, self):
        'padding(self) -> float'
        return 1.0
    
    @classmethod
    def pageBreakPolicy(cls, self):
        'pageBreakPolicy(self) -> QTextFormat.PageBreakFlags'
        pass
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def position(cls, self):
        'position(self) -> QTextFrameFormat.Position'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def rightMargin(cls, self):
        'rightMargin(self) -> float'
        return 1.0
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBorder(cls, self, float):
        'setBorder(self, float)'
        pass
    
    @classmethod
    def setBorderBrush(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBorderBrush(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBorderStyle(cls, self, QTextFrameFormatBorderStyle):
        'setBorderStyle(self, QTextFrameFormat.BorderStyle)'
        pass
    
    @classmethod
    def setBottomMargin(cls, self, float):
        'setBottomMargin(self, float)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setHeight(cls, self, QTextLength):
        'setHeight(self, float)\nsetHeight(self, QTextLength)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setLeftMargin(cls, self, float):
        'setLeftMargin(self, float)'
        pass
    
    @classmethod
    def setMargin(cls, self, float):
        'setMargin(self, float)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setPadding(cls, self, float):
        'setPadding(self, float)'
        pass
    
    @classmethod
    def setPageBreakPolicy(cls, self, UnionQTextFormatPageBreakFlags=None, QTextFormatPageBreakFlag=None):
        'setPageBreakPolicy(self, Union[QTextFormat.PageBreakFlags, QTextFormat.PageBreakFlag])'
        pass
    
    @classmethod
    def setPosition(cls, self, QTextFrameFormatPosition):
        'setPosition(self, QTextFrameFormat.Position)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setRightMargin(cls, self, float):
        'setRightMargin(self, float)'
        pass
    
    @classmethod
    def setTopMargin(cls, self, float):
        'setTopMargin(self, float)'
        pass
    
    @classmethod
    def setWidth(cls, self, QTextLength):
        'setWidth(self, QTextLength)\nsetWidth(self, float)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def topMargin(cls, self):
        'topMargin(self) -> float'
        return 1.0
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> QTextLength'
        pass
    

class QTextImageFormat(QTextCharFormat):
    'QTextImageFormat()\nQTextImageFormat(QTextImageFormat)'
    __class__ = QTextImageFormat
    __dict__ = {}
    def __init__(self, QTextImageFormat):
        'QTextImageFormat()\nQTextImageFormat(QTextImageFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def anchorHref(cls, self):
        'anchorHref(self) -> str'
        return ''
    
    @classmethod
    def anchorNames(cls, self):
        'anchorNames(self) -> List[str]'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def fontCapitalization(cls, self):
        'fontCapitalization(self) -> QFont.Capitalization'
        pass
    
    @classmethod
    def fontFamily(cls, self):
        'fontFamily(self) -> str'
        return ''
    
    @classmethod
    def fontFixedPitch(cls, self):
        'fontFixedPitch(self) -> bool'
        return True
    
    @classmethod
    def fontHintingPreference(cls, self):
        'fontHintingPreference(self) -> QFont.HintingPreference'
        pass
    
    @classmethod
    def fontItalic(cls, self):
        'fontItalic(self) -> bool'
        return True
    
    @classmethod
    def fontKerning(cls, self):
        'fontKerning(self) -> bool'
        return True
    
    @classmethod
    def fontLetterSpacing(cls, self):
        'fontLetterSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def fontLetterSpacingType(cls, self):
        'fontLetterSpacingType(self) -> QFont.SpacingType'
        pass
    
    @classmethod
    def fontOverline(cls, self):
        'fontOverline(self) -> bool'
        return True
    
    @classmethod
    def fontPointSize(cls, self):
        'fontPointSize(self) -> float'
        return 1.0
    
    @classmethod
    def fontStretch(cls, self):
        'fontStretch(self) -> int'
        return 1
    
    @classmethod
    def fontStrikeOut(cls, self):
        'fontStrikeOut(self) -> bool'
        return True
    
    @classmethod
    def fontStyleHint(cls, self):
        'fontStyleHint(self) -> QFont.StyleHint'
        pass
    
    @classmethod
    def fontStyleStrategy(cls, self):
        'fontStyleStrategy(self) -> QFont.StyleStrategy'
        pass
    
    @classmethod
    def fontUnderline(cls, self):
        'fontUnderline(self) -> bool'
        return True
    
    @classmethod
    def fontWeight(cls, self):
        'fontWeight(self) -> int'
        return 1
    
    @classmethod
    def fontWordSpacing(cls, self):
        'fontWordSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def height(cls, self):
        'height(self) -> float'
        return 1.0
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isAnchor(cls, self):
        'isAnchor(self) -> bool'
        return True
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def name(cls, self):
        'name(self) -> str'
        return ''
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def setAnchor(cls, self, bool):
        'setAnchor(self, bool)'
        pass
    
    @classmethod
    def setAnchorHref(cls, self, str):
        'setAnchorHref(self, str)'
        pass
    
    @classmethod
    def setAnchorNames(cls, self, Iterablestr=None):
        'setAnchorNames(self, Iterable[str])'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setFont(cls, self, QFont, QTextCharFormatFontPropertiesInheritanceBehavior):
        'setFont(self, QFont)\nsetFont(self, QFont, QTextCharFormat.FontPropertiesInheritanceBehavior)'
        pass
    
    @classmethod
    def setFontCapitalization(cls, self, QFontCapitalization):
        'setFontCapitalization(self, QFont.Capitalization)'
        pass
    
    @classmethod
    def setFontFamily(cls, self, str):
        'setFontFamily(self, str)'
        pass
    
    @classmethod
    def setFontFixedPitch(cls, self, bool):
        'setFontFixedPitch(self, bool)'
        pass
    
    @classmethod
    def setFontHintingPreference(cls, self, QFontHintingPreference):
        'setFontHintingPreference(self, QFont.HintingPreference)'
        pass
    
    @classmethod
    def setFontItalic(cls, self, bool):
        'setFontItalic(self, bool)'
        pass
    
    @classmethod
    def setFontKerning(cls, self, bool):
        'setFontKerning(self, bool)'
        pass
    
    @classmethod
    def setFontLetterSpacing(cls, self, float):
        'setFontLetterSpacing(self, float)'
        pass
    
    @classmethod
    def setFontLetterSpacingType(cls, self, QFontSpacingType):
        'setFontLetterSpacingType(self, QFont.SpacingType)'
        pass
    
    @classmethod
    def setFontOverline(cls, self, bool):
        'setFontOverline(self, bool)'
        pass
    
    @classmethod
    def setFontPointSize(cls, self, float):
        'setFontPointSize(self, float)'
        pass
    
    @classmethod
    def setFontStretch(cls, self, int):
        'setFontStretch(self, int)'
        pass
    
    @classmethod
    def setFontStrikeOut(cls, self, bool):
        'setFontStrikeOut(self, bool)'
        pass
    
    @classmethod
    def setFontStyleHint(cls, self, QFontStyleHint, strategy: QFont.StyleStrategy=QFont.PreferDefault):
        'setFontStyleHint(self, QFont.StyleHint, strategy: QFont.StyleStrategy = QFont.PreferDefault)'
        pass
    
    @classmethod
    def setFontStyleStrategy(cls, self, QFontStyleStrategy):
        'setFontStyleStrategy(self, QFont.StyleStrategy)'
        pass
    
    @classmethod
    def setFontUnderline(cls, self, bool):
        'setFontUnderline(self, bool)'
        pass
    
    @classmethod
    def setFontWeight(cls, self, int):
        'setFontWeight(self, int)'
        pass
    
    @classmethod
    def setFontWordSpacing(cls, self, float):
        'setFontWordSpacing(self, float)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setHeight(cls, self, float):
        'setHeight(self, float)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setName(cls, self, str):
        'setName(self, str)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setTableCellColumnSpan(cls, self, int):
        'setTableCellColumnSpan(self, int)'
        pass
    
    @classmethod
    def setTableCellRowSpan(cls, self, int):
        'setTableCellRowSpan(self, int)'
        pass
    
    @classmethod
    def setTextOutline(cls, self, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setTextOutline(self, Union[QPen, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setToolTip(cls, self, str):
        'setToolTip(self, str)'
        pass
    
    @classmethod
    def setUnderlineColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setUnderlineColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setUnderlineStyle(cls, self, QTextCharFormatUnderlineStyle):
        'setUnderlineStyle(self, QTextCharFormat.UnderlineStyle)'
        pass
    
    @classmethod
    def setVerticalAlignment(cls, self, QTextCharFormatVerticalAlignment):
        'setVerticalAlignment(self, QTextCharFormat.VerticalAlignment)'
        pass
    
    @classmethod
    def setWidth(cls, self, float):
        'setWidth(self, float)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def tableCellColumnSpan(cls, self):
        'tableCellColumnSpan(self) -> int'
        return 1
    
    @classmethod
    def tableCellRowSpan(cls, self):
        'tableCellRowSpan(self) -> int'
        return 1
    
    @classmethod
    def textOutline(cls, self):
        'textOutline(self) -> QPen'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def toolTip(cls, self):
        'toolTip(self) -> str'
        return ''
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def underlineColor(cls, self):
        'underlineColor(self) -> QColor'
        pass
    
    @classmethod
    def underlineStyle(cls, self):
        'underlineStyle(self) -> QTextCharFormat.UnderlineStyle'
        pass
    
    @classmethod
    def verticalAlignment(cls, self):
        'verticalAlignment(self) -> QTextCharFormat.VerticalAlignment'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> float'
        return 1.0
    

class QTextInlineObject(_mod_sip.simplewrapper):
    'QTextInlineObject()\nQTextInlineObject(QTextInlineObject)'
    __class__ = QTextInlineObject
    __dict__ = {}
    def __init__(self, QTextInlineObject):
        'QTextInlineObject()\nQTextInlineObject(QTextInlineObject)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> float'
        return 1.0
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> float'
        return 1.0
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def height(cls, self):
        'height(self) -> float'
        return 1.0
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRectF'
        pass
    
    @classmethod
    def setAscent(cls, self, float):
        'setAscent(self, float)'
        pass
    
    @classmethod
    def setDescent(cls, self, float):
        'setDescent(self, float)'
        pass
    
    @classmethod
    def setWidth(cls, self, float):
        'setWidth(self, float)'
        pass
    
    @classmethod
    def textDirection(cls, self):
        'textDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def textPosition(cls, self):
        'textPosition(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> float'
        return 1.0
    

class QTextItem(_mod_sip.simplewrapper):
    'QTextItem()\nQTextItem(QTextItem)'
    Overline = RenderFlag()
    RenderFlag = RenderFlag()
    RenderFlags = RenderFlags()
    RightToLeft = RenderFlag()
    StrikeOut = RenderFlag()
    Underline = RenderFlag()
    __class__ = QTextItem
    __dict__ = {}
    def __init__(self, QTextItem):
        'QTextItem()\nQTextItem(QTextItem)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> float'
        return 1.0
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> float'
        return 1.0
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def renderFlags(cls, self):
        'renderFlags(self) -> QTextItem.RenderFlags'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def width(cls, self):
        'width(self) -> float'
        return 1.0
    

class QTextLayout(_mod_sip.simplewrapper):
    'QTextLayout()\nQTextLayout(str)\nQTextLayout(str, QFont, paintDevice: QPaintDevice = None)\nQTextLayout(QTextBlock)'
    CursorMode = CursorMode()
    FormatRange = FormatRange()
    SkipCharacters = CursorMode()
    SkipWords = CursorMode()
    __class__ = QTextLayout
    __dict__ = {}
    def __init__(self, str, QFont, paintDevice: QPaintDevice=None):
        'QTextLayout()\nQTextLayout(str)\nQTextLayout(str, QFont, paintDevice: QPaintDevice = None)\nQTextLayout(QTextBlock)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def additionalFormats(cls, self):
        'additionalFormats(self) -> List[QTextLayout.FormatRange]'
        pass
    
    @classmethod
    def beginLayout(cls, self):
        'beginLayout(self)'
        pass
    
    @classmethod
    def boundingRect(cls, self):
        'boundingRect(self) -> QRectF'
        pass
    
    @classmethod
    def cacheEnabled(cls, self):
        'cacheEnabled(self) -> bool'
        return True
    
    @classmethod
    def clearAdditionalFormats(cls, self):
        'clearAdditionalFormats(self)'
        pass
    
    @classmethod
    def clearFormats(cls, self):
        'clearFormats(self)'
        pass
    
    @classmethod
    def clearLayout(cls, self):
        'clearLayout(self)'
        pass
    
    @classmethod
    def createLine(cls, self):
        'createLine(self) -> QTextLine'
        pass
    
    @classmethod
    def cursorMoveStyle(cls, self):
        'cursorMoveStyle(self) -> Qt.CursorMoveStyle'
        pass
    
    @classmethod
    def draw(cls, self, QPainter, UnionQPointF=None, QPoint=None, selections: object=None, clip: QRectF=QRectF()):
        'draw(self, QPainter, Union[QPointF, QPoint], selections: object = QVector&lt;QTextLayout.FormatRange&gt;(), clip: QRectF = QRectF())'
        pass
    
    @classmethod
    def drawCursor(cls, self, QPainter, UnionQPointF=None, QPoint=None, int=None, int_=None):
        'drawCursor(self, QPainter, Union[QPointF, QPoint], int)\ndrawCursor(self, QPainter, Union[QPointF, QPoint], int, int)'
        pass
    
    @classmethod
    def endLayout(cls, self):
        'endLayout(self)'
        pass
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def formats(cls, self):
        'formats(self) -> List[QTextLayout.FormatRange]'
        pass
    
    @classmethod
    def glyphRuns(cls, self, from_: int=-1, length: int=-1):
        'glyphRuns(self, from_: int = -1, length: int = -1) -> object'
        pass
    
    @classmethod
    def isValidCursorPosition(cls, self, int):
        'isValidCursorPosition(self, int) -> bool'
        return True
    
    @classmethod
    def leftCursorPosition(cls, self, int):
        'leftCursorPosition(self, int) -> int'
        return 1
    
    @classmethod
    def lineAt(cls, self, int):
        'lineAt(self, int) -> QTextLine'
        pass
    
    @classmethod
    def lineCount(cls, self):
        'lineCount(self) -> int'
        return 1
    
    @classmethod
    def lineForTextPosition(cls, self, int):
        'lineForTextPosition(self, int) -> QTextLine'
        pass
    
    @classmethod
    def maximumWidth(cls, self):
        'maximumWidth(self) -> float'
        return 1.0
    
    @classmethod
    def minimumWidth(cls, self):
        'minimumWidth(self) -> float'
        return 1.0
    
    @classmethod
    def nextCursorPosition(cls, self, int, mode: QTextLayout.CursorMode=QTextLayout.SkipCharacters):
        'nextCursorPosition(self, int, mode: QTextLayout.CursorMode = QTextLayout.SkipCharacters) -> int'
        return 1
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPointF'
        pass
    
    @classmethod
    def preeditAreaPosition(cls, self):
        'preeditAreaPosition(self) -> int'
        return 1
    
    @classmethod
    def preeditAreaText(cls, self):
        'preeditAreaText(self) -> str'
        return ''
    
    @classmethod
    def previousCursorPosition(cls, self, int, mode: QTextLayout.CursorMode=QTextLayout.SkipCharacters):
        'previousCursorPosition(self, int, mode: QTextLayout.CursorMode = QTextLayout.SkipCharacters) -> int'
        return 1
    
    @classmethod
    def rightCursorPosition(cls, self, int):
        'rightCursorPosition(self, int) -> int'
        return 1
    
    @classmethod
    def setAdditionalFormats(cls, self, object):
        'setAdditionalFormats(self, object)'
        pass
    
    @classmethod
    def setCacheEnabled(cls, self, bool):
        'setCacheEnabled(self, bool)'
        pass
    
    @classmethod
    def setCursorMoveStyle(cls, self, QtCursorMoveStyle):
        'setCursorMoveStyle(self, Qt.CursorMoveStyle)'
        pass
    
    @classmethod
    def setFont(cls, self, QFont):
        'setFont(self, QFont)'
        pass
    
    @classmethod
    def setFormats(cls, self, IterableQTextLayoutFormatRange=None):
        'setFormats(self, Iterable[QTextLayout.FormatRange])'
        pass
    
    @classmethod
    def setPosition(cls, self, UnionQPointF=None, QPoint=None):
        'setPosition(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def setPreeditArea(cls, self, int, str):
        'setPreeditArea(self, int, str)'
        pass
    
    @classmethod
    def setText(cls, self, str):
        'setText(self, str)'
        pass
    
    @classmethod
    def setTextOption(cls, self, QTextOption):
        'setTextOption(self, QTextOption)'
        pass
    
    @classmethod
    def text(cls, self):
        'text(self) -> str'
        return ''
    
    @classmethod
    def textOption(cls, self):
        'textOption(self) -> QTextOption'
        pass
    

class QTextLength(_mod_sip.simplewrapper):
    'QTextLength()\nQTextLength(QTextLength.Type, float)\nQTextLength(Any)\nQTextLength(QTextLength)'
    FixedLength = Type()
    PercentageLength = Type()
    Type = Type()
    VariableLength = Type()
    __class__ = QTextLength
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextLengthType, float):
        'QTextLength()\nQTextLength(QTextLength.Type, float)\nQTextLength(Any)\nQTextLength(QTextLength)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def rawValue(cls, self):
        'rawValue(self) -> float'
        return 1.0
    
    @classmethod
    def type(cls, self):
        'type(self) -> QTextLength.Type'
        pass
    
    @classmethod
    def value(cls, self, float):
        'value(self, float) -> float'
        return 1.0
    

class QTextLine(_mod_sip.simplewrapper):
    'QTextLine()\nQTextLine(QTextLine)'
    CursorBetweenCharacters = CursorPosition()
    CursorOnCharacter = CursorPosition()
    CursorPosition = CursorPosition()
    Edge = Edge()
    Leading = Edge()
    Trailing = Edge()
    __class__ = QTextLine
    __dict__ = {}
    def __init__(self, QTextLine):
        'QTextLine()\nQTextLine(QTextLine)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def ascent(cls, self):
        'ascent(self) -> float'
        return 1.0
    
    @classmethod
    def cursorToX(cls, self, int, edge: QTextLine.Edge=QTextLine.Leading):
        'cursorToX(self, int, edge: QTextLine.Edge = QTextLine.Leading) -> Tuple[float, int]'
        pass
    
    @classmethod
    def descent(cls, self):
        'descent(self) -> float'
        return 1.0
    
    @classmethod
    def draw(cls, self, QPainter, UnionQPointF=None, QPoint=None, selection: QTextLayout.FormatRange=None):
        'draw(self, QPainter, Union[QPointF, QPoint], selection: QTextLayout.FormatRange = None)'
        pass
    
    @classmethod
    def glyphRuns(cls, self, from_: int=-1, length: int=-1):
        'glyphRuns(self, from_: int = -1, length: int = -1) -> List[QGlyphRun]'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> float'
        return 1.0
    
    @classmethod
    def horizontalAdvance(cls, self):
        'horizontalAdvance(self) -> float'
        return 1.0
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def leading(cls, self):
        'leading(self) -> float'
        return 1.0
    
    @classmethod
    def leadingIncluded(cls, self):
        'leadingIncluded(self) -> bool'
        return True
    
    @classmethod
    def lineNumber(cls, self):
        'lineNumber(self) -> int'
        return 1
    
    @classmethod
    def naturalTextRect(cls, self):
        'naturalTextRect(self) -> QRectF'
        pass
    
    @classmethod
    def naturalTextWidth(cls, self):
        'naturalTextWidth(self) -> float'
        return 1.0
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPointF'
        pass
    
    @classmethod
    def rect(cls, self):
        'rect(self) -> QRectF'
        pass
    
    @classmethod
    def setLeadingIncluded(cls, self, bool):
        'setLeadingIncluded(self, bool)'
        pass
    
    @classmethod
    def setLineWidth(cls, self, float):
        'setLineWidth(self, float)'
        pass
    
    @classmethod
    def setNumColumns(cls, self, int, float):
        'setNumColumns(self, int)\nsetNumColumns(self, int, float)'
        pass
    
    @classmethod
    def setPosition(cls, self, UnionQPointF=None, QPoint=None):
        'setPosition(self, Union[QPointF, QPoint])'
        pass
    
    @classmethod
    def textLength(cls, self):
        'textLength(self) -> int'
        return 1
    
    @classmethod
    def textStart(cls, self):
        'textStart(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> float'
        return 1.0
    
    @classmethod
    def x(cls, self):
        'x(self) -> float'
        return 1.0
    
    @classmethod
    def xToCursor(cls, self, float, edge: QTextLine.CursorPosition=QTextLine.CursorBetweenCharacters):
        'xToCursor(self, float, edge: QTextLine.CursorPosition = QTextLine.CursorBetweenCharacters) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> float'
        return 1.0
    

class QTextList(QTextBlockGroup):
    'QTextList(QTextDocument)'
    __class__ = QTextList
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QTextList(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __len__(self):
        'Return len(self).'
        return 0
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def add(cls, self, QTextBlock):
        'add(self, QTextBlock)'
        pass
    
    @classmethod
    def blockFormatChanged(cls, self, QTextBlock):
        'blockFormatChanged(self, QTextBlock)'
        pass
    
    @classmethod
    def blockInserted(cls, self, QTextBlock):
        'blockInserted(self, QTextBlock)'
        pass
    
    @classmethod
    def blockList(cls, self):
        'blockList(self) -> object'
        pass
    
    @classmethod
    def blockRemoved(cls, self, QTextBlock):
        'blockRemoved(self, QTextBlock)'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def count(cls, self):
        'count(self) -> int'
        return 1
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextListFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def item(cls, self, int):
        'item(self, int) -> QTextBlock'
        pass
    
    @classmethod
    def itemNumber(cls, self, QTextBlock):
        'itemNumber(self, QTextBlock) -> int'
        return 1
    
    @classmethod
    def itemText(cls, self, QTextBlock):
        'itemText(self, QTextBlock) -> str'
        return ''
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def remove(cls, self, QTextBlock):
        'remove(self, QTextBlock)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def removeItem(cls, self, int):
        'removeItem(self, int)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextListFormat):
        'setFormat(self, QTextListFormat)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTextListFormat(QTextFormat):
    'QTextListFormat()\nQTextListFormat(QTextListFormat)'
    ListCircle = Style()
    ListDecimal = Style()
    ListDisc = Style()
    ListLowerAlpha = Style()
    ListLowerRoman = Style()
    ListSquare = Style()
    ListUpperAlpha = Style()
    ListUpperRoman = Style()
    Style = Style()
    __class__ = QTextListFormat
    __dict__ = {}
    def __init__(self, QTextListFormat):
        'QTextListFormat()\nQTextListFormat(QTextListFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def indent(cls, self):
        'indent(self) -> int'
        return 1
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def numberPrefix(cls, self):
        'numberPrefix(self) -> str'
        return ''
    
    @classmethod
    def numberSuffix(cls, self):
        'numberSuffix(self) -> str'
        return ''
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setIndent(cls, self, int):
        'setIndent(self, int)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setNumberPrefix(cls, self, str):
        'setNumberPrefix(self, str)'
        pass
    
    @classmethod
    def setNumberSuffix(cls, self, str):
        'setNumberSuffix(self, str)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setStyle(cls, self, QTextListFormatStyle):
        'setStyle(self, QTextListFormat.Style)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def style(cls, self):
        'style(self) -> QTextListFormat.Style'
        pass
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    

class QTextObject(_mod_PyQt5_QtCore.QObject):
    'QTextObject(QTextDocument)'
    __class__ = QTextObject
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QTextObject(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextFormat):
        'setFormat(self, QTextFormat)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTextObjectInterface(_mod_sip.simplewrapper):
    'QTextObjectInterface()\nQTextObjectInterface(QTextObjectInterface)'
    __class__ = QTextObjectInterface
    __dict__ = {}
    def __init__(self, QTextObjectInterface):
        'QTextObjectInterface()\nQTextObjectInterface(QTextObjectInterface)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def drawObject(cls, self, QPainter, QRectF, QTextDocument, int, QTextFormat):
        'drawObject(self, QPainter, QRectF, QTextDocument, int, QTextFormat)'
        pass
    
    @classmethod
    def intrinsicSize(cls, self, QTextDocument, int, QTextFormat):
        'intrinsicSize(self, QTextDocument, int, QTextFormat) -> QSizeF'
        pass
    

class QTextOption(_mod_sip.simplewrapper):
    'QTextOption()\nQTextOption(Union[Qt.Alignment, Qt.AlignmentFlag])\nQTextOption(QTextOption)'
    AddSpaceForLineAndParagraphSeparators = Flag()
    CenterTab = TabType()
    DelimiterTab = TabType()
    Flag = Flag()
    Flags = Flags()
    IncludeTrailingSpaces = Flag()
    LeftTab = TabType()
    ManualWrap = WrapMode()
    NoWrap = WrapMode()
    RightTab = TabType()
    ShowDocumentTerminator = Flag()
    ShowLineAndParagraphSeparators = Flag()
    ShowTabsAndSpaces = Flag()
    SuppressColors = Flag()
    Tab = Tab()
    TabType = TabType()
    WordWrap = WrapMode()
    WrapAnywhere = WrapMode()
    WrapAtWordBoundaryOrAnywhere = WrapMode()
    WrapMode = WrapMode()
    __class__ = QTextOption
    __dict__ = {}
    def __init__(self, UnionQtAlignment=None, QtAlignmentFlag=None):
        'QTextOption()\nQTextOption(Union[Qt.Alignment, Qt.AlignmentFlag])\nQTextOption(QTextOption)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def alignment(cls, self):
        'alignment(self) -> Qt.Alignment'
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> QTextOption.Flags'
        pass
    
    @classmethod
    def setAlignment(cls, self, UnionQtAlignment=None, QtAlignmentFlag=None):
        'setAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag])'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQTextOptionFlags=None, QTextOptionFlag=None):
        'setFlags(self, Union[QTextOption.Flags, QTextOption.Flag])'
        pass
    
    @classmethod
    def setTabArray(cls, self, Iterablefloat=None):
        'setTabArray(self, Iterable[float])'
        pass
    
    @classmethod
    def setTabStop(cls, self, float):
        'setTabStop(self, float)'
        pass
    
    @classmethod
    def setTabs(cls, self, IterableQTextOptionTab=None):
        'setTabs(self, Iterable[QTextOption.Tab])'
        pass
    
    @classmethod
    def setTextDirection(cls, self, QtLayoutDirection):
        'setTextDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setUseDesignMetrics(cls, self, bool):
        'setUseDesignMetrics(self, bool)'
        pass
    
    @classmethod
    def setWrapMode(cls, self, QTextOptionWrapMode):
        'setWrapMode(self, QTextOption.WrapMode)'
        pass
    
    @classmethod
    def tabArray(cls, self):
        'tabArray(self) -> List[float]'
        pass
    
    @classmethod
    def tabStop(cls, self):
        'tabStop(self) -> float'
        return 1.0
    
    @classmethod
    def tabs(cls, self):
        'tabs(self) -> List[QTextOption.Tab]'
        pass
    
    @classmethod
    def textDirection(cls, self):
        'textDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def useDesignMetrics(cls, self):
        'useDesignMetrics(self) -> bool'
        return True
    
    @classmethod
    def wrapMode(cls, self):
        'wrapMode(self) -> QTextOption.WrapMode'
        pass
    

class QTextTable(QTextFrame):
    'QTextTable(QTextDocument)'
    __class__ = QTextTable
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, QTextDocument):
        'QTextTable(QTextDocument)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def appendColumns(cls, self, int):
        'appendColumns(self, int)'
        pass
    
    @classmethod
    def appendRows(cls, self, int):
        'appendRows(self, int)'
        pass
    
    @classmethod
    def begin(cls, self):
        'begin(self) -> QTextFrame.iterator'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def cellAt(cls, self, QTextCursor):
        'cellAt(self, int, int) -> QTextTableCell\ncellAt(self, int) -> QTextTableCell\ncellAt(self, QTextCursor) -> QTextTableCell'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def childFrames(cls, self):
        'childFrames(self) -> object'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def columns(cls, self):
        'columns(self) -> int'
        return 1
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def document(cls, self):
        'document(self) -> QTextDocument'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def end(cls, self):
        'end(self) -> QTextFrame.iterator'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def firstCursorPosition(cls, self):
        'firstCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def firstPosition(cls, self):
        'firstPosition(self) -> int'
        return 1
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def formatIndex(cls, self):
        'formatIndex(self) -> int'
        return 1
    
    @classmethod
    def frameFormat(cls, self):
        'frameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def insertColumns(cls, self, int, int_):
        'insertColumns(self, int, int)'
        pass
    
    @classmethod
    def insertRows(cls, self, int, int_):
        'insertRows(self, int, int)'
        pass
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def lastCursorPosition(cls, self):
        'lastCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def lastPosition(cls, self):
        'lastPosition(self) -> int'
        return 1
    
    @classmethod
    def mergeCells(cls, self, int, int_, int_1, int_2):
        'mergeCells(self, int, int, int, int)\nmergeCells(self, QTextCursor)'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def parentFrame(cls, self):
        'parentFrame(self) -> QTextFrame'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeColumns(cls, self, int, int_):
        'removeColumns(self, int, int)'
        pass
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def removeRows(cls, self, int, int_):
        'removeRows(self, int, int)'
        pass
    
    @classmethod
    def resize(cls, self, int, int_):
        'resize(self, int, int)'
        pass
    
    @classmethod
    def rowEnd(cls, self, QTextCursor):
        'rowEnd(self, QTextCursor) -> QTextCursor'
        pass
    
    @classmethod
    def rowStart(cls, self, QTextCursor):
        'rowStart(self, QTextCursor) -> QTextCursor'
        pass
    
    @classmethod
    def rows(cls, self):
        'rows(self) -> int'
        return 1
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextTableFormat):
        'setFormat(self, QTextTableFormat)'
        pass
    
    @classmethod
    def setFrameFormat(cls, self, QTextFrameFormat):
        'setFrameFormat(self, QTextFrameFormat)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def splitCell(cls, self, int, int_, int_1, int_2):
        'splitCell(self, int, int, int, int)'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    

class QTextTableCell(_mod_sip.simplewrapper):
    'QTextTableCell()\nQTextTableCell(QTextTableCell)'
    __class__ = QTextTableCell
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __init__(self, QTextTableCell):
        'QTextTableCell()\nQTextTableCell(QTextTableCell)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def column(cls, self):
        'column(self) -> int'
        return 1
    
    @classmethod
    def columnSpan(cls, self):
        'columnSpan(self) -> int'
        return 1
    
    @classmethod
    def firstCursorPosition(cls, self):
        'firstCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def lastCursorPosition(cls, self):
        'lastCursorPosition(self) -> QTextCursor'
        pass
    
    @classmethod
    def row(cls, self):
        'row(self) -> int'
        return 1
    
    @classmethod
    def rowSpan(cls, self):
        'rowSpan(self) -> int'
        return 1
    
    @classmethod
    def setFormat(cls, self, QTextCharFormat):
        'setFormat(self, QTextCharFormat)'
        pass
    
    @classmethod
    def tableCellFormatIndex(cls, self):
        'tableCellFormatIndex(self) -> int'
        return 1
    

class QTextTableCellFormat(QTextCharFormat):
    'QTextTableCellFormat()\nQTextTableCellFormat(QTextTableCellFormat)'
    __class__ = QTextTableCellFormat
    __dict__ = {}
    def __init__(self, QTextTableCellFormat):
        'QTextTableCellFormat()\nQTextTableCellFormat(QTextTableCellFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def anchorHref(cls, self):
        'anchorHref(self) -> str'
        return ''
    
    @classmethod
    def anchorNames(cls, self):
        'anchorNames(self) -> List[str]'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def bottomPadding(cls, self):
        'bottomPadding(self) -> float'
        return 1.0
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def font(cls, self):
        'font(self) -> QFont'
        pass
    
    @classmethod
    def fontCapitalization(cls, self):
        'fontCapitalization(self) -> QFont.Capitalization'
        pass
    
    @classmethod
    def fontFamily(cls, self):
        'fontFamily(self) -> str'
        return ''
    
    @classmethod
    def fontFixedPitch(cls, self):
        'fontFixedPitch(self) -> bool'
        return True
    
    @classmethod
    def fontHintingPreference(cls, self):
        'fontHintingPreference(self) -> QFont.HintingPreference'
        pass
    
    @classmethod
    def fontItalic(cls, self):
        'fontItalic(self) -> bool'
        return True
    
    @classmethod
    def fontKerning(cls, self):
        'fontKerning(self) -> bool'
        return True
    
    @classmethod
    def fontLetterSpacing(cls, self):
        'fontLetterSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def fontLetterSpacingType(cls, self):
        'fontLetterSpacingType(self) -> QFont.SpacingType'
        pass
    
    @classmethod
    def fontOverline(cls, self):
        'fontOverline(self) -> bool'
        return True
    
    @classmethod
    def fontPointSize(cls, self):
        'fontPointSize(self) -> float'
        return 1.0
    
    @classmethod
    def fontStretch(cls, self):
        'fontStretch(self) -> int'
        return 1
    
    @classmethod
    def fontStrikeOut(cls, self):
        'fontStrikeOut(self) -> bool'
        return True
    
    @classmethod
    def fontStyleHint(cls, self):
        'fontStyleHint(self) -> QFont.StyleHint'
        pass
    
    @classmethod
    def fontStyleStrategy(cls, self):
        'fontStyleStrategy(self) -> QFont.StyleStrategy'
        pass
    
    @classmethod
    def fontUnderline(cls, self):
        'fontUnderline(self) -> bool'
        return True
    
    @classmethod
    def fontWeight(cls, self):
        'fontWeight(self) -> int'
        return 1
    
    @classmethod
    def fontWordSpacing(cls, self):
        'fontWordSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isAnchor(cls, self):
        'isAnchor(self) -> bool'
        return True
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def leftPadding(cls, self):
        'leftPadding(self) -> float'
        return 1.0
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def rightPadding(cls, self):
        'rightPadding(self) -> float'
        return 1.0
    
    @classmethod
    def setAnchor(cls, self, bool):
        'setAnchor(self, bool)'
        pass
    
    @classmethod
    def setAnchorHref(cls, self, str):
        'setAnchorHref(self, str)'
        pass
    
    @classmethod
    def setAnchorNames(cls, self, Iterablestr=None):
        'setAnchorNames(self, Iterable[str])'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBottomPadding(cls, self, float):
        'setBottomPadding(self, float)'
        pass
    
    @classmethod
    def setFont(cls, self, QFont, QTextCharFormatFontPropertiesInheritanceBehavior):
        'setFont(self, QFont)\nsetFont(self, QFont, QTextCharFormat.FontPropertiesInheritanceBehavior)'
        pass
    
    @classmethod
    def setFontCapitalization(cls, self, QFontCapitalization):
        'setFontCapitalization(self, QFont.Capitalization)'
        pass
    
    @classmethod
    def setFontFamily(cls, self, str):
        'setFontFamily(self, str)'
        pass
    
    @classmethod
    def setFontFixedPitch(cls, self, bool):
        'setFontFixedPitch(self, bool)'
        pass
    
    @classmethod
    def setFontHintingPreference(cls, self, QFontHintingPreference):
        'setFontHintingPreference(self, QFont.HintingPreference)'
        pass
    
    @classmethod
    def setFontItalic(cls, self, bool):
        'setFontItalic(self, bool)'
        pass
    
    @classmethod
    def setFontKerning(cls, self, bool):
        'setFontKerning(self, bool)'
        pass
    
    @classmethod
    def setFontLetterSpacing(cls, self, float):
        'setFontLetterSpacing(self, float)'
        pass
    
    @classmethod
    def setFontLetterSpacingType(cls, self, QFontSpacingType):
        'setFontLetterSpacingType(self, QFont.SpacingType)'
        pass
    
    @classmethod
    def setFontOverline(cls, self, bool):
        'setFontOverline(self, bool)'
        pass
    
    @classmethod
    def setFontPointSize(cls, self, float):
        'setFontPointSize(self, float)'
        pass
    
    @classmethod
    def setFontStretch(cls, self, int):
        'setFontStretch(self, int)'
        pass
    
    @classmethod
    def setFontStrikeOut(cls, self, bool):
        'setFontStrikeOut(self, bool)'
        pass
    
    @classmethod
    def setFontStyleHint(cls, self, QFontStyleHint, strategy: QFont.StyleStrategy=QFont.PreferDefault):
        'setFontStyleHint(self, QFont.StyleHint, strategy: QFont.StyleStrategy = QFont.PreferDefault)'
        pass
    
    @classmethod
    def setFontStyleStrategy(cls, self, QFontStyleStrategy):
        'setFontStyleStrategy(self, QFont.StyleStrategy)'
        pass
    
    @classmethod
    def setFontUnderline(cls, self, bool):
        'setFontUnderline(self, bool)'
        pass
    
    @classmethod
    def setFontWeight(cls, self, int):
        'setFontWeight(self, int)'
        pass
    
    @classmethod
    def setFontWordSpacing(cls, self, float):
        'setFontWordSpacing(self, float)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setLeftPadding(cls, self, float):
        'setLeftPadding(self, float)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setPadding(cls, self, float):
        'setPadding(self, float)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setRightPadding(cls, self, float):
        'setRightPadding(self, float)'
        pass
    
    @classmethod
    def setTableCellColumnSpan(cls, self, int):
        'setTableCellColumnSpan(self, int)'
        pass
    
    @classmethod
    def setTableCellRowSpan(cls, self, int):
        'setTableCellRowSpan(self, int)'
        pass
    
    @classmethod
    def setTextOutline(cls, self, UnionQPen=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setTextOutline(self, Union[QPen, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setToolTip(cls, self, str):
        'setToolTip(self, str)'
        pass
    
    @classmethod
    def setTopPadding(cls, self, float):
        'setTopPadding(self, float)'
        pass
    
    @classmethod
    def setUnderlineColor(cls, self, UnionQColor=None, QtGlobalColor=None, QGradient=None):
        'setUnderlineColor(self, Union[QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setUnderlineStyle(cls, self, QTextCharFormatUnderlineStyle):
        'setUnderlineStyle(self, QTextCharFormat.UnderlineStyle)'
        pass
    
    @classmethod
    def setVerticalAlignment(cls, self, QTextCharFormatVerticalAlignment):
        'setVerticalAlignment(self, QTextCharFormat.VerticalAlignment)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def tableCellColumnSpan(cls, self):
        'tableCellColumnSpan(self) -> int'
        return 1
    
    @classmethod
    def tableCellRowSpan(cls, self):
        'tableCellRowSpan(self) -> int'
        return 1
    
    @classmethod
    def textOutline(cls, self):
        'textOutline(self) -> QPen'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def toolTip(cls, self):
        'toolTip(self) -> str'
        return ''
    
    @classmethod
    def topPadding(cls, self):
        'topPadding(self) -> float'
        return 1.0
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def underlineColor(cls, self):
        'underlineColor(self) -> QColor'
        pass
    
    @classmethod
    def underlineStyle(cls, self):
        'underlineStyle(self) -> QTextCharFormat.UnderlineStyle'
        pass
    
    @classmethod
    def verticalAlignment(cls, self):
        'verticalAlignment(self) -> QTextCharFormat.VerticalAlignment'
        pass
    

class QTextTableFormat(QTextFrameFormat):
    'QTextTableFormat()\nQTextTableFormat(QTextTableFormat)'
    __class__ = QTextTableFormat
    __dict__ = {}
    def __init__(self, QTextTableFormat):
        'QTextTableFormat()\nQTextTableFormat(QTextTableFormat)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def alignment(cls, self):
        'alignment(self) -> Qt.Alignment'
        pass
    
    @classmethod
    def background(cls, self):
        'background(self) -> QBrush'
        pass
    
    @classmethod
    def boolProperty(cls, self, int):
        'boolProperty(self, int) -> bool'
        return True
    
    @classmethod
    def border(cls, self):
        'border(self) -> float'
        return 1.0
    
    @classmethod
    def borderBrush(cls, self):
        'borderBrush(self) -> QBrush'
        pass
    
    @classmethod
    def borderStyle(cls, self):
        'borderStyle(self) -> QTextFrameFormat.BorderStyle'
        pass
    
    @classmethod
    def bottomMargin(cls, self):
        'bottomMargin(self) -> float'
        return 1.0
    
    @classmethod
    def brushProperty(cls, self, int):
        'brushProperty(self, int) -> QBrush'
        pass
    
    @classmethod
    def cellPadding(cls, self):
        'cellPadding(self) -> float'
        return 1.0
    
    @classmethod
    def cellSpacing(cls, self):
        'cellSpacing(self) -> float'
        return 1.0
    
    @classmethod
    def clearBackground(cls, self):
        'clearBackground(self)'
        pass
    
    @classmethod
    def clearColumnWidthConstraints(cls, self):
        'clearColumnWidthConstraints(self)'
        pass
    
    @classmethod
    def clearForeground(cls, self):
        'clearForeground(self)'
        pass
    
    @classmethod
    def clearProperty(cls, self, int):
        'clearProperty(self, int)'
        pass
    
    @classmethod
    def colorProperty(cls, self, int):
        'colorProperty(self, int) -> QColor'
        pass
    
    @classmethod
    def columnWidthConstraints(cls, self):
        'columnWidthConstraints(self) -> List[QTextLength]'
        pass
    
    @classmethod
    def columns(cls, self):
        'columns(self) -> int'
        return 1
    
    @classmethod
    def doubleProperty(cls, self, int):
        'doubleProperty(self, int) -> float'
        return 1.0
    
    @classmethod
    def foreground(cls, self):
        'foreground(self) -> QBrush'
        pass
    
    @classmethod
    def hasProperty(cls, self, int):
        'hasProperty(self, int) -> bool'
        return True
    
    @classmethod
    def headerRowCount(cls, self):
        'headerRowCount(self) -> int'
        return 1
    
    @classmethod
    def height(cls, self):
        'height(self) -> QTextLength'
        pass
    
    @classmethod
    def intProperty(cls, self, int):
        'intProperty(self, int) -> int'
        return 1
    
    @classmethod
    def isBlockFormat(cls, self):
        'isBlockFormat(self) -> bool'
        return True
    
    @classmethod
    def isCharFormat(cls, self):
        'isCharFormat(self) -> bool'
        return True
    
    @classmethod
    def isEmpty(cls, self):
        'isEmpty(self) -> bool'
        return True
    
    @classmethod
    def isFrameFormat(cls, self):
        'isFrameFormat(self) -> bool'
        return True
    
    @classmethod
    def isImageFormat(cls, self):
        'isImageFormat(self) -> bool'
        return True
    
    @classmethod
    def isListFormat(cls, self):
        'isListFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableCellFormat(cls, self):
        'isTableCellFormat(self) -> bool'
        return True
    
    @classmethod
    def isTableFormat(cls, self):
        'isTableFormat(self) -> bool'
        return True
    
    @classmethod
    def isValid(cls, self):
        'isValid(self) -> bool'
        return True
    
    @classmethod
    def layoutDirection(cls, self):
        'layoutDirection(self) -> Qt.LayoutDirection'
        pass
    
    @classmethod
    def leftMargin(cls, self):
        'leftMargin(self) -> float'
        return 1.0
    
    @classmethod
    def lengthProperty(cls, self, int):
        'lengthProperty(self, int) -> QTextLength'
        pass
    
    @classmethod
    def lengthVectorProperty(cls, self, int):
        'lengthVectorProperty(self, int) -> object'
        pass
    
    @classmethod
    def margin(cls, self):
        'margin(self) -> float'
        return 1.0
    
    @classmethod
    def merge(cls, self, QTextFormat):
        'merge(self, QTextFormat)'
        pass
    
    @classmethod
    def objectIndex(cls, self):
        'objectIndex(self) -> int'
        return 1
    
    @classmethod
    def objectType(cls, self):
        'objectType(self) -> int'
        return 1
    
    @classmethod
    def padding(cls, self):
        'padding(self) -> float'
        return 1.0
    
    @classmethod
    def pageBreakPolicy(cls, self):
        'pageBreakPolicy(self) -> QTextFormat.PageBreakFlags'
        pass
    
    @classmethod
    def penProperty(cls, self, int):
        'penProperty(self, int) -> QPen'
        pass
    
    @classmethod
    def position(cls, self):
        'position(self) -> QTextFrameFormat.Position'
        pass
    
    @classmethod
    def properties(cls, self):
        'properties(self) -> Dict[int, Any]'
        pass
    
    @classmethod
    def property(cls, self, int):
        'property(self, int) -> Any'
        pass
    
    @classmethod
    def propertyCount(cls, self):
        'propertyCount(self) -> int'
        return 1
    
    @classmethod
    def rightMargin(cls, self):
        'rightMargin(self) -> float'
        return 1.0
    
    @classmethod
    def setAlignment(cls, self, UnionQtAlignment=None, QtAlignmentFlag=None):
        'setAlignment(self, Union[Qt.Alignment, Qt.AlignmentFlag])'
        pass
    
    @classmethod
    def setBackground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBackground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBorder(cls, self, float):
        'setBorder(self, float)'
        pass
    
    @classmethod
    def setBorderBrush(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setBorderBrush(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setBorderStyle(cls, self, QTextFrameFormatBorderStyle):
        'setBorderStyle(self, QTextFrameFormat.BorderStyle)'
        pass
    
    @classmethod
    def setBottomMargin(cls, self, float):
        'setBottomMargin(self, float)'
        pass
    
    @classmethod
    def setCellPadding(cls, self, float):
        'setCellPadding(self, float)'
        pass
    
    @classmethod
    def setCellSpacing(cls, self, float):
        'setCellSpacing(self, float)'
        pass
    
    @classmethod
    def setColumnWidthConstraints(cls, self, IterableQTextLength=None):
        'setColumnWidthConstraints(self, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setColumns(cls, self, int):
        'setColumns(self, int)'
        pass
    
    @classmethod
    def setForeground(cls, self, UnionQBrush=None, QColor=None, QtGlobalColor=None, QGradient=None):
        'setForeground(self, Union[QBrush, QColor, Qt.GlobalColor, QGradient])'
        pass
    
    @classmethod
    def setHeaderRowCount(cls, self, int):
        'setHeaderRowCount(self, int)'
        pass
    
    @classmethod
    def setHeight(cls, self, QTextLength):
        'setHeight(self, float)\nsetHeight(self, QTextLength)'
        pass
    
    @classmethod
    def setLayoutDirection(cls, self, QtLayoutDirection):
        'setLayoutDirection(self, Qt.LayoutDirection)'
        pass
    
    @classmethod
    def setLeftMargin(cls, self, float):
        'setLeftMargin(self, float)'
        pass
    
    @classmethod
    def setMargin(cls, self, float):
        'setMargin(self, float)'
        pass
    
    @classmethod
    def setObjectIndex(cls, self, int):
        'setObjectIndex(self, int)'
        pass
    
    @classmethod
    def setObjectType(cls, self, int):
        'setObjectType(self, int)'
        pass
    
    @classmethod
    def setPadding(cls, self, float):
        'setPadding(self, float)'
        pass
    
    @classmethod
    def setPageBreakPolicy(cls, self, UnionQTextFormatPageBreakFlags=None, QTextFormatPageBreakFlag=None):
        'setPageBreakPolicy(self, Union[QTextFormat.PageBreakFlags, QTextFormat.PageBreakFlag])'
        pass
    
    @classmethod
    def setPosition(cls, self, QTextFrameFormatPosition):
        'setPosition(self, QTextFrameFormat.Position)'
        pass
    
    @classmethod
    def setProperty(cls, self, int, IterableQTextLength=None):
        'setProperty(self, int, Any)\nsetProperty(self, int, Iterable[QTextLength])'
        pass
    
    @classmethod
    def setRightMargin(cls, self, float):
        'setRightMargin(self, float)'
        pass
    
    @classmethod
    def setTopMargin(cls, self, float):
        'setTopMargin(self, float)'
        pass
    
    @classmethod
    def setWidth(cls, self, QTextLength):
        'setWidth(self, QTextLength)\nsetWidth(self, float)'
        pass
    
    @classmethod
    def stringProperty(cls, self, int):
        'stringProperty(self, int) -> str'
        return ''
    
    @classmethod
    def swap(cls, self, QTextFormat):
        'swap(self, QTextFormat)'
        pass
    
    @classmethod
    def toBlockFormat(cls, self):
        'toBlockFormat(self) -> QTextBlockFormat'
        pass
    
    @classmethod
    def toCharFormat(cls, self):
        'toCharFormat(self) -> QTextCharFormat'
        pass
    
    @classmethod
    def toFrameFormat(cls, self):
        'toFrameFormat(self) -> QTextFrameFormat'
        pass
    
    @classmethod
    def toImageFormat(cls, self):
        'toImageFormat(self) -> QTextImageFormat'
        pass
    
    @classmethod
    def toListFormat(cls, self):
        'toListFormat(self) -> QTextListFormat'
        pass
    
    @classmethod
    def toTableCellFormat(cls, self):
        'toTableCellFormat(self) -> QTextTableCellFormat'
        pass
    
    @classmethod
    def toTableFormat(cls, self):
        'toTableFormat(self) -> QTextTableFormat'
        pass
    
    @classmethod
    def topMargin(cls, self):
        'topMargin(self) -> float'
        return 1.0
    
    @classmethod
    def type(cls, self):
        'type(self) -> int'
        return 1
    
    @classmethod
    def width(cls, self):
        'width(self) -> QTextLength'
        pass
    

class QTouchDevice(_mod_sip.simplewrapper):
    'QTouchDevice()\nQTouchDevice(QTouchDevice)'
    Area = CapabilityFlag()
    Capabilities = Capabilities()
    CapabilityFlag = CapabilityFlag()
    DeviceType = DeviceType()
    MouseEmulation = CapabilityFlag()
    NormalizedPosition = CapabilityFlag()
    Position = CapabilityFlag()
    Pressure = CapabilityFlag()
    RawPositions = CapabilityFlag()
    TouchPad = DeviceType()
    TouchScreen = DeviceType()
    Velocity = CapabilityFlag()
    __class__ = QTouchDevice
    __dict__ = {}
    def __init__(self, QTouchDevice):
        'QTouchDevice()\nQTouchDevice(QTouchDevice)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def capabilities(cls, self):
        'capabilities(self) -> QTouchDevice.Capabilities'
        pass
    
    @classmethod
    def devices(cls):
        'devices() -> object'
        pass
    
    @classmethod
    def maximumTouchPoints(cls, self):
        'maximumTouchPoints(self) -> int'
        return 1
    
    @classmethod
    def name(cls, self):
        'name(self) -> str'
        return ''
    
    @classmethod
    def setCapabilities(cls, self, UnionQTouchDeviceCapabilities=None, QTouchDeviceCapabilityFlag=None):
        'setCapabilities(self, Union[QTouchDevice.Capabilities, QTouchDevice.CapabilityFlag])'
        pass
    
    @classmethod
    def setMaximumTouchPoints(cls, self, int):
        'setMaximumTouchPoints(self, int)'
        pass
    
    @classmethod
    def setName(cls, self, str):
        'setName(self, str)'
        pass
    
    @classmethod
    def setType(cls, self, QTouchDeviceDeviceType):
        'setType(self, QTouchDevice.DeviceType)'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QTouchDevice.DeviceType'
        pass
    

class QTouchEvent(QInputEvent):
    'QTouchEvent(QEvent.Type, device: QTouchDevice = None, modifiers: Union[Qt.KeyboardModifiers, Qt.KeyboardModifier] = Qt.NoModifier, touchPointStates: Union[Qt.TouchPointStates, Qt.TouchPointState] = 0, touchPoints: object = QList&lt;QTouchEvent.TouchPoint&gt;())\nQTouchEvent(QTouchEvent)'
    TouchPoint = TouchPoint()
    __class__ = QTouchEvent
    __dict__ = {}
    def __init__(self, QEventType, device: QTouchDevice=None, modifiers: Union[Qt.KeyboardModifiers,Qt.KeyboardModifier]=Qt.NoModifier, touchPointStates: Union[Qt.TouchPointStates,Qt.TouchPointState]=0, touchPoints: object=None):
        'QTouchEvent(QEvent.Type, device: QTouchDevice = None, modifiers: Union[Qt.KeyboardModifiers, Qt.KeyboardModifier] = Qt.NoModifier, touchPointStates: Union[Qt.TouchPointStates, Qt.TouchPointState] = 0, touchPoints: object = QList&lt;QTouchEvent.TouchPoint&gt;())\nQTouchEvent(QTouchEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def device(cls, self):
        'device(self) -> QTouchDevice'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setDevice(cls, self, QTouchDevice):
        'setDevice(self, QTouchDevice)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def target(cls, self):
        'target(self) -> QObject'
        pass
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def touchPointStates(cls, self):
        'touchPointStates(self) -> Qt.TouchPointStates'
        pass
    
    @classmethod
    def touchPoints(cls, self):
        'touchPoints(self) -> List[QTouchEvent.TouchPoint]'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def window(cls, self):
        'window(self) -> QWindow'
        pass
    

class QTransform(_mod_sip.simplewrapper):
    'QTransform()\nQTransform(float, float, float, float, float, float, float, float, m33: float = 1)\nQTransform(float, float, float, float, float, float)\nQTransform(QTransform)'
    TransformationType = TransformationType()
    TxNone = TransformationType()
    TxProject = TransformationType()
    TxRotate = TransformationType()
    TxScale = TransformationType()
    TxShear = TransformationType()
    TxTranslate = TransformationType()
    def __add__(self, value):
        'Return self+value.'
        return QTransform()
    
    __class__ = QTransform
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    def __hash__(self):
        'Return hash(self).'
        return 0
    
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imatmul__(self, value):
        'Return self@=value.'
        pass
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, float, float_, float_1, float_2, float_3, float_4, float_5, float_6, m33: float=1):
        'QTransform()\nQTransform(float, float, float, float, float, float, float, float, m33: float = 1)\nQTransform(float, float, float, float, float, float)\nQTransform(QTransform)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    def __matmul__(self, value):
        'Return self@value.'
        pass
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QTransform()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __radd__(self, value):
        'Return value+self.'
        return QTransform()
    
    def __reduce__(self):
        return ''; return ()
    
    def __rmatmul__(self, value):
        'Return value@self.'
        pass
    
    def __rmul__(self, value):
        'Return value*self.'
        return QTransform()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QTransform()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QTransform()
    
    def __sub__(self, value):
        'Return self-value.'
        return QTransform()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def adjoint(cls, self):
        'adjoint(self) -> QTransform'
        pass
    
    @classmethod
    def determinant(cls, self):
        'determinant(self) -> float'
        return 1.0
    
    @classmethod
    def dx(cls, self):
        'dx(self) -> float'
        return 1.0
    
    @classmethod
    def dy(cls, self):
        'dy(self) -> float'
        return 1.0
    
    @classmethod
    def fromScale(cls, float, float_):
        'fromScale(float, float) -> QTransform'
        pass
    
    @classmethod
    def fromTranslate(cls, float, float_):
        'fromTranslate(float, float) -> QTransform'
        pass
    
    @classmethod
    def inverted(cls, self):
        'inverted(self) -> Tuple[QTransform, bool]'
        pass
    
    @classmethod
    def isAffine(cls, self):
        'isAffine(self) -> bool'
        return True
    
    @classmethod
    def isIdentity(cls, self):
        'isIdentity(self) -> bool'
        return True
    
    @classmethod
    def isInvertible(cls, self):
        'isInvertible(self) -> bool'
        return True
    
    @classmethod
    def isRotating(cls, self):
        'isRotating(self) -> bool'
        return True
    
    @classmethod
    def isScaling(cls, self):
        'isScaling(self) -> bool'
        return True
    
    @classmethod
    def isTranslating(cls, self):
        'isTranslating(self) -> bool'
        return True
    
    @classmethod
    def m11(cls, self):
        'm11(self) -> float'
        return 1.0
    
    @classmethod
    def m12(cls, self):
        'm12(self) -> float'
        return 1.0
    
    @classmethod
    def m13(cls, self):
        'm13(self) -> float'
        return 1.0
    
    @classmethod
    def m21(cls, self):
        'm21(self) -> float'
        return 1.0
    
    @classmethod
    def m22(cls, self):
        'm22(self) -> float'
        return 1.0
    
    @classmethod
    def m23(cls, self):
        'm23(self) -> float'
        return 1.0
    
    @classmethod
    def m31(cls, self):
        'm31(self) -> float'
        return 1.0
    
    @classmethod
    def m32(cls, self):
        'm32(self) -> float'
        return 1.0
    
    @classmethod
    def m33(cls, self):
        'm33(self) -> float'
        return 1.0
    
    @classmethod
    def map(cls, self, UnionQPointF=None, QPoint=None):
        'map(self, int, int) -> Tuple[int, int]\nmap(self, float, float) -> Tuple[float, float]\nmap(self, QPoint) -> QPoint\nmap(self, Union[QPointF, QPoint]) -> QPointF\nmap(self, QLine) -> QLine\nmap(self, QLineF) -> QLineF\nmap(self, QPolygonF) -> QPolygonF\nmap(self, QPolygon) -> QPolygon\nmap(self, QRegion) -> QRegion\nmap(self, QPainterPath) -> QPainterPath'
        pass
    
    @classmethod
    def mapRect(cls, self, QRectF):
        'mapRect(self, QRect) -> QRect\nmapRect(self, QRectF) -> QRectF'
        pass
    
    @classmethod
    def mapToPolygon(cls, self, QRect):
        'mapToPolygon(self, QRect) -> QPolygon'
        pass
    
    @classmethod
    def quadToQuad(cls, QPolygonF, QPolygonF_, QTransform):
        'quadToQuad(QPolygonF, QPolygonF, QTransform) -> bool'
        return True
    
    @classmethod
    def quadToSquare(cls, QPolygonF, QTransform):
        'quadToSquare(QPolygonF, QTransform) -> bool'
        return True
    
    @classmethod
    def reset(cls, self):
        'reset(self)'
        pass
    
    @classmethod
    def rotate(cls, self, float, axis: Qt.Axis=Qt.ZAxis):
        'rotate(self, float, axis: Qt.Axis = Qt.ZAxis) -> QTransform'
        pass
    
    @classmethod
    def rotateRadians(cls, self, float, axis: Qt.Axis=Qt.ZAxis):
        'rotateRadians(self, float, axis: Qt.Axis = Qt.ZAxis) -> QTransform'
        pass
    
    @classmethod
    def scale(cls, self, float, float_):
        'scale(self, float, float) -> QTransform'
        pass
    
    @classmethod
    def setMatrix(cls, self, float, float_, float_1, float_2, float_3, float_4, float_5, float_6, float_7):
        'setMatrix(self, float, float, float, float, float, float, float, float, float)'
        pass
    
    @classmethod
    def shear(cls, self, float, float_):
        'shear(self, float, float) -> QTransform'
        pass
    
    @classmethod
    def squareToQuad(cls, QPolygonF, QTransform):
        'squareToQuad(QPolygonF, QTransform) -> bool'
        return True
    
    @classmethod
    def translate(cls, self, float, float_):
        'translate(self, float, float) -> QTransform'
        pass
    
    @classmethod
    def transposed(cls, self):
        'transposed(self) -> QTransform'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> QTransform.TransformationType'
        pass
    

class QValidator(_mod_PyQt5_QtCore.QObject):
    'QValidator(parent: QObject = None)'
    Acceptable = State()
    Intermediate = State()
    Invalid = State()
    State = State()
    __class__ = QValidator
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, parent: QObject=None):
        'QValidator(parent: QObject = None)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    def changed(self):
        'changed(self) [signal]'
        pass
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def fixup(cls, self, str):
        'fixup(self, str) -> str'
        return ''
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def locale(cls, self):
        'locale(self) -> QLocale'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def parent(cls, self):
        'parent(self) -> QObject'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setLocale(cls, self, QLocale):
        'setLocale(self, QLocale)'
        pass
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setParent(cls, self, QObject):
        'setParent(self, QObject)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def validate(cls, self, str, int):
        'validate(self, str, int) -> Tuple[QValidator.State, str, int]'
        pass
    

class QVector2D(_mod_sip.simplewrapper):
    'QVector2D()\nQVector2D(float, float)\nQVector2D(QPoint)\nQVector2D(Union[QPointF, QPoint])\nQVector2D(QVector3D)\nQVector2D(QVector4D)\nQVector2D(QVector2D)'
    def __add__(self, value):
        'Return self+value.'
        return QVector2D()
    
    __class__ = QVector2D
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, UnionQPointF=None, QPoint=None):
        'QVector2D()\nQVector2D(float, float)\nQVector2D(QPoint)\nQVector2D(Union[QPointF, QPoint])\nQVector2D(QVector3D)\nQVector2D(QVector4D)\nQVector2D(QVector2D)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QVector2D()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __neg__(self):
        '-self'
        return QVector2D()
    
    def __radd__(self, value):
        'Return value+self.'
        return QVector2D()
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __rmul__(self, value):
        'Return value*self.'
        return QVector2D()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QVector2D()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QVector2D()
    
    def __sub__(self, value):
        'Return self-value.'
        return QVector2D()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def distanceToLine(cls, self, QVector2D, QVector2D_):
        'distanceToLine(self, QVector2D, QVector2D) -> float'
        return 1.0
    
    @classmethod
    def distanceToPoint(cls, self, QVector2D):
        'distanceToPoint(self, QVector2D) -> float'
        return 1.0
    
    @classmethod
    def dotProduct(cls, QVector2D, QVector2D_):
        'dotProduct(QVector2D, QVector2D) -> float'
        return 1.0
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> float'
        return 1.0
    
    @classmethod
    def lengthSquared(cls, self):
        'lengthSquared(self) -> float'
        return 1.0
    
    @classmethod
    def normalize(cls, self):
        'normalize(self)'
        pass
    
    @classmethod
    def normalized(cls, self):
        'normalized(self) -> QVector2D'
        pass
    
    @classmethod
    def setX(cls, self, float):
        'setX(self, float)'
        pass
    
    @classmethod
    def setY(cls, self, float):
        'setY(self, float)'
        pass
    
    @classmethod
    def toPoint(cls, self):
        'toPoint(self) -> QPoint'
        pass
    
    @classmethod
    def toPointF(cls, self):
        'toPointF(self) -> QPointF'
        pass
    
    @classmethod
    def toVector3D(cls, self):
        'toVector3D(self) -> QVector3D'
        pass
    
    @classmethod
    def toVector4D(cls, self):
        'toVector4D(self) -> QVector4D'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> float'
        return 1.0
    
    @classmethod
    def y(cls, self):
        'y(self) -> float'
        return 1.0
    

class QVector3D(_mod_sip.simplewrapper):
    'QVector3D()\nQVector3D(float, float, float)\nQVector3D(QPoint)\nQVector3D(Union[QPointF, QPoint])\nQVector3D(QVector2D)\nQVector3D(QVector2D, float)\nQVector3D(QVector4D)\nQVector3D(QVector3D)'
    def __add__(self, value):
        'Return self+value.'
        return QVector3D()
    
    __class__ = QVector3D
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, UnionQPointF=None, QPoint=None):
        'QVector3D()\nQVector3D(float, float, float)\nQVector3D(QPoint)\nQVector3D(Union[QPointF, QPoint])\nQVector3D(QVector2D)\nQVector3D(QVector2D, float)\nQVector3D(QVector4D)\nQVector3D(QVector3D)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QVector3D()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __neg__(self):
        '-self'
        return QVector3D()
    
    def __radd__(self, value):
        'Return value+self.'
        return QVector3D()
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __rmul__(self, value):
        'Return value*self.'
        return QVector3D()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QVector3D()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QVector3D()
    
    def __sub__(self, value):
        'Return self-value.'
        return QVector3D()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def crossProduct(cls, QVector3D, QVector3D_):
        'crossProduct(QVector3D, QVector3D) -> QVector3D'
        pass
    
    @classmethod
    def distanceToLine(cls, self, QVector3D, QVector3D_):
        'distanceToLine(self, QVector3D, QVector3D) -> float'
        return 1.0
    
    @classmethod
    def distanceToPlane(cls, self, QVector3D, QVector3D_, QVector3D_1):
        'distanceToPlane(self, QVector3D, QVector3D) -> float\ndistanceToPlane(self, QVector3D, QVector3D, QVector3D) -> float'
        return 1.0
    
    @classmethod
    def distanceToPoint(cls, self, QVector3D):
        'distanceToPoint(self, QVector3D) -> float'
        return 1.0
    
    @classmethod
    def dotProduct(cls, QVector3D, QVector3D_):
        'dotProduct(QVector3D, QVector3D) -> float'
        return 1.0
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> float'
        return 1.0
    
    @classmethod
    def lengthSquared(cls, self):
        'lengthSquared(self) -> float'
        return 1.0
    
    @classmethod
    def normal(cls, QVector3D, QVector3D_, QVector3D_1):
        'normal(QVector3D, QVector3D) -> QVector3D\nnormal(QVector3D, QVector3D, QVector3D) -> QVector3D'
        pass
    
    @classmethod
    def normalize(cls, self):
        'normalize(self)'
        pass
    
    @classmethod
    def normalized(cls, self):
        'normalized(self) -> QVector3D'
        pass
    
    @classmethod
    def project(cls, self, QMatrix4x4, QMatrix4x4_, QRect):
        'project(self, QMatrix4x4, QMatrix4x4, QRect) -> QVector3D'
        pass
    
    @classmethod
    def setX(cls, self, float):
        'setX(self, float)'
        pass
    
    @classmethod
    def setY(cls, self, float):
        'setY(self, float)'
        pass
    
    @classmethod
    def setZ(cls, self, float):
        'setZ(self, float)'
        pass
    
    @classmethod
    def toPoint(cls, self):
        'toPoint(self) -> QPoint'
        pass
    
    @classmethod
    def toPointF(cls, self):
        'toPointF(self) -> QPointF'
        pass
    
    @classmethod
    def toVector2D(cls, self):
        'toVector2D(self) -> QVector2D'
        pass
    
    @classmethod
    def toVector4D(cls, self):
        'toVector4D(self) -> QVector4D'
        pass
    
    @classmethod
    def unproject(cls, self, QMatrix4x4, QMatrix4x4_, QRect):
        'unproject(self, QMatrix4x4, QMatrix4x4, QRect) -> QVector3D'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> float'
        return 1.0
    
    @classmethod
    def y(cls, self):
        'y(self) -> float'
        return 1.0
    
    @classmethod
    def z(cls, self):
        'z(self) -> float'
        return 1.0
    

class QVector4D(_mod_sip.simplewrapper):
    'QVector4D()\nQVector4D(float, float, float, float)\nQVector4D(QPoint)\nQVector4D(Union[QPointF, QPoint])\nQVector4D(QVector2D)\nQVector4D(QVector2D, float, float)\nQVector4D(QVector3D)\nQVector4D(QVector3D, float)\nQVector4D(QVector4D)'
    def __add__(self, value):
        'Return self+value.'
        return QVector4D()
    
    __class__ = QVector4D
    __dict__ = {}
    def __eq__(self, value):
        'Return self==value.'
        return False
    
    def __ge__(self, value):
        'Return self>=value.'
        return False
    
    def __getitem__(self, key):
        'Return self[key].'
        pass
    
    def __gt__(self, value):
        'Return self>value.'
        return False
    
    __hash__ = None
    def __iadd__(self, value):
        'Return self+=value.'
        return None
    
    def __imul__(self, value):
        'Return self*=value.'
        return None
    
    def __init__(self, float, float_, float_1, float_2):
        'QVector4D()\nQVector4D(float, float, float, float)\nQVector4D(QPoint)\nQVector4D(Union[QPointF, QPoint])\nQVector4D(QVector2D)\nQVector4D(QVector2D, float, float)\nQVector4D(QVector3D)\nQVector4D(QVector3D, float)\nQVector4D(QVector4D)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __isub__(self, value):
        'Return self-=value.'
        return None
    
    def __itruediv__(self, value):
        'Return self/=value.'
        pass
    
    def __le__(self, value):
        'Return self<=value.'
        return False
    
    def __lt__(self, value):
        'Return self<value.'
        return False
    
    __module__ = 'PyQt5.QtGui'
    def __mul__(self, value):
        'Return self*value.'
        return QVector4D()
    
    def __ne__(self, value):
        'Return self!=value.'
        return False
    
    def __neg__(self):
        '-self'
        return QVector4D()
    
    def __radd__(self, value):
        'Return value+self.'
        return QVector4D()
    
    def __reduce__(self):
        return ''; return ()
    
    def __repr__(self):
        'Return repr(self).'
        return ''
    
    def __rmul__(self, value):
        'Return value*self.'
        return QVector4D()
    
    def __rsub__(self, value):
        'Return value-self.'
        return QVector4D()
    
    def __rtruediv__(self, value):
        'Return value/self.'
        return QVector4D()
    
    def __sub__(self, value):
        'Return self-value.'
        return QVector4D()
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def __truediv__(self, value):
        'Return self/value.'
        return 0.0
    
    @property
    def __weakref__(self):
        'list of weak references to the object (if defined)'
        pass
    
    @classmethod
    def dotProduct(cls, QVector4D, QVector4D_):
        'dotProduct(QVector4D, QVector4D) -> float'
        return 1.0
    
    @classmethod
    def isNull(cls, self):
        'isNull(self) -> bool'
        return True
    
    @classmethod
    def length(cls, self):
        'length(self) -> float'
        return 1.0
    
    @classmethod
    def lengthSquared(cls, self):
        'lengthSquared(self) -> float'
        return 1.0
    
    @classmethod
    def normalize(cls, self):
        'normalize(self)'
        pass
    
    @classmethod
    def normalized(cls, self):
        'normalized(self) -> QVector4D'
        pass
    
    @classmethod
    def setW(cls, self, float):
        'setW(self, float)'
        pass
    
    @classmethod
    def setX(cls, self, float):
        'setX(self, float)'
        pass
    
    @classmethod
    def setY(cls, self, float):
        'setY(self, float)'
        pass
    
    @classmethod
    def setZ(cls, self, float):
        'setZ(self, float)'
        pass
    
    @classmethod
    def toPoint(cls, self):
        'toPoint(self) -> QPoint'
        pass
    
    @classmethod
    def toPointF(cls, self):
        'toPointF(self) -> QPointF'
        pass
    
    @classmethod
    def toVector2D(cls, self):
        'toVector2D(self) -> QVector2D'
        pass
    
    @classmethod
    def toVector2DAffine(cls, self):
        'toVector2DAffine(self) -> QVector2D'
        pass
    
    @classmethod
    def toVector3D(cls, self):
        'toVector3D(self) -> QVector3D'
        pass
    
    @classmethod
    def toVector3DAffine(cls, self):
        'toVector3DAffine(self) -> QVector3D'
        pass
    
    @classmethod
    def w(cls, self):
        'w(self) -> float'
        return 1.0
    
    @classmethod
    def x(cls, self):
        'x(self) -> float'
        return 1.0
    
    @classmethod
    def y(cls, self):
        'y(self) -> float'
        return 1.0
    
    @classmethod
    def z(cls, self):
        'z(self) -> float'
        return 1.0
    

class QWhatsThisClickedEvent(_mod_PyQt5_QtCore.QEvent):
    'QWhatsThisClickedEvent(str)\nQWhatsThisClickedEvent(QWhatsThisClickedEvent)'
    __class__ = QWhatsThisClickedEvent
    __dict__ = {}
    def __init__(self, QWhatsThisClickedEvent):
        'QWhatsThisClickedEvent(str)\nQWhatsThisClickedEvent(QWhatsThisClickedEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def href(cls, self):
        'href(self) -> str'
        return ''
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

class QWheelEvent(QInputEvent):
    'QWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase)\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase, Qt.MouseEventSource)\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase, Qt.MouseEventSource, bool)\nQWheelEvent(QWheelEvent)'
    __class__ = QWheelEvent
    __dict__ = {}
    def __init__(self, UnionQPointF=None, QPoint=None, UnionQPointF_=None, QPoint_=None, QPoint_1=None, QPoint_2=None, int=None, QtOrientation=None, UnionQtMouseButtons=None, QtMouseButton=None, UnionQtKeyboardModifiers=None, QtKeyboardModifier=None, QtScrollPhase=None, QtMouseEventSource=None, bool=None):
        'QWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier])\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase)\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase, Qt.MouseEventSource)\nQWheelEvent(Union[QPointF, QPoint], Union[QPointF, QPoint], QPoint, QPoint, int, Qt.Orientation, Union[Qt.MouseButtons, Qt.MouseButton], Union[Qt.KeyboardModifiers, Qt.KeyboardModifier], Qt.ScrollPhase, Qt.MouseEventSource, bool)\nQWheelEvent(QWheelEvent)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def angleDelta(cls, self):
        'angleDelta(self) -> QPoint'
        pass
    
    @classmethod
    def buttons(cls, self):
        'buttons(self) -> Qt.MouseButtons'
        pass
    
    @classmethod
    def globalPos(cls, self):
        'globalPos(self) -> QPoint'
        pass
    
    @classmethod
    def globalPosF(cls, self):
        'globalPosF(self) -> QPointF'
        pass
    
    @classmethod
    def globalX(cls, self):
        'globalX(self) -> int'
        return 1
    
    @classmethod
    def globalY(cls, self):
        'globalY(self) -> int'
        return 1
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def inverted(cls, self):
        'inverted(self) -> bool'
        return True
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def modifiers(cls, self):
        'modifiers(self) -> Qt.KeyboardModifiers'
        pass
    
    @classmethod
    def phase(cls, self):
        'phase(self) -> Qt.ScrollPhase'
        pass
    
    @classmethod
    def pixelDelta(cls, self):
        'pixelDelta(self) -> QPoint'
        pass
    
    @classmethod
    def pos(cls, self):
        'pos(self) -> QPoint'
        pass
    
    @classmethod
    def posF(cls, self):
        'posF(self) -> QPointF'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def setTimestamp(cls, self, int):
        'setTimestamp(self, int)'
        pass
    
    @classmethod
    def source(cls, self):
        'source(self) -> Qt.MouseEventSource'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def timestamp(cls, self):
        'timestamp(self) -> int'
        return 1
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    

class QWindow(_mod_PyQt5_QtCore.QObject,QSurface):
    'QWindow(screen: QScreen = None)\nQWindow(QWindow)'
    AncestorMode = AncestorMode()
    AutomaticVisibility = Visibility()
    ExcludeTransients = AncestorMode()
    FullScreen = Visibility()
    Hidden = Visibility()
    IncludeTransients = AncestorMode()
    Maximized = Visibility()
    Minimized = Visibility()
    Visibility = Visibility()
    Windowed = Visibility()
    __class__ = QWindow
    __dict__ = {}
    @classmethod
    def __getattr__(cls, self, str):
        '__getattr__(self, str) -> object'
        pass
    
    def __init__(self, screen: QScreen=None):
        'QWindow(screen: QScreen = None)\nQWindow(QWindow)'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def activeChanged(self):
        'activeChanged(self) [signal]'
        pass
    
    @classmethod
    def alert(cls, self, int):
        'alert(self, int)'
        pass
    
    @classmethod
    def baseSize(cls, self):
        'baseSize(self) -> QSize'
        pass
    
    @classmethod
    def blockSignals(cls, self, bool):
        'blockSignals(self, bool) -> bool'
        return True
    
    @classmethod
    def childEvent(cls, self, QChildEvent):
        'childEvent(self, QChildEvent)'
        pass
    
    @classmethod
    def children(cls, self):
        'children(self) -> object'
        pass
    
    @classmethod
    def close(cls, self):
        'close(self) -> bool'
        return True
    
    @classmethod
    def connectNotify(cls, self, QMetaMethod):
        'connectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def contentOrientation(cls, self):
        'contentOrientation(self) -> Qt.ScreenOrientation'
        pass
    
    @classmethod
    def create(cls, self):
        'create(self)'
        pass
    
    @classmethod
    def cursor(cls, self):
        'cursor(self) -> QCursor'
        pass
    
    @classmethod
    def customEvent(cls, self, QEvent):
        'customEvent(self, QEvent)'
        pass
    
    @classmethod
    def deleteLater(cls, self):
        'deleteLater(self)'
        pass
    
    @classmethod
    def destroy(cls, self):
        'destroy(self)'
        pass
    
    @classmethod
    def devicePixelRatio(cls, self):
        'devicePixelRatio(self) -> float'
        return 1.0
    
    @classmethod
    def disconnect(cls, self):
        'disconnect(self)'
        pass
    
    @classmethod
    def disconnectNotify(cls, self, QMetaMethod):
        'disconnectNotify(self, QMetaMethod)'
        pass
    
    @classmethod
    def dumpObjectInfo(cls, self):
        'dumpObjectInfo(self)'
        pass
    
    @classmethod
    def dumpObjectTree(cls, self):
        'dumpObjectTree(self)'
        pass
    
    @classmethod
    def dynamicPropertyNames(cls, self):
        'dynamicPropertyNames(self) -> object'
        pass
    
    @classmethod
    def event(cls, self, QEvent):
        'event(self, QEvent) -> bool'
        return True
    
    @classmethod
    def eventFilter(cls, self, QObject, QEvent):
        'eventFilter(self, QObject, QEvent) -> bool'
        return True
    
    @classmethod
    def exposeEvent(cls, self, QExposeEvent):
        'exposeEvent(self, QExposeEvent)'
        pass
    
    @classmethod
    def filePath(cls, self):
        'filePath(self) -> str'
        return ''
    
    @classmethod
    def findChild(cls, self, Tuple, name: str='', options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\nfindChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject"
        pass
    
    @classmethod
    def findChildren(cls, self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions,Qt.FindChildOption]=Qt.FindChildrenRecursively):
        "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\nfindChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]"
        pass
    
    @classmethod
    def flags(cls, self):
        'flags(self) -> Qt.WindowFlags'
        pass
    
    @classmethod
    def focusInEvent(cls, self, QFocusEvent):
        'focusInEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def focusObject(cls, self):
        'focusObject(self) -> QObject'
        pass
    
    def focusObjectChanged(self, QObject):
        'focusObjectChanged(self, QObject) [signal]'
        pass
    
    @classmethod
    def focusOutEvent(cls, self, QFocusEvent):
        'focusOutEvent(self, QFocusEvent)'
        pass
    
    @classmethod
    def format(cls, self):
        'format(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def frameGeometry(cls, self):
        'frameGeometry(self) -> QRect'
        pass
    
    @classmethod
    def frameMargins(cls, self):
        'frameMargins(self) -> QMargins'
        pass
    
    @classmethod
    def framePosition(cls, self):
        'framePosition(self) -> QPoint'
        pass
    
    @classmethod
    def fromWinId(cls, sipvoidptr):
        'fromWinId(sip.voidptr) -> QWindow'
        pass
    
    @classmethod
    def geometry(cls, self):
        'geometry(self) -> QRect'
        pass
    
    @classmethod
    def height(cls, self):
        'height(self) -> int'
        return 1
    
    def heightChanged(self, int):
        'heightChanged(self, int) [signal]'
        pass
    
    @classmethod
    def hide(cls, self):
        'hide(self)'
        pass
    
    @classmethod
    def hideEvent(cls, self, QHideEvent):
        'hideEvent(self, QHideEvent)'
        pass
    
    @classmethod
    def icon(cls, self):
        'icon(self) -> QIcon'
        pass
    
    @classmethod
    def inherits(cls, self, str):
        'inherits(self, str) -> bool'
        return True
    
    @classmethod
    def installEventFilter(cls, self, QObject):
        'installEventFilter(self, QObject)'
        pass
    
    @classmethod
    def isActive(cls, self):
        'isActive(self) -> bool'
        return True
    
    @classmethod
    def isAncestorOf(cls, self, QWindow, mode: QWindow.AncestorMode=QWindow.IncludeTransients):
        'isAncestorOf(self, QWindow, mode: QWindow.AncestorMode = QWindow.IncludeTransients) -> bool'
        return True
    
    @classmethod
    def isExposed(cls, self):
        'isExposed(self) -> bool'
        return True
    
    @classmethod
    def isModal(cls, self):
        'isModal(self) -> bool'
        return True
    
    @classmethod
    def isSignalConnected(cls, self, QMetaMethod):
        'isSignalConnected(self, QMetaMethod) -> bool'
        return True
    
    @classmethod
    def isTopLevel(cls, self):
        'isTopLevel(self) -> bool'
        return True
    
    @classmethod
    def isVisible(cls, self):
        'isVisible(self) -> bool'
        return True
    
    @classmethod
    def isWidgetType(cls, self):
        'isWidgetType(self) -> bool'
        return True
    
    @classmethod
    def isWindowType(cls, self):
        'isWindowType(self) -> bool'
        return True
    
    @classmethod
    def keyPressEvent(cls, self, QKeyEvent):
        'keyPressEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def keyReleaseEvent(cls, self, QKeyEvent):
        'keyReleaseEvent(self, QKeyEvent)'
        pass
    
    @classmethod
    def killTimer(cls, self, int):
        'killTimer(self, int)'
        pass
    
    @classmethod
    def lower(cls, self):
        'lower(self)'
        pass
    
    @classmethod
    def mapFromGlobal(cls, self, QPoint):
        'mapFromGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mapToGlobal(cls, self, QPoint):
        'mapToGlobal(self, QPoint) -> QPoint'
        pass
    
    @classmethod
    def mask(cls, self):
        'mask(self) -> QRegion'
        pass
    
    @classmethod
    def maximumHeight(cls, self):
        'maximumHeight(self) -> int'
        return 1
    
    def maximumHeightChanged(self, int):
        'maximumHeightChanged(self, int) [signal]'
        pass
    
    @classmethod
    def maximumSize(cls, self):
        'maximumSize(self) -> QSize'
        pass
    
    @classmethod
    def maximumWidth(cls, self):
        'maximumWidth(self) -> int'
        return 1
    
    def maximumWidthChanged(self, int):
        'maximumWidthChanged(self, int) [signal]'
        pass
    
    @classmethod
    def metaObject(cls, self):
        'metaObject(self) -> QMetaObject'
        pass
    
    @classmethod
    def minimumHeight(cls, self):
        'minimumHeight(self) -> int'
        return 1
    
    def minimumHeightChanged(self, int):
        'minimumHeightChanged(self, int) [signal]'
        pass
    
    @classmethod
    def minimumSize(cls, self):
        'minimumSize(self) -> QSize'
        pass
    
    @classmethod
    def minimumWidth(cls, self):
        'minimumWidth(self) -> int'
        return 1
    
    def minimumWidthChanged(self, int):
        'minimumWidthChanged(self, int) [signal]'
        pass
    
    @classmethod
    def modality(cls, self):
        'modality(self) -> Qt.WindowModality'
        pass
    
    @classmethod
    def mouseDoubleClickEvent(cls, self, QMouseEvent):
        'mouseDoubleClickEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseMoveEvent(cls, self, QMouseEvent):
        'mouseMoveEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mousePressEvent(cls, self, QMouseEvent):
        'mousePressEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def mouseReleaseEvent(cls, self, QMouseEvent):
        'mouseReleaseEvent(self, QMouseEvent)'
        pass
    
    @classmethod
    def moveEvent(cls, self, QMoveEvent):
        'moveEvent(self, QMoveEvent)'
        pass
    
    @classmethod
    def moveToThread(cls, self, QThread):
        'moveToThread(self, QThread)'
        pass
    
    @classmethod
    def objectName(cls, self):
        'objectName(self) -> str'
        return ''
    
    @classmethod
    def opacity(cls, self):
        'opacity(self) -> float'
        return 1.0
    
    def opacityChanged(self, float):
        'opacityChanged(self, float) [signal]'
        pass
    
    @classmethod
    def parent(cls, self, QWindowAncestorMode):
        'parent(self) -> QWindow\nparent(self, QWindow.AncestorMode) -> QWindow'
        pass
    
    @classmethod
    def position(cls, self):
        'position(self) -> QPoint'
        pass
    
    @classmethod
    def property(cls, self, str):
        'property(self, str) -> Any'
        pass
    
    @classmethod
    def pyqtConfigure(cls):
        'QObject.pyqtConfigure(...)\n\nEach keyword argument is either the name of a Qt property or a Qt signal.\nFor properties the property is set to the given value which should be of an\nappropriate type.\nFor signals the signal is connected to the given value which should be a\ncallable.'
        pass
    
    @classmethod
    def raise_(cls, self):
        'raise_(self)'
        pass
    
    @classmethod
    def receivers(cls, self, PYQT_SIGNAL):
        'receivers(self, PYQT_SIGNAL) -> int'
        return 1
    
    @classmethod
    def removeEventFilter(cls, self, QObject):
        'removeEventFilter(self, QObject)'
        pass
    
    @classmethod
    def reportContentOrientationChange(cls, self, QtScreenOrientation):
        'reportContentOrientationChange(self, Qt.ScreenOrientation)'
        pass
    
    @classmethod
    def requestActivate(cls, self):
        'requestActivate(self)'
        pass
    
    @classmethod
    def requestUpdate(cls, self):
        'requestUpdate(self)'
        pass
    
    @classmethod
    def requestedFormat(cls, self):
        'requestedFormat(self) -> QSurfaceFormat'
        pass
    
    @classmethod
    def resize(cls, self, int, int_):
        'resize(self, QSize)\nresize(self, int, int)'
        pass
    
    @classmethod
    def resizeEvent(cls, self, QResizeEvent):
        'resizeEvent(self, QResizeEvent)'
        pass
    
    @classmethod
    def screen(cls, self):
        'screen(self) -> QScreen'
        pass
    
    def screenChanged(self, QScreen):
        'screenChanged(self, QScreen) [signal]'
        pass
    
    @classmethod
    def sender(cls, self):
        'sender(self) -> QObject'
        pass
    
    @classmethod
    def senderSignalIndex(cls, self):
        'senderSignalIndex(self) -> int'
        return 1
    
    @classmethod
    def setBaseSize(cls, self, QSize):
        'setBaseSize(self, QSize)'
        pass
    
    @classmethod
    def setCursor(cls, self, UnionQCursor=None, QtCursorShape=None):
        'setCursor(self, Union[QCursor, Qt.CursorShape])'
        pass
    
    @classmethod
    def setFilePath(cls, self, str):
        'setFilePath(self, str)'
        pass
    
    @classmethod
    def setFlag(cls, self, QtWindowType, on: bool=True):
        'setFlag(self, Qt.WindowType, on: bool = True)'
        pass
    
    @classmethod
    def setFlags(cls, self, UnionQtWindowFlags=None, QtWindowType=None):
        'setFlags(self, Union[Qt.WindowFlags, Qt.WindowType])'
        pass
    
    @classmethod
    def setFormat(cls, self, QSurfaceFormat):
        'setFormat(self, QSurfaceFormat)'
        pass
    
    @classmethod
    def setFramePosition(cls, self, QPoint):
        'setFramePosition(self, QPoint)'
        pass
    
    @classmethod
    def setGeometry(cls, self, int, int_, int_1, int_2):
        'setGeometry(self, int, int, int, int)\nsetGeometry(self, QRect)'
        pass
    
    @classmethod
    def setHeight(cls, self, int):
        'setHeight(self, int)'
        pass
    
    @classmethod
    def setIcon(cls, self, QIcon):
        'setIcon(self, QIcon)'
        pass
    
    @classmethod
    def setKeyboardGrabEnabled(cls, self, bool):
        'setKeyboardGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setMask(cls, self, QRegion):
        'setMask(self, QRegion)'
        pass
    
    @classmethod
    def setMaximumHeight(cls, self, int):
        'setMaximumHeight(self, int)'
        pass
    
    @classmethod
    def setMaximumSize(cls, self, QSize):
        'setMaximumSize(self, QSize)'
        pass
    
    @classmethod
    def setMaximumWidth(cls, self, int):
        'setMaximumWidth(self, int)'
        pass
    
    @classmethod
    def setMinimumHeight(cls, self, int):
        'setMinimumHeight(self, int)'
        pass
    
    @classmethod
    def setMinimumSize(cls, self, QSize):
        'setMinimumSize(self, QSize)'
        pass
    
    @classmethod
    def setMinimumWidth(cls, self, int):
        'setMinimumWidth(self, int)'
        pass
    
    @classmethod
    def setModality(cls, self, QtWindowModality):
        'setModality(self, Qt.WindowModality)'
        pass
    
    @classmethod
    def setMouseGrabEnabled(cls, self, bool):
        'setMouseGrabEnabled(self, bool) -> bool'
        return True
    
    @classmethod
    def setObjectName(cls, self, str):
        'setObjectName(self, str)'
        pass
    
    @classmethod
    def setOpacity(cls, self, float):
        'setOpacity(self, float)'
        pass
    
    @classmethod
    def setParent(cls, self, QWindow):
        'setParent(self, QWindow)'
        pass
    
    @classmethod
    def setPosition(cls, self, int, int_):
        'setPosition(self, QPoint)\nsetPosition(self, int, int)'
        pass
    
    @classmethod
    def setProperty(cls, self, str, Any):
        'setProperty(self, str, Any) -> bool'
        return True
    
    @classmethod
    def setScreen(cls, self, QScreen):
        'setScreen(self, QScreen)'
        pass
    
    @classmethod
    def setSizeIncrement(cls, self, QSize):
        'setSizeIncrement(self, QSize)'
        pass
    
    @classmethod
    def setSurfaceType(cls, self, QSurfaceSurfaceType):
        'setSurfaceType(self, QSurface.SurfaceType)'
        pass
    
    @classmethod
    def setTitle(cls, self, str):
        'setTitle(self, str)'
        pass
    
    @classmethod
    def setTransientParent(cls, self, QWindow):
        'setTransientParent(self, QWindow)'
        pass
    
    @classmethod
    def setVisibility(cls, self, QWindowVisibility):
        'setVisibility(self, QWindow.Visibility)'
        pass
    
    @classmethod
    def setVisible(cls, self, bool):
        'setVisible(self, bool)'
        pass
    
    @classmethod
    def setWidth(cls, self, int):
        'setWidth(self, int)'
        pass
    
    @classmethod
    def setWindowState(cls, self, QtWindowState):
        'setWindowState(self, Qt.WindowState)'
        pass
    
    @classmethod
    def setX(cls, self, int):
        'setX(self, int)'
        pass
    
    @classmethod
    def setY(cls, self, int):
        'setY(self, int)'
        pass
    
    @classmethod
    def show(cls, self):
        'show(self)'
        pass
    
    @classmethod
    def showEvent(cls, self, QShowEvent):
        'showEvent(self, QShowEvent)'
        pass
    
    @classmethod
    def showFullScreen(cls, self):
        'showFullScreen(self)'
        pass
    
    @classmethod
    def showMaximized(cls, self):
        'showMaximized(self)'
        pass
    
    @classmethod
    def showMinimized(cls, self):
        'showMinimized(self)'
        pass
    
    @classmethod
    def showNormal(cls, self):
        'showNormal(self)'
        pass
    
    @classmethod
    def signalsBlocked(cls, self):
        'signalsBlocked(self) -> bool'
        return True
    
    @classmethod
    def size(cls, self):
        'size(self) -> QSize'
        pass
    
    @classmethod
    def sizeIncrement(cls, self):
        'sizeIncrement(self) -> QSize'
        pass
    
    @classmethod
    def startTimer(cls, self, int, timerType: Qt.TimerType=Qt.CoarseTimer):
        'startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int'
        return 1
    
    staticMetaObject = _mod_PyQt5_QtCore.QMetaObject()
    @classmethod
    def supportsOpenGL(cls, self):
        'supportsOpenGL(self) -> bool'
        return True
    
    @classmethod
    def surfaceClass(cls, self):
        'surfaceClass(self) -> QSurface.SurfaceClass'
        pass
    
    @classmethod
    def surfaceType(cls, self):
        'surfaceType(self) -> QSurface.SurfaceType'
        pass
    
    @classmethod
    def tabletEvent(cls, self, QTabletEvent):
        'tabletEvent(self, QTabletEvent)'
        pass
    
    @classmethod
    def thread(cls, self):
        'thread(self) -> QThread'
        pass
    
    @classmethod
    def timerEvent(cls, self, QTimerEvent):
        'timerEvent(self, QTimerEvent)'
        pass
    
    @classmethod
    def title(cls, self):
        'title(self) -> str'
        return ''
    
    @classmethod
    def touchEvent(cls, self, QTouchEvent):
        'touchEvent(self, QTouchEvent)'
        pass
    
    @classmethod
    def tr(cls, self, str, disambiguation: str=None, n: int=-1):
        'tr(self, str, disambiguation: str = None, n: int = -1) -> str'
        return ''
    
    @classmethod
    def transientParent(cls, self):
        'transientParent(self) -> QWindow'
        pass
    
    @classmethod
    def type(cls, self):
        'type(self) -> Qt.WindowType'
        pass
    
    @classmethod
    def unsetCursor(cls, self):
        'unsetCursor(self)'
        pass
    
    @classmethod
    def visibility(cls, self):
        'visibility(self) -> QWindow.Visibility'
        pass
    
    def visibilityChanged(self, QWindowVisibility):
        'visibilityChanged(self, QWindow.Visibility) [signal]'
        pass
    
    def visibleChanged(self, bool):
        'visibleChanged(self, bool) [signal]'
        pass
    
    @classmethod
    def wheelEvent(cls, self, QWheelEvent):
        'wheelEvent(self, QWheelEvent)'
        pass
    
    @classmethod
    def width(cls, self):
        'width(self) -> int'
        return 1
    
    def widthChanged(self, int):
        'widthChanged(self, int) [signal]'
        pass
    
    @classmethod
    def winId(cls, self):
        'winId(self) -> sip.voidptr'
        pass
    
    @classmethod
    def windowState(cls, self):
        'windowState(self) -> Qt.WindowState'
        pass
    
    def windowTitleChanged(self, str):
        'windowTitleChanged(self, str) [signal]'
        pass
    
    @classmethod
    def x(cls, self):
        'x(self) -> int'
        return 1
    
    def xChanged(self, int):
        'xChanged(self, int) [signal]'
        pass
    
    @classmethod
    def y(cls, self):
        'y(self) -> int'
        return 1
    
    def yChanged(self, int):
        'yChanged(self, int) [signal]'
        pass
    

class QWindowStateChangeEvent(_mod_PyQt5_QtCore.QEvent):
    __class__ = QWindowStateChangeEvent
    __dict__ = {}
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'PyQt5.QtGui'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    @classmethod
    def accept(cls, self):
        'accept(self)'
        pass
    
    @classmethod
    def ignore(cls, self):
        'ignore(self)'
        pass
    
    @classmethod
    def isAccepted(cls, self):
        'isAccepted(self) -> bool'
        return True
    
    @classmethod
    def oldState(cls, self):
        'oldState(self) -> Qt.WindowStates'
        pass
    
    @classmethod
    def registerEventType(cls, hint: int=-1):
        'registerEventType(hint: int = -1) -> int'
        return 1
    
    @classmethod
    def setAccepted(cls, self, bool):
        'setAccepted(self, bool)'
        pass
    
    @classmethod
    def spontaneous(cls, self):
        'spontaneous(self) -> bool'
        return True
    
    @classmethod
    def type(cls, self):
        'type(self) -> QEvent.Type'
        pass
    

__doc__ = None
__file__ = '/home/nj/.conda/envs/cs231n/lib/python3.6/site-packages/PyQt5/QtGui.so'
__name__ = 'PyQt5.QtGui'
__package__ = 'PyQt5'
def qAlpha(QRgba64):
    'qAlpha(QRgba64) -> int\nqAlpha(int) -> int'
    return 1

def qBlue(QRgba64):
    'qBlue(QRgba64) -> int\nqBlue(int) -> int'
    return 1

def qFuzzyCompare(QQuaternion, QQuaternion_):
    'qFuzzyCompare(QMatrix4x4, QMatrix4x4) -> bool\nqFuzzyCompare(QQuaternion, QQuaternion) -> bool\nqFuzzyCompare(QTransform, QTransform) -> bool\nqFuzzyCompare(QVector2D, QVector2D) -> bool\nqFuzzyCompare(QVector3D, QVector3D) -> bool\nqFuzzyCompare(QVector4D, QVector4D) -> bool'
    return True

def qGray(int, int_, int_1):
    'qGray(int, int, int) -> int\nqGray(int) -> int'
    return 1

def qGreen(QRgba64):
    'qGreen(QRgba64) -> int\nqGreen(int) -> int'
    return 1

def qIsGray(int):
    'qIsGray(int) -> bool'
    return True

def qPixelFormatAlpha(int, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.UnsignedInteger):
    'qPixelFormatAlpha(int, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.UnsignedInteger) -> QPixelFormat'
    pass

def qPixelFormatCmyk(int, alphaSize: int=0, alphaUsage: QPixelFormat.AlphaUsage=QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition=QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.UnsignedInteger):
    'qPixelFormatCmyk(int, alphaSize: int = 0, alphaUsage: QPixelFormat.AlphaUsage = QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition = QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.UnsignedInteger) -> QPixelFormat'
    pass

def qPixelFormatGrayscale(int, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.UnsignedInteger):
    'qPixelFormatGrayscale(int, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.UnsignedInteger) -> QPixelFormat'
    pass

def qPixelFormatHsl(int, alphaSize: int=0, alphaUsage: QPixelFormat.AlphaUsage=QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition=QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.FloatingPoint):
    'qPixelFormatHsl(int, alphaSize: int = 0, alphaUsage: QPixelFormat.AlphaUsage = QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition = QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.FloatingPoint) -> QPixelFormat'
    pass

def qPixelFormatHsv(int, alphaSize: int=0, alphaUsage: QPixelFormat.AlphaUsage=QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition=QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.FloatingPoint):
    'qPixelFormatHsv(int, alphaSize: int = 0, alphaUsage: QPixelFormat.AlphaUsage = QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition = QPixelFormat.AtBeginning, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.FloatingPoint) -> QPixelFormat'
    pass

def qPixelFormatRgba(int, int_, int_1, int_2, QPixelFormatAlphaUsage, QPixelFormatAlphaPosition, premultiplied: QPixelFormat.AlphaPremultiplied=QPixelFormat.NotPremultiplied, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.UnsignedInteger):
    'qPixelFormatRgba(int, int, int, int, QPixelFormat.AlphaUsage, QPixelFormat.AlphaPosition, premultiplied: QPixelFormat.AlphaPremultiplied = QPixelFormat.NotPremultiplied, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.UnsignedInteger) -> QPixelFormat'
    pass

def qPixelFormatYuv(QPixelFormatYUVLayout, alphaSize: int=0, alphaUsage: QPixelFormat.AlphaUsage=QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition=QPixelFormat.AtBeginning, premultiplied: QPixelFormat.AlphaPremultiplied=QPixelFormat.NotPremultiplied, typeInterpretation: QPixelFormat.TypeInterpretation=QPixelFormat.UnsignedByte, byteOrder: QPixelFormat.ByteOrder=QPixelFormat.LittleEndian):
    'qPixelFormatYuv(QPixelFormat.YUVLayout, alphaSize: int = 0, alphaUsage: QPixelFormat.AlphaUsage = QPixelFormat.IgnoresAlpha, alphaPosition: QPixelFormat.AlphaPosition = QPixelFormat.AtBeginning, premultiplied: QPixelFormat.AlphaPremultiplied = QPixelFormat.NotPremultiplied, typeInterpretation: QPixelFormat.TypeInterpretation = QPixelFormat.UnsignedByte, byteOrder: QPixelFormat.ByteOrder = QPixelFormat.LittleEndian) -> QPixelFormat'
    pass

def qPremultiply(QRgba64):
    'qPremultiply(QRgba64) -> QRgba64\nqPremultiply(int) -> int'
    pass

def qRed(QRgba64):
    'qRed(QRgba64) -> int\nqRed(int) -> int'
    return 1

def qRgb(int, int_, int_1):
    'qRgb(int, int, int) -> int'
    return 1

def qRgba(int, int_, int_1, int_2):
    'qRgba(int, int, int, int) -> int'
    return 1

def qRgba64(int, int_, int_1, int_2):
    'qRgba64(int, int, int, int) -> QRgba64\nqRgba64(int) -> QRgba64'
    pass

def qUnpremultiply(QRgba64):
    'qUnpremultiply(QRgba64) -> QRgba64\nqUnpremultiply(int) -> int'
    pass

def qt_set_sequence_auto_mnemonic(bool):
    'qt_set_sequence_auto_mnemonic(bool)'
    pass

