__doc__ = 'Bottleneck non-reducing functions that operate along an axis.'
__file__ = '/home/nj/.conda/envs/cs231n/lib/python3.6/site-packages/bottleneck/nonreduce_axis.cpython-36m-x86_64-linux-gnu.so'
__name__ = 'bottleneck.nonreduce_axis'
__package__ = 'bottleneck'
def argpartition(a, kth, axis=-1):
    "argpartition(a, kth, axis=-1)\n\nReturn indices that would partition array along the given axis.\n\nA 1d array B is partitioned at array index `kth` if three conditions\nare met: (1) B[kth] is in its sorted position, (2) all elements to the\nleft of `kth` are less than or equal to B[kth], and (3) all elements\nto the right of `kth` are greater than or equal to B[kth]. Note that\nthe array elements in conditions (2) and (3) are in general unordered.\n\nShuffling the input array may change the output. The only guarantee is\ngiven by the three conditions above.\n\nThis functions is not protected against NaN. Therefore, you may get\nunexpected results if the input contains NaN.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\nkth : int\n    The value of the element at index `kth` will be in its sorted\n    position. Smaller (larger) or equal values will be to the left\n    (right) of index `kth`.\naxis : {int, None}, optional\n    Axis along which the partition is performed. The default (axis=-1)\n    is to partition along the last axis.\n\nReturns\n-------\ny : ndarray\n    An array the same shape as the input array containing the indices\n    that partition `a`. The dtype of the indices is numpy.intp.\n\nSee Also\n--------\nbottleneck.partition: Partition array elements along given axis.\n\nNotes\n-----\nUnexpected results may occur if the input array contains NaN.\n\nExamples\n--------\nCreate a numpy array:\n\n>>> a = np.array([10, 0, 30, 40, 20])\n\nFind the indices that partition the array so that the first 3\nelements are the smallest 3 elements:\n\n>>> index = bn.argpartition(a, kth=2)\n>>> index\narray([0, 1, 4, 3, 2])\n\nLet's use the indices to partition the array (note, as in this\nexample, that the smallest 3 elements may not be in order):\n\n>>> a[index]\narray([10, 0, 20, 40, 30])\n\n"
    pass

def nanrankdata(a, axis=None):
    "nanrankdata(a, axis=None)\n\nRanks the data, dealing with ties and NaNs appropriately.\n\nEqual values are assigned a rank that is the average of the ranks that\nwould have been otherwise assigned to all of the values within that set.\nRanks begin at 1, not 0.\n\nNaNs in the input array are returned as NaNs.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the elements of the array are ranked. The default\n    (axis=None) is to rank the elements of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`. The dtype is 'float64'.\n\nSee also\n--------\nbottleneck.rankdata: Ranks the data, dealing with ties and appropriately.\n\nExamples\n--------\n>>> bn.nanrankdata([np.nan, 2, 2, 3])\narray([ nan,  1.5,  1.5,  3. ])\n>>> bn.nanrankdata([[np.nan, 2], [2, 3]])\narray([ nan,  1.5,  1.5,  3. ])\n>>> bn.nanrankdata([[np.nan, 2], [2, 3]], axis=0)\narray([[ nan,   1.],\n       [  1.,   2.]])\n>>> bn.nanrankdata([[np.nan, 2], [2, 3]], axis=1)\narray([[ nan,   1.],\n       [  1.,   2.]])\n\n"
    pass

def partition(a, kth, axis=-1):
    'partition(a, kth, axis=-1)\n\nPartition array elements along given axis.\n\nA 1d array B is partitioned at array index `kth` if three conditions\nare met: (1) B[kth] is in its sorted position, (2) all elements to the\nleft of `kth` are less than or equal to B[kth], and (3) all elements\nto the right of `kth` are greater than or equal to B[kth]. Note that\nthe array elements in conditions (2) and (3) are in general unordered.\n\nShuffling the input array may change the output. The only guarantee is\ngiven by the three conditions above.\n\nThis functions is not protected against NaN. Therefore, you may get\nunexpected results if the input contains NaN.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\nkth : int\n    The value of the element at index `kth` will be in its sorted\n    position. Smaller (larger) or equal values will be to the left\n    (right) of index `kth`.\naxis : {int, None}, optional\n    Axis along which the partition is performed. The default\n    (axis=-1) is to partition along the last axis.\n\nReturns\n-------\ny : ndarray\n    A partitioned copy of the input array with the same shape and\n    type of `a`.\n\nSee Also\n--------\nbottleneck.argpartition: Indices that would partition an array\n\nNotes\n-----\nUnexpected results may occur if the input array contains NaN.\n\nExamples\n--------\nCreate a numpy array:\n\n>>> a = np.array([1, 0, 3, 4, 2])\n\nPartition array so that the first 3 elements (indices 0, 1, 2) are the\nsmallest 3 elements (note, as in this example, that the smallest 3\nelements may not be sorted):\n\n>>> bn.partition(a, kth=2)\narray([1, 0, 2, 4, 3])\n\nNow Partition array so that the last 2 elements are the largest 2\nelements:\n\n>>> bn.partition(a, kth=3)\narray([1, 0, 2, 3, 4])\n\n'
    pass

def push(a, n=None, axis=-1):
    'push(a, n=None, axis=-1)\n\nFill missing values (NaNs) with most recent non-missing values.\n\nFilling proceeds along the specified axis from small index values to large\nindex values.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\nn : {int, None}, optional\n    How far to push values. If the most recent non-NaN array element is\n    more than `n` index positions away, than a NaN is returned. The default\n    (n = None) is to push the entire length of the slice. If `n` is an integer\n    it must be nonnegative.\naxis : int, optional\n    Axis along which the elements of the array are pushed. The default\n    (axis=-1) is to push along the last axis of the input array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape and dtype as `a`.\n\nSee also\n--------\nbottleneck.replace: Replace specified value of an array with new value.\n\nExamples\n--------\n>>> a = np.array([5, np.nan, np.nan, 6, np.nan])\n>>> bn.push(a)\n    array([ 5.,  5.,  5.,  6.,  6.])\n>>> bn.push(a, n=1)\n    array([  5.,   5.,  nan,   6.,   6.])\n>>> bn.push(a, n=2)\n    array([ 5.,  5.,  5.,  6.,  6.])\n\n'
    pass

def rankdata(a, axis=None):
    "rankdata(a, axis=None)\n\nRanks the data, dealing with ties appropriately.\n\nEqual values are assigned a rank that is the average of the ranks that\nwould have been otherwise assigned to all of the values within that set.\nRanks begin at 1, not 0.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the elements of the array are ranked. The default\n    (axis=None) is to rank the elements of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`. The dtype is 'float64'.\n\nSee also\n--------\nbottleneck.nanrankdata: Ranks the data dealing with ties and NaNs.\n\nExamples\n--------\n>>> bn.rankdata([0, 2, 2, 3])\narray([ 1. ,  2.5,  2.5,  4. ])\n>>> bn.rankdata([[0, 2], [2, 3]])\narray([ 1. ,  2.5,  2.5,  4. ])\n>>> bn.rankdata([[0, 2], [2, 3]], axis=0)\narray([[ 1.,  1.],\n       [ 2.,  2.]])\n>>> bn.rankdata([[0, 2], [2, 3]], axis=1)\narray([[ 1.,  2.],\n       [ 1.,  2.]])\n\n"
    pass

