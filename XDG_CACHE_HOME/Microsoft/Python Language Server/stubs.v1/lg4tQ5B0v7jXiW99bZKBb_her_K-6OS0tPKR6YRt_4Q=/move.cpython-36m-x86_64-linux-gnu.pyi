__doc__ = 'Bottleneck moving window functions.'
__file__ = '/home/nj/.conda/envs/cs231n/lib/python3.6/site-packages/bottleneck/move.cpython-36m-x86_64-linux-gnu.so'
__name__ = 'bottleneck.move'
__package__ = 'bottleneck'
def move_argmax(a, window, min_count=None, axis=-1):
    'move_argmax(a, window, min_count=None, axis=-1)\n\nMoving window index of maximum along the specified axis, optionally\nignoring NaNs.\n\nIndex 0 is at the rightmost edge of the window. For example, if the array\nis monotonically increasing (decreasing) along the specified axis then\nthe output array will contain zeros (window-1).\n\nIf there is a tie in input values within a window, then the rightmost\nindex is returned.\n\nfloat64 output is returned for all input data types.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving index of maximum values of the input array along the\n    specified axis. The output has the same shape as the input. The dtype\n    of the output is always float64.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> bn.move_argmax(a, window=2)\narray([ nan,   0.,   0.,   0.,   0.])\n\n>>> a = np.array([5.0, 4.0, 3.0, 2.0, 1.0])\n>>> bn.move_argmax(a, window=2)\narray([ nan,   1.,   1.,   1.,   1.])\n\n>>> a = np.array([2.0, 3.0, 4.0, 1.0, 7.0, 5.0, 6.0])\n>>> bn.move_argmax(a, window=3)\narray([ nan,  nan,   0.,   1.,   0.,   1.,   2.])\n\n'
    pass

def move_argmin(a, window, min_count=None, axis=-1):
    'move_argmin(a, window, min_count=None, axis=-1)\n\nMoving window index of minimum along the specified axis, optionally\nignoring NaNs.\n\nIndex 0 is at the rightmost edge of the window. For example, if the array\nis monotonically decreasing (increasing) along the specified axis then\nthe output array will contain zeros (window-1).\n\nIf there is a tie in input values within a window, then the rightmost\nindex is returned.\n\nfloat64 output is returned for all input data types.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving index of minimum values of the input array along the\n    specified axis. The output has the same shape as the input. The dtype\n    of the output is always float64.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n>>> bn.move_argmin(a, window=2)\narray([ nan,   1.,   1.,   1.,   1.])\n\n>>> a = np.array([5.0, 4.0, 3.0, 2.0, 1.0])\n>>> bn.move_argmin(a, window=2)\narray([ nan,   0.,   0.,   0.,   0.])\n\n>>> a = np.array([2.0, 3.0, 4.0, 1.0, 7.0, 5.0, 6.0])\n>>> bn.move_argmin(a, window=3)\narray([ nan,  nan,   2.,   0.,   1.,   2.,   1.])\n\n'
    pass

def move_max(a, window, min_count=None, axis=-1):
    'move_max(a, window, min_count=None, axis=-1)\n\nMoving window maximum along the specified axis, optionally ignoring NaNs.\n\nfloat64 output is returned for all input data types.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving maximum of the input array along the specified axis. The\n    output has the same shape as the input. The dtype of the output is\n    always float64.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_max(a, window=2)\narray([ nan,   2.,   3.,  nan,  nan])\n>>> bn.move_max(a, window=2, min_count=1)\narray([ 1.,  2.,  3.,  3.,  5.])\n\n'
    pass

def move_mean(a, window, min_count=None, axis=-1):
    'move_mean(a, window, min_count=None, axis=-1)\n\nMoving window mean along the specified axis, optionally ignoring NaNs.\n\nThis function cannot handle input arrays that contain Inf. When the\nwindow contains Inf, the output will correctly be Inf. However, when Inf\nmoves out of the window, the remaining output values in the slice will\nincorrectly be NaN.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving mean of the input array along the specified axis. The output\n    has the same shape as the input.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_mean(a, window=2)\narray([ nan,  1.5,  2.5,  nan,  nan])\n>>> bn.move_mean(a, window=2, min_count=1)\narray([ 1. ,  1.5,  2.5,  3. ,  5. ])\n\n'
    pass

def move_median(a, window, min_count=None, axis=-1):
    'move_median(a, window, min_count=None, axis=-1)\n\nMoving window median along the specified axis, optionally ignoring NaNs.\n\nfloat64 output is returned for all input data types.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving median of the input array along the specified axis. The\n    output has the same shape as the input.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, 4.0])\n>>> bn.move_median(a, window=2)\narray([ nan,  1.5,  2.5,  3.5])\n>>> bn.move_median(a, window=2, min_count=1)\narray([ 1. ,  1.5,  2.5,  3.5])\n\n'
    pass

def move_min(a, window, min_count=None, axis=-1):
    'move_min(a, window, min_count=None, axis=-1)\n\nMoving window minimum along the specified axis, optionally ignoring NaNs.\n\nfloat64 output is returned for all input data types.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving minimum of the input array along the specified axis. The\n    output has the same shape as the input. The dtype of the output is\n    always float64.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_min(a, window=2)\narray([ nan,   1.,   2.,  nan,  nan])\n>>> bn.move_min(a, window=2, min_count=1)\narray([ 1.,  1.,  2.,  3.,  5.])\n\n'
    pass

def move_rank(a, window, min_count=None, axis=-1):
    'move_rank(a, window, min_count=None, axis=-1)\n\nMoving window ranking along the specified axis, optionally ignoring NaNs.\n\nThe output is normalized to be between -1 and 1. For example, with a\nwindow width of 3 (and with no ties), the possible output values are\n-1, 0, 1.\n\nTies are broken by averaging the rankings. See the examples below.\n\nThe runtime depends almost linearly on `window`. The more NaNs there are\nin the input array, the shorter the runtime.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving ranking along the specified axis. The output has the same\n    shape as the input. For integer input arrays, the dtype of the output\n    is float64.\n\nExamples\n--------\nWith window=3 and no ties, there are 3 possible output values, i.e.\n[-1., 0., 1.]:\n\n>>> a = np.array([1, 2, 3, 9, 8, 7, 5, 6, 4])\n>>> bn.move_rank(a, window=3)\n    array([ nan,  nan,   1.,   1.,   0.,  -1.,  -1.,   0.,  -1.])\n\nTies are broken by averaging the rankings of the tied elements:\n\n>>> a = np.array([1, 2, 3, 3, 3, 4])\n>>> bn.move_rank(a, window=3)\n    array([ nan,  nan,  1. ,  0.5,  0. ,  1. ])\n\nIn an increasing sequence, the moving window ranking is always equal to 1:\n\n>>> a = np.array([1, 2, 3, 4, 5])\n>>> bn.move_rank(a, window=2)\n    array([ nan,   1.,   1.,   1.,   1.])\n\n'
    pass

def move_std(a, window, min_count=None, axis=-1, ddof=0):
    "move_std(a, window, min_count=None, axis=-1, ddof=0)\n\nMoving window standard deviation along the specified axis, optionally\nignoring NaNs.\n\nThis function cannot handle input arrays that contain Inf. When Inf\nenters the moving window, the outout becomes NaN and will continue to\nbe NaN for the remainer of the slice.\n\nUnlike bn.nanstd, which uses a two-pass algorithm, move_nanstd uses a\none-pass algorithm called Welford's method. The algorithm is slow but\nnumerically stable for cases where the mean is large compared to the\nstandard deviation.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\nddof : int, optional\n    Means Delta Degrees of Freedom. The divisor used in calculations\n    is ``N - ddof``, where ``N`` represents the number of elements.\n    By default `ddof` is zero.\n\nReturns\n-------\ny : ndarray\n    The moving standard deviation of the input array along the specified\n    axis. The output has the same shape as the input.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_std(a, window=2)\narray([ nan,  0.5,  0.5,  nan,  nan])\n>>> bn.move_std(a, window=2, min_count=1)\narray([ 0. ,  0.5,  0.5,  0. ,  0. ])\n\n"
    pass

def move_sum(a, window, min_count=None, axis=-1):
    'move_sum(a, window, min_count=None, axis=-1)\n\nMoving window sum along the specified axis, optionally ignoring NaNs.\n\nThis function cannot handle input arrays that contain Inf. When the\nwindow contains Inf, the output will correctly be Inf. However, when Inf\nmoves out of the window, the remaining output values in the slice will\nincorrectly be NaN.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\n\nReturns\n-------\ny : ndarray\n    The moving sum of the input array along the specified axis. The output\n    has the same shape as the input.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_sum(a, window=2)\narray([ nan,   3.,   5.,  nan,  nan])\n>>> bn.move_sum(a, window=2, min_count=1)\narray([ 1.,  3.,  5.,  3.,  5.])\n\n'
    pass

def move_var(a, window, min_count=None, axis=-1, ddof=0):
    "move_var(a, window, min_count=None, axis=-1, ddof=0)\n\nMoving window variance along the specified axis, optionally ignoring NaNs.\n\nThis function cannot handle input arrays that contain Inf. When Inf\nenters the moving window, the outout becomes NaN and will continue to\nbe NaN for the remainer of the slice.\n\nUnlike bn.nanvar, which uses a two-pass algorithm, move_nanvar uses a\none-pass algorithm called Welford's method. The algorithm is slow but\nnumerically stable for cases where the mean is large compared to the\nstandard deviation.\n\nParameters\n----------\na : ndarray\n    Input array. If `a` is not an array, a conversion is attempted.\nwindow : int\n    The number of elements in the moving window.\nmin_count: {int, None}, optional\n    If the number of non-NaN values in a window is less than `min_count`,\n    then a value of NaN is assigned to the window. By default `min_count`\n    is None, which is equivalent to setting `min_count` equal to `window`.\naxis : int, optional\n    The axis over which the window is moved. By default the last axis\n    (axis=-1) is used. An axis of None is not allowed.\nddof : int, optional\n    Means Delta Degrees of Freedom. The divisor used in calculations\n    is ``N - ddof``, where ``N`` represents the number of elements.\n    By default `ddof` is zero.\n\nReturns\n-------\ny : ndarray\n    The moving variance of the input array along the specified axis. The\n    output has the same shape as the input.\n\nExamples\n--------\n>>> a = np.array([1.0, 2.0, 3.0, np.nan, 5.0])\n>>> bn.move_var(a, window=2)\narray([ nan,  0.25,  0.25,  nan,  nan])\n>>> bn.move_var(a, window=2, min_count=1)\narray([ 0. ,  0.25,  0.25,  0. ,  0. ])\n\n"
    pass

