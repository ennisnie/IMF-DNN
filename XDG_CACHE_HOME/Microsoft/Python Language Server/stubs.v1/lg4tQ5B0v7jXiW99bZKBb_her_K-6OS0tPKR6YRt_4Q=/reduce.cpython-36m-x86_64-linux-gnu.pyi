__doc__ = 'Bottleneck functions that reduce the input array along a specified axis.'
__file__ = '/home/nj/.conda/envs/cs231n/lib/python3.6/site-packages/bottleneck/reduce.cpython-36m-x86_64-linux-gnu.so'
__name__ = 'bottleneck.reduce'
__package__ = 'bottleneck'
def allnan(a, axis=None):
    'allnan(a, axis=None)\n\nTest whether all array elements along a given axis are NaN.\n\nReturns the same output as np.isnan(a).all(axis)\n\nNote that allnan([]) is True to match np.isnan([]).all() and all([])\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which NaNs are searched. The default (`axis` = ``None``)\n    is to search for NaNs over a flattened input array.\n\nReturns\n-------\ny : bool or ndarray\n    A boolean or new `ndarray` is returned.\n\nSee also\n--------\nbottleneck.anynan: Test if any array element along given axis is NaN\n\nExamples\n--------\n>>> bn.allnan(1)\nFalse\n>>> bn.allnan(np.nan)\nTrue\n>>> bn.allnan([1, np.nan])\nFalse\n>>> a = np.array([[1, np.nan], [1, np.nan]])\n>>> bn.allnan(a)\nFalse\n>>> bn.allnan(a, axis=0)\narray([False,  True], dtype=bool)\n\nAn empty array returns True:\n\n>>> bn.allnan([])\nTrue\n\nwhich is similar to:\n\n>>> all([])\nTrue\n>>> np.isnan([]).all()\nTrue\n\n'
    pass

def anynan(a, axis=None):
    'anynan(a, axis=None)\n\nTest whether any array element along a given axis is NaN.\n\nReturns the same output as np.isnan(a).any(axis)\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which NaNs are searched. The default (`axis` = ``None``)\n    is to search for NaNs over a flattened input array.\n\nReturns\n-------\ny : bool or ndarray\n    A boolean or new `ndarray` is returned.\n\nSee also\n--------\nbottleneck.allnan: Test if all array elements along given axis are NaN\n\nExamples\n--------\n>>> bn.anynan(1)\nFalse\n>>> bn.anynan(np.nan)\nTrue\n>>> bn.anynan([1, np.nan])\nTrue\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.anynan(a)\nTrue\n>>> bn.anynan(a, axis=0)\narray([False,  True], dtype=bool)\n\n'
    pass

def median(a, axis=None):
    'median(a, axis=None)\n\nMedian of array elements along given axis.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the median is computed. The default (axis=None) is to\n    compute the median of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, except that the specified axis\n    has been removed. If `a` is a 0d array, or if axis is None, a scalar\n    is returned. `float64` return values are used for integer inputs. NaN\n    is returned for a slice that contains one or more NaNs.\n\nSee also\n--------\nbottleneck.nanmedian: Median along specified axis ignoring NaNs.\n\nExamples\n--------\n>>> a = np.array([[10, 7, 4], [3, 2, 1]])\n>>> bn.median(a)\n    3.5\n>>> bn.median(a, axis=0)\n    array([ 6.5,  4.5,  2.5])\n>>> bn.median(a, axis=1)\n    array([ 7.,  2.])\n\n'
    pass

def nanargmax(a, axis=None):
    'nanargmax(a, axis=None)\n\nIndices of the maximum values along an axis, ignoring NaNs.\n\nFor all-NaN slices ``ValueError`` is raised. Unlike NumPy, the results\ncan be trusted if a slice contains only NaNs and Infs.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which to operate. By default (axis=None) flattened input\n    is used.\n\nSee also\n--------\nbottleneck.nanargmin: Indices of the minimum values along an axis.\nbottleneck.nanmax: Maximum values along specified axis, ignoring NaNs.\n\nReturns\n-------\nindex_array : ndarray\n    An array of indices or a single index value.\n\nExamples\n--------\n>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> bn.nanargmax(a)\n1\n>>> a.flat[1]\n4.0\n>>> bn.nanargmax(a, axis=0)\narray([1, 0])\n>>> bn.nanargmax(a, axis=1)\narray([1, 1])\n\n'
    pass

def nanargmin(a, axis=None):
    'nanargmin(a, axis=None)\n\nIndices of the minimum values along an axis, ignoring NaNs.\n\nFor all-NaN slices ``ValueError`` is raised. Unlike NumPy, the results\ncan be trusted if a slice contains only NaNs and Infs.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which to operate. By default (axis=None) flattened input\n    is used.\n\nSee also\n--------\nbottleneck.nanargmax: Indices of the maximum values along an axis.\nbottleneck.nanmin: Minimum values along specified axis, ignoring NaNs.\n\nReturns\n-------\nindex_array : ndarray\n    An array of indices or a single index value.\n\nExamples\n--------\n>>> a = np.array([[np.nan, 4], [2, 3]])\n>>> bn.nanargmin(a)\n2\n>>> a.flat[2]\n2.0\n>>> bn.nanargmin(a, axis=0)\narray([1, 1])\n>>> bn.nanargmin(a, axis=1)\narray([1, 0])\n\n'
    pass

def nanmax(a, axis=None):
    'nanmax(a, axis=None)\n\nMaximum values along specified axis, ignoring NaNs.\n\nWhen all-NaN slices are encountered, NaN is returned for that slice.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the maximum is computed. The default (axis=None) is\n    to compute the maximum of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis removed.\n    If `a` is a 0-d array, or if axis is None, a scalar is returned. The\n    same dtype as `a` is returned.\n\nSee also\n--------\nbottleneck.nanmin: Minimum along specified axis, ignoring NaNs.\nbottleneck.nanargmax: Indices of maximum values along axis, ignoring NaNs.\n\nExamples\n--------\n>>> bn.nanmax(1)\n1\n>>> bn.nanmax([1])\n1\n>>> bn.nanmax([1, np.nan])\n1.0\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.nanmax(a)\n4.0\n>>> bn.nanmax(a, axis=0)\narray([ 1.,  4.])\n\n'
    pass

def nanmean(a, axis=None):
    'nanmean(a, axis=None)\n\nMean of array elements along given axis ignoring NaNs.\n\n`float64` intermediate and return values are used for integer inputs.\n\nParameters\n----------\na : array_like\n    Array containing numbers whose mean is desired. If `a` is not an\n    array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the means are computed. The default (axis=None) is to\n    compute the mean of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis removed.\n    If `a` is a 0-d array, or if axis is None, a scalar is returned.\n    `float64` intermediate and return values are used for integer inputs.\n\nSee also\n--------\nbottleneck.nanmedian: Median along specified axis, ignoring NaNs.\n\nNotes\n-----\nNo error is raised on overflow. (The sum is computed and then the result\nis divided by the number of non-NaN elements.)\n\nIf positive or negative infinity are present the result is positive or\nnegative infinity. But if both positive and negative infinity are present,\nthe result is Not A Number (NaN).\n\nExamples\n--------\n>>> bn.nanmean(1)\n1.0\n>>> bn.nanmean([1])\n1.0\n>>> bn.nanmean([1, np.nan])\n1.0\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.nanmean(a)\n2.0\n>>> bn.nanmean(a, axis=0)\narray([ 1.,  4.])\n\nWhen positive infinity and negative infinity are present:\n\n>>> bn.nanmean([1, np.nan, np.inf])\ninf\n>>> bn.nanmean([1, np.nan, np.NINF])\n-inf\n>>> bn.nanmean([1, np.nan, np.inf, np.NINF])\nnan\n\n'
    pass

def nanmedian(a, axis=None):
    'nanmedian(a, axis=None)\n\nMedian of array elements along given axis ignoring NaNs.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the median is computed. The default (axis=None) is to\n    compute the median of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, except that the specified axis\n    has been removed. If `a` is a 0d array, or if axis is None, a scalar\n    is returned. `float64` return values are used for integer inputs.\n\nSee also\n--------\nbottleneck.median: Median along specified axis.\n\nExamples\n--------\n>>> a = np.array([[np.nan, 7, 4], [3, 2, 1]])\n>>> a\narray([[ nan,   7.,   4.],\n       [  3.,   2.,   1.]])\n>>> bn.nanmedian(a)\n3.0\n>> bn.nanmedian(a, axis=0)\narray([ 3. ,  4.5,  2.5])\n>> bn.nanmedian(a, axis=1)\narray([ 5.5,  2. ])\n\n'
    pass

def nanmin(a, axis=None):
    'nanmin(a, axis=None)\n\nMinimum values along specified axis, ignoring NaNs.\n\nWhen all-NaN slices are encountered, NaN is returned for that slice.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the minimum is computed. The default (axis=None) is\n    to compute the minimum of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis removed.\n    If `a` is a 0-d array, or if axis is None, a scalar is returned. The\n    same dtype as `a` is returned.\n\nSee also\n--------\nbottleneck.nanmax: Maximum along specified axis, ignoring NaNs.\nbottleneck.nanargmin: Indices of minimum values along axis, ignoring NaNs.\n\nExamples\n--------\n>>> bn.nanmin(1)\n1\n>>> bn.nanmin([1])\n1\n>>> bn.nanmin([1, np.nan])\n1.0\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.nanmin(a)\n1.0\n>>> bn.nanmin(a, axis=0)\narray([ 1.,  4.])\n\n'
    pass

def nanstd(a, axis=None, ddof=0):
    'nanstd(a, axis=None, ddof=0)\n\nStandard deviation along the specified axis, ignoring NaNs.\n\n`float64` intermediate and return values are used for integer inputs.\n\nInstead of a faster one-pass algorithm, a more stable two-pass algorithm\nis used.\n\nAn example of a one-pass algorithm:\n\n    >>> np.sqrt((a*a).mean() - a.mean()**2)\n\nAn example of a two-pass algorithm:\n\n    >>> np.sqrt(((a - a.mean())**2).mean())\n\nNote in the two-pass algorithm the mean must be found (first pass) before\nthe squared deviation (second pass) can be found.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the standard deviation is computed. The default\n    (axis=None) is to compute the standard deviation of the flattened\n    array.\nddof : int, optional\n    Means Delta Degrees of Freedom. The divisor used in calculations\n    is ``N - ddof``, where ``N`` represents the number of non-NaN elements.\n    By default `ddof` is zero.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis removed.\n    If `a` is a 0-d array, or if axis is None, a scalar is returned.\n    `float64` intermediate and return values are used for integer inputs.\n    If ddof is >= the number of non-NaN elements in a slice or the slice\n    contains only NaNs, then the result for that slice is NaN.\n\nSee also\n--------\nbottleneck.nanvar: Variance along specified axis ignoring NaNs\n\nNotes\n-----\nIf positive or negative infinity are present the result is Not A Number\n(NaN).\n\nExamples\n--------\n>>> bn.nanstd(1)\n0.0\n>>> bn.nanstd([1])\n0.0\n>>> bn.nanstd([1, np.nan])\n0.0\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.nanstd(a)\n1.4142135623730951\n>>> bn.nanstd(a, axis=0)\narray([ 0.,  0.])\n\nWhen positive infinity or negative infinity are present NaN is returned:\n\n>>> bn.nanstd([1, np.nan, np.inf])\nnan\n\n'
    pass

def nansum(a, axis=None):
    'nansum(a, axis=None)\n\nSum of array elements along given axis treating NaNs as zero.\n\nThe data type (dtype) of the output is the same as the input. On 64-bit\noperating systems, 32-bit input is NOT upcast to 64-bit accumulator and\nreturn values.\n\nParameters\n----------\na : array_like\n    Array containing numbers whose sum is desired. If `a` is not an\n    array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the sum is computed. The default (axis=None) is to\n    compute the sum of the flattened array.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis removed.\n    If `a` is a 0-d array, or if axis is None, a scalar is returned.\n\nNotes\n-----\nNo error is raised on overflow.\n\nIf positive or negative infinity are present the result is positive or\nnegative infinity. But if both positive and negative infinity are present,\nthe result is Not A Number (NaN).\n\nExamples\n--------\n>>> bn.nansum(1)\n1\n>>> bn.nansum([1])\n1\n>>> bn.nansum([1, np.nan])\n1.0\n>>> a = np.array([[1, 1], [1, np.nan]])\n>>> bn.nansum(a)\n3.0\n>>> bn.nansum(a, axis=0)\narray([ 2.,  1.])\n\nWhen positive infinity and negative infinity are present:\n\n>>> bn.nansum([1, np.nan, np.inf])\ninf\n>>> bn.nansum([1, np.nan, np.NINF])\n-inf\n>>> bn.nansum([1, np.nan, np.inf, np.NINF])\nnan\n\n'
    pass

def nanvar(a, axis=None, ddof=0):
    'nanvar(a, axis=None, ddof=0)\n\nVariance along the specified axis, ignoring NaNs.\n\n`float64` intermediate and return values are used for integer inputs.\n\nInstead of a faster one-pass algorithm, a more stable two-pass algorithm\nis used.\n\nAn example of a one-pass algorithm:\n\n    >>> (a*a).mean() - a.mean()**2\n\nAn example of a two-pass algorithm:\n\n    >>> ((a - a.mean())**2).mean()\n\nNote in the two-pass algorithm the mean must be found (first pass) before\nthe squared deviation (second pass) can be found.\n\nParameters\n----------\na : array_like\n    Input array. If `a` is not an array, a conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the variance is computed. The default (axis=None) is\n    to compute the variance of the flattened array.\nddof : int, optional\n    Means Delta Degrees of Freedom. The divisor used in calculations\n    is ``N - ddof``, where ``N`` represents the number of non_NaN elements.\n    By default `ddof` is zero.\n\nReturns\n-------\ny : ndarray\n    An array with the same shape as `a`, with the specified axis\n    removed. If `a` is a 0-d array, or if axis is None, a scalar is\n    returned. `float64` intermediate and return values are used for\n    integer inputs. If ddof is >= the number of non-NaN elements in a\n    slice or the slice contains only NaNs, then the result for that slice\n    is NaN.\n\nSee also\n--------\nbottleneck.nanstd: Standard deviation along specified axis ignoring NaNs.\n\nNotes\n-----\nIf positive or negative infinity are present the result is Not A Number\n(NaN).\n\nExamples\n--------\n>>> bn.nanvar(1)\n0.0\n>>> bn.nanvar([1])\n0.0\n>>> bn.nanvar([1, np.nan])\n0.0\n>>> a = np.array([[1, 4], [1, np.nan]])\n>>> bn.nanvar(a)\n2.0\n>>> bn.nanvar(a, axis=0)\narray([ 0.,  0.])\n\nWhen positive infinity or negative infinity are present NaN is returned:\n\n>>> bn.nanvar([1, np.nan, np.inf])\nnan\n\n'
    pass

def ss(a, axis=None):
    'ss(a, axis=None)\n\nSum of the square of each element along the specified axis.\n\nParameters\n----------\na : array_like\n    Array whose sum of squares is desired. If `a` is not an array, a\n    conversion is attempted.\naxis : {int, None}, optional\n    Axis along which the sum of squares is computed. The default\n    (axis=None) is to sum the squares of the flattened array.\n\nReturns\n-------\ny : ndarray\n    The sum of a**2 along the given axis.\n\nExamples\n--------\n>>> a = np.array([1., 2., 5.])\n>>> bn.ss(a)\n30.0\n\nAnd calculating along an axis:\n\n>>> b = np.array([[1., 2., 5.], [2., 5., 6.]])\n>>> bn.ss(b, axis=1)\narray([ 30., 65.])\n\n'
    pass

